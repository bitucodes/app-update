{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar _require = require(\"tapable\"),\n  Tapable = _require.Tapable,\n  SyncHook = _require.SyncHook,\n  MultiHook = _require.MultiHook;\nvar asyncLib = require(\"neo-async\");\nvar MultiWatching = require(\"./MultiWatching\");\nvar MultiStats = require(\"./MultiStats\");\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nmodule.exports = /*#__PURE__*/function (_Tapable) {\n  _inherits(MultiCompiler, _Tapable);\n  function MultiCompiler(compilers) {\n    var _this;\n    _classCallCheck(this, MultiCompiler);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MultiCompiler).call(this));\n    _this.hooks = {\n      done: new SyncHook([\"stats\"]),\n      invalid: new MultiHook(compilers.map(function (c) {\n        return c.hooks.invalid;\n      })),\n      run: new MultiHook(compilers.map(function (c) {\n        return c.hooks.run;\n      })),\n      watchClose: new SyncHook([]),\n      watchRun: new MultiHook(compilers.map(function (c) {\n        return c.hooks.watchRun;\n      }))\n    };\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(function (name) {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n    _this.compilers = compilers;\n    var doneCompilers = 0;\n    var compilerStats = [];\n    var index = 0;\n    var _iterator = _createForOfIteratorHelper(_this.compilers),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var compiler = _step.value;\n        var compilerDone = false;\n        var compilerIndex = index++;\n        // eslint-disable-next-line no-loop-func\n        compiler.hooks.done.tap(\"MultiCompiler\", function (stats) {\n          if (!compilerDone) {\n            compilerDone = true;\n            doneCompilers++;\n          }\n          compilerStats[compilerIndex] = stats;\n          if (doneCompilers === _this.compilers.length) {\n            _this.hooks.done.call(new MultiStats(compilerStats));\n          }\n        });\n        // eslint-disable-next-line no-loop-func\n        compiler.hooks.invalid.tap(\"MultiCompiler\", function () {\n          if (compilerDone) {\n            compilerDone = false;\n            doneCompilers--;\n          }\n        });\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    _this.running = false;\n    return _this;\n  }\n  _createClass(MultiCompiler, [{\n    key: \"validateDependencies\",\n    value: function validateDependencies(callback) {\n      var _this2 = this;\n      var edges = new Set();\n      var missing = [];\n      var targetFound = function targetFound(compiler) {\n        var _iterator2 = _createForOfIteratorHelper(edges),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var edge = _step2.value;\n            if (edge.target === compiler) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        return false;\n      };\n      var sortEdges = function sortEdges(e1, e2) {\n        return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n      };\n      var _iterator3 = _createForOfIteratorHelper(this.compilers),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var source = _step3.value;\n          if (source.dependencies) {\n            var _iterator5 = _createForOfIteratorHelper(source.dependencies),\n              _step5;\n            try {\n              var _loop2 = function _loop2() {\n                var dep = _step5.value;\n                var target = _this2.compilers.find(function (c) {\n                  return c.name === dep;\n                });\n                if (!target) {\n                  missing.push(dep);\n                } else {\n                  edges.add({\n                    source: source,\n                    target: target\n                  });\n                }\n              };\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var errors = missing.map(function (m) {\n        return \"Compiler dependency `\".concat(m, \"` not found.\");\n      });\n      var stack = this.compilers.filter(function (c) {\n        return !targetFound(c);\n      });\n      while (stack.length > 0) {\n        var current = stack.pop();\n        var _iterator4 = _createForOfIteratorHelper(edges),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var edge = _step4.value;\n            if (edge.source === current) {\n              edges.delete(edge);\n              var target = edge.target;\n              if (!targetFound(target)) {\n                stack.push(target);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      if (edges.size > 0) {\n        var lines = Array.from(edges).sort(sortEdges).map(function (edge) {\n          return \"\".concat(edge.source.name, \" -> \").concat(edge.target.name);\n        });\n        lines.unshift(\"Circular dependency found in compiler dependencies.\");\n        errors.unshift(lines.join(\"\\n\"));\n      }\n      if (errors.length > 0) {\n        var message = errors.join(\"\\n\");\n        callback(new Error(message));\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"runWithDependencies\",\n    value: function runWithDependencies(compilers, fn, callback) {\n      var fulfilledNames = new Set();\n      var remainingCompilers = compilers;\n      var isDependencyFulfilled = function isDependencyFulfilled(d) {\n        return fulfilledNames.has(d);\n      };\n      var getReadyCompilers = function getReadyCompilers() {\n        var readyCompilers = [];\n        var list = remainingCompilers;\n        remainingCompilers = [];\n        var _iterator6 = _createForOfIteratorHelper(list),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var c = _step6.value;\n            var ready = !c.dependencies || c.dependencies.every(isDependencyFulfilled);\n            if (ready) {\n              readyCompilers.push(c);\n            } else {\n              remainingCompilers.push(c);\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        return readyCompilers;\n      };\n      var runCompilers = function runCompilers(callback) {\n        if (remainingCompilers.length === 0) return callback();\n        asyncLib.map(getReadyCompilers(), function (compiler, callback) {\n          fn(compiler, function (err) {\n            if (err) return callback(err);\n            fulfilledNames.add(compiler.name);\n            runCompilers(callback);\n          });\n        }, callback);\n      };\n      runCompilers(callback);\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      var _this3 = this;\n      if (this.running) return handler(new ConcurrentCompilationError());\n      var watchings = [];\n      var allStats = this.compilers.map(function () {\n        return null;\n      });\n      var compilerStatus = this.compilers.map(function () {\n        return false;\n      });\n      if (this.validateDependencies(handler)) {\n        this.running = true;\n        this.runWithDependencies(this.compilers, function (compiler, callback) {\n          var compilerIdx = _this3.compilers.indexOf(compiler);\n          var firstRun = true;\n          var watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, function (err, stats) {\n            if (err) handler(err);\n            if (stats) {\n              allStats[compilerIdx] = stats;\n              compilerStatus[compilerIdx] = \"new\";\n              if (compilerStatus.every(Boolean)) {\n                var freshStats = allStats.filter(function (s, idx) {\n                  return compilerStatus[idx] === \"new\";\n                });\n                compilerStatus.fill(true);\n                var multiStats = new MultiStats(freshStats);\n                handler(null, multiStats);\n              }\n            }\n            if (firstRun && !err) {\n              firstRun = false;\n              callback();\n            }\n          });\n          watchings.push(watching);\n        }, function () {\n          // ignore\n        });\n      }\n      return new MultiWatching(watchings, this);\n    }\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this4 = this;\n      if (this.running) {\n        return callback(new ConcurrentCompilationError());\n      }\n      var finalCallback = function finalCallback(err, stats) {\n        _this4.running = false;\n        if (callback !== undefined) {\n          return callback(err, stats);\n        }\n      };\n      var allStats = this.compilers.map(function () {\n        return null;\n      });\n      if (this.validateDependencies(callback)) {\n        this.running = true;\n        this.runWithDependencies(this.compilers, function (compiler, callback) {\n          var compilerIdx = _this4.compilers.indexOf(compiler);\n          compiler.run(function (err, stats) {\n            if (err) {\n              return callback(err);\n            }\n            allStats[compilerIdx] = stats;\n            callback();\n          });\n        }, function (err) {\n          if (err) {\n            return finalCallback(err);\n          }\n          finalCallback(null, new MultiStats(allStats));\n        });\n      }\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      var _iterator7 = _createForOfIteratorHelper(this.compilers),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var compiler = _step7.value;\n          if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n            compiler.inputFileSystem.purge();\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"outputPath\",\n    get: function get() {\n      var commonPath = this.compilers[0].outputPath;\n      var _iterator8 = _createForOfIteratorHelper(this.compilers),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var compiler = _step8.value;\n          while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n            commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n      return commonPath;\n    }\n  }, {\n    key: \"inputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator9 = _createForOfIteratorHelper(this.compilers),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var compiler = _step9.value;\n          compiler.inputFileSystem = value;\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }, {\n    key: \"outputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator10 = _createForOfIteratorHelper(this.compilers),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var compiler = _step10.value;\n          compiler.outputFileSystem = value;\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }]);\n  return MultiCompiler;\n}(Tapable);","map":null,"metadata":{},"sourceType":"script"}