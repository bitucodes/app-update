{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar merge = require('deepmerge');\nvar he = require('he');\nvar htmlparser = require('htmlparser2');\nvar _require = require('./block-text-builder'),\n  BlockTextBuilder = _require.BlockTextBuilder;\nvar defaultFormatters = require('./formatter');\nvar _require2 = require('./helper'),\n  limitedDepthRecursive = _require2.limitedDepthRecursive,\n  set = _require2.set,\n  splitSelector = _require2.splitSelector; // eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */\nvar DEFAULT_OPTIONS = {\n  baseElement: 'body',\n  decodeOptions: {\n    isAttributeValue: false,\n    strict: false\n  },\n  formatters: {},\n  limits: {\n    ellipsis: '...',\n    maxChildNodes: undefined,\n    maxDepth: undefined,\n    maxInputLength: 1 << 24 // 16_777_216\n  },\n\n  longWordSplit: {\n    forceWrapOnLimit: false,\n    wrapCharacters: []\n  },\n  preserveNewlines: false,\n  returnDomByDefault: true,\n  tables: [],\n  tags: {\n    '': {\n      format: 'inline'\n    },\n    // defaults for any other tag name\n    'a': {\n      format: 'anchor',\n      options: {\n        baseUrl: null,\n        hideLinkHrefIfSameAsText: false,\n        ignoreHref: false,\n        noAnchorUrl: true,\n        noLinkBrackets: false\n      }\n    },\n    'article': {\n      format: 'block'\n    },\n    'aside': {\n      format: 'block'\n    },\n    'blockquote': {\n      format: 'blockquote',\n      options: {\n        leadingLineBreaks: 2,\n        trailingLineBreaks: 2,\n        trimEmptyLines: true\n      }\n    },\n    'br': {\n      format: 'lineBreak'\n    },\n    'div': {\n      format: 'block'\n    },\n    'footer': {\n      format: 'block'\n    },\n    'form': {\n      format: 'block'\n    },\n    'h1': {\n      format: 'heading',\n      options: {\n        leadingLineBreaks: 3,\n        trailingLineBreaks: 2,\n        uppercase: true\n      }\n    },\n    'h2': {\n      format: 'heading',\n      options: {\n        leadingLineBreaks: 3,\n        trailingLineBreaks: 2,\n        uppercase: true\n      }\n    },\n    'h3': {\n      format: 'heading',\n      options: {\n        leadingLineBreaks: 3,\n        trailingLineBreaks: 2,\n        uppercase: true\n      }\n    },\n    'h4': {\n      format: 'heading',\n      options: {\n        leadingLineBreaks: 2,\n        trailingLineBreaks: 2,\n        uppercase: true\n      }\n    },\n    'h5': {\n      format: 'heading',\n      options: {\n        leadingLineBreaks: 2,\n        trailingLineBreaks: 2,\n        uppercase: true\n      }\n    },\n    'h6': {\n      format: 'heading',\n      options: {\n        leadingLineBreaks: 2,\n        trailingLineBreaks: 2,\n        uppercase: true\n      }\n    },\n    'header': {\n      format: 'block'\n    },\n    'hr': {\n      format: 'horizontalLine',\n      options: {\n        leadingLineBreaks: 2,\n        length: undefined,\n        trailingLineBreaks: 2\n      }\n    },\n    'img': {\n      format: 'image',\n      options: {\n        baseUrl: null\n      }\n    },\n    'main': {\n      format: 'block'\n    },\n    'nav': {\n      format: 'block'\n    },\n    'ol': {\n      format: 'orderedList',\n      options: {\n        leadingLineBreaks: 2,\n        trailingLineBreaks: 2\n      }\n    },\n    'p': {\n      format: 'paragraph',\n      options: {\n        leadingLineBreaks: 2,\n        trailingLineBreaks: 2\n      }\n    },\n    'pre': {\n      format: 'pre',\n      options: {\n        leadingLineBreaks: 2,\n        trailingLineBreaks: 2\n      }\n    },\n    'section': {\n      format: 'block'\n    },\n    'table': {\n      format: 'table',\n      options: {\n        colSpacing: 3,\n        leadingLineBreaks: 2,\n        maxColumnWidth: 60,\n        rowSpacing: 0,\n        trailingLineBreaks: 2,\n        uppercaseHeaderCells: true\n      }\n    },\n    'ul': {\n      format: 'unorderedList',\n      options: {\n        itemPrefix: ' * ',\n        leadingLineBreaks: 2,\n        trailingLineBreaks: 2\n      }\n    },\n    'wbr': {\n      format: 'wbr'\n    }\n  },\n  whitespaceCharacters: \" \\t\\r\\n\\f\\u200B\",\n  wordwrap: 80\n};\n\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { htmlToText } = require('html-to-text');\n * const text = htmlToText('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */\nfunction htmlToText(html) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = merge(DEFAULT_OPTIONS, options, {\n    arrayMerge: function arrayMerge(destinationArray, sourceArray, mergeOptions) {\n      return sourceArray;\n    }\n  });\n  options.formatters = Object.assign({}, defaultFormatters, options.formatters);\n  handleDeprecatedOptions(options);\n  var maxInputLength = options.limits.maxInputLength;\n  if (maxInputLength && html && html.length > maxInputLength) {\n    console.warn(\"Input length \".concat(html.length, \" is above allowed limit of \").concat(maxInputLength, \". Truncating without ellipsis.\"));\n    html = html.substring(0, maxInputLength);\n  }\n  var handler = new htmlparser.DefaultHandler();\n  new htmlparser.Parser(handler, {\n    decodeEntities: false\n  }).parseComplete(html);\n  var limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function (dom, builder) {\n    builder.addInline(options.limits.ellipsis || '');\n  });\n  var baseElements = Array.isArray(options.baseElement) ? options.baseElement : [options.baseElement];\n  var bases = baseElements.map(function (be) {\n    return findBase(handler.dom, options, be);\n  }).filter(function (b) {\n    return b;\n  }).reduce(function (acc, b) {\n    return acc.concat(b);\n  }, []);\n  var builder = new BlockTextBuilder(options);\n  limitedWalk(bases, builder);\n  return builder.toString();\n}\n\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */\nfunction handleDeprecatedOptions(options) {\n  var tagDefinitions = Object.values(options.tags);\n  function copyFormatterOption(source, format, target) {\n    if (options[source] === undefined) {\n      return;\n    }\n    for (var _i = 0, _tagDefinitions = tagDefinitions; _i < _tagDefinitions.length; _i++) {\n      var tagDefinition = _tagDefinitions[_i];\n      if (tagDefinition.format === format) {\n        set(tagDefinition, ['options', target], options[source]);\n      }\n    }\n  }\n  copyFormatterOption('hideLinkHrefIfSameAsText', 'anchor', 'hideLinkHrefIfSameAsText');\n  copyFormatterOption('ignoreHref', 'anchor', 'ignoreHref');\n  copyFormatterOption('linkHrefBaseUrl', 'anchor', 'baseUrl');\n  copyFormatterOption('noAnchorUrl', 'anchor', 'noAnchorUrl');\n  copyFormatterOption('noLinkBrackets', 'anchor', 'noLinkBrackets');\n  copyFormatterOption('linkHrefBaseUrl', 'image', 'baseUrl');\n  copyFormatterOption('unorderedListItemPrefix', 'unorderedList', 'itemPrefix');\n  copyFormatterOption('uppercaseHeadings', 'heading', 'uppercase');\n  copyFormatterOption('uppercaseHeadings', 'table', 'uppercaseHeadings');\n  copyFormatterOption('uppercaseHeadings', 'dataTable', 'uppercaseHeadings');\n  if (options['ignoreImage']) {\n    var _iterator = _createForOfIteratorHelper(tagDefinitions),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var tagDefinition = _step.value;\n        if (tagDefinition.format === 'image') {\n          tagDefinition.format = 'skip';\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  if (options['singleNewLineParagraphs']) {\n    var _iterator2 = _createForOfIteratorHelper(tagDefinitions),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _tagDefinition = _step2.value;\n        if (_tagDefinition.format === 'paragraph' || _tagDefinition.format === 'pre') {\n          set(_tagDefinition, ['options', 'leadingLineBreaks'], 1);\n          set(_tagDefinition, ['options', 'trailingLineBreaks'], 1);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n}\nfunction findBase(dom, options, baseElement) {\n  var result = null;\n  var splitTag = splitSelector(baseElement);\n  function recursiveWalk(walk, /** @type { DomNode[] } */dom) {\n    if (result) {\n      return;\n    }\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    var _iterator3 = _createForOfIteratorHelper(dom),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var elem = _step3.value;\n        if (result) {\n          return;\n        }\n        if (elem.name === splitTag.element) {\n          var _ret = function () {\n            var documentClasses = elem.attribs && elem.attribs.class ? elem.attribs.class.split(' ') : [];\n            var documentIds = elem.attribs && elem.attribs.id ? elem.attribs.id.split(' ') : [];\n            if (splitTag.classes.every(function (val) {\n              return documentClasses.indexOf(val) >= 0;\n            }) && splitTag.ids.every(function (val) {\n              return documentIds.indexOf(val) >= 0;\n            })) {\n              result = [elem];\n              return {\n                v: void 0\n              };\n            }\n          }();\n          if (typeof _ret === \"object\") return _ret.v;\n        }\n        if (elem.children) {\n          walk(elem.children);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  var limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);\n  limitedWalk(dom);\n  return options.returnDomByDefault ? result || dom : result;\n}\n\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */\nfunction recursiveWalk(walk, dom, builder) {\n  if (!dom) {\n    return;\n  }\n  var options = builder.options;\n  var tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n  if (tooManyChildNodes) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    dom.push({\n      data: options.limits.ellipsis,\n      type: 'text'\n    });\n  }\n  var _iterator4 = _createForOfIteratorHelper(dom),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var elem = _step4.value;\n      switch (elem.type) {\n        case 'text':\n          {\n            builder.addInline(he.decode(elem.data, options.decodeOptions));\n            break;\n          }\n        case 'tag':\n          {\n            var tags = options.tags;\n            var tagDefinition = tags[elem.name] || tags[''];\n            var format = options.formatters[tagDefinition.format];\n            format(elem, walk, builder, tagDefinition.options || {});\n            break;\n          }\n        default:\n          /* do nothing */\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return;\n}\n\n/**\n * @deprecated Import/require `{ htmlToText }` function instead!\n * @see htmlToText\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @returns { string }                 Plain text string.\n * @static\n */\nvar fromString = function fromString(html) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return htmlToText(html, options);\n};\nmodule.exports = {\n  htmlToText: htmlToText,\n  fromString: fromString\n};","map":null,"metadata":{},"sourceType":"script"}