{"ast":null,"code":"var _classCallCheck = require(\"/home/lenovo/Desktop/apitest/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/apitest/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _require = require('./helper'),\n  trimCharacter = _require.trimCharacter; // eslint-disable-next-line no-unused-vars\nvar _require2 = require('./stack-item'),\n  StackItem = _require2.StackItem,\n  BlockStackItem = _require2.BlockStackItem,\n  TableCellStackItem = _require2.TableCellStackItem,\n  TableRowStackItem = _require2.TableRowStackItem,\n  TableStackItem = _require2.TableStackItem,\n  TransformerStackItem = _require2.TransformerStackItem;\nvar _require3 = require('./table-printer'),\n  tableToString = _require3.tableToString;\nvar _require4 = require('./whitespace-processor'),\n  WhitespaceProcessor = _require4.WhitespaceProcessor; // eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nvar BlockTextBuilder = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   */\n  function BlockTextBuilder(options) {\n    _classCallCheck(this, BlockTextBuilder);\n    this.options = options;\n    this.whitepaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  _createClass(BlockTextBuilder, [{\n    key: \"pushWordTransform\",\n    value: function pushWordTransform(wordTransform) {\n      this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n    }\n    /**\n     * Remove a function from the word transformations stack.\n     *\n     * @returns { (str: string) => string } A function that was removed.\n     */\n  }, {\n    key: \"popWordTransform\",\n    value: function popWordTransform() {\n      if (!this._wordTransformer) {\n        return undefined;\n      }\n      var transform = this._wordTransformer.transform;\n      this._wordTransformer = this._wordTransformer.next;\n      return transform;\n    } /** @returns { (str: string) => string } */\n  }, {\n    key: \"_getCombinedWordTransformer\",\n    value: function _getCombinedWordTransformer() {\n      var _this = this;\n      var applyTransformer = function applyTransformer(str, transformer) {\n        return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n      };\n      return function (str) {\n        return applyTransformer(str, _this._wordTransformer);\n      };\n    }\n  }, {\n    key: \"_popStackItem\",\n    value: function _popStackItem() {\n      var item = this._stackItem;\n      this._stackItem = item.next;\n      return item;\n    }\n    /**\n     * Add a line break into currently built block.\n     */\n  }, {\n    key: \"addLineBreak\",\n    value: function addLineBreak() {\n      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n        return;\n      }\n      if (this._stackItem.isPre) {\n        this._stackItem.rawText += '\\n';\n      } else {\n        this._stackItem.inlineTextBuilder.startNewLine();\n      }\n    }\n    /**\n     * Allow to break line in case directly following text will not fit.\n     */\n  }, {\n    key: \"addWordBreakOpportunity\",\n    value: function addWordBreakOpportunity() {\n      if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem) {\n        this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n      }\n    }\n    /**\n     * Add a node inline into the currently built block.\n     *\n     * @param { string } str\n     * Text content of a node to add.\n     *\n     * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n     * Object holding the parameters of the operation.\n     *\n     * Boolean value is deprecated.\n     *\n     * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n     * Ignore word transformers if there are any.\n     */\n  }, {\n    key: \"addInline\",\n    value: function addInline(str) {\n      var optionsObjectOrNoWordTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof optionsObjectOrNoWordTransform === 'object') {\n        this._addInline(str, optionsObjectOrNoWordTransform);\n      } else {\n        this._addInline(str, {\n          noWordTransform: optionsObjectOrNoWordTransform\n        });\n      }\n    }\n  }, {\n    key: \"_addInline\",\n    value: function _addInline(str) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$noWordTransform = _ref.noWordTransform,\n        noWordTransform = _ref$noWordTransform === void 0 ? false : _ref$noWordTransform;\n      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n        return;\n      }\n      if (this._stackItem.isPre) {\n        this._stackItem.rawText += str;\n        return;\n      }\n      if (this.whitepaceProcessor.testContainsWords(str) ||\n      // There are words to add;\n      str.length && !this._stackItem.stashedLineBreaks // or at least spaces to take into account.\n      ) {\n        if (this._stackItem.stashedLineBreaks) {\n          this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n        this.whitepaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, this._wordTransformer && !noWordTransform ? this._getCombinedWordTransformer() : undefined);\n        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n      }\n    }\n    /**\n     * Start building a new block.\n     *\n     * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n     * Object holding the parameters of the block.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n     * This block should have at least this number of line breaks to separate if from any preceding block.\n     *\n     * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n     * Reserve this number of characters on each line for block markup.\n     *\n     * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n     * Should HTML whitespace be preserved inside this block.\n     *\n     * @param { number }  [reservedLineLength]\n     * Deprecated.\n     *\n     * @param { boolean } [isPre]\n     * Deprecated.\n     */\n  }, {\n    key: \"openBlock\",\n    value: function openBlock() {\n      var optionsObjectOrLeadingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var reservedLineLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var isPre = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n        this._openBlock(optionsObjectOrLeadingLineBreaks);\n      } else {\n        this._openBlock({\n          isPre: isPre,\n          leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n          reservedLineLength: reservedLineLength\n        });\n      }\n    }\n  }, {\n    key: \"_openBlock\",\n    value: function _openBlock() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$leadingLineBrea = _ref2.leadingLineBreaks,\n        leadingLineBreaks = _ref2$leadingLineBrea === void 0 ? 1 : _ref2$leadingLineBrea,\n        _ref2$reservedLineLen = _ref2.reservedLineLength,\n        reservedLineLength = _ref2$reservedLineLen === void 0 ? 0 : _ref2$reservedLineLen,\n        _ref2$isPre = _ref2.isPre,\n        isPre = _ref2$isPre === void 0 ? false : _ref2$isPre;\n      var maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n      this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n      if (isPre) {\n        this._stackItem.isPre = true;\n      }\n    }\n    /**\n     * Finalize currently built block, add it's content to the parent block.\n     *\n     * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n     * Object holding the parameters of the block.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n     * This block should have at least this number of line breaks to separate it from any following block.\n     *\n     * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n     * A function to transform the block text before adding to the parent block.\n     * This happens after word wrap and should be used in combination with reserved line length\n     * in order to keep line lengths correct.\n     * Used for whole block markup.\n     *\n     * @param { (str: string) => string } [blockTransform]\n     * Deprecated.\n     */\n  }, {\n    key: \"closeBlock\",\n    value: function closeBlock() {\n      var optionsObjectOrTrailingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var blockTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n        this._closeBlock(optionsObjectOrTrailingLineBreaks);\n      } else {\n        this._closeBlock({\n          trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n          blockTransform: blockTransform\n        });\n      }\n    }\n  }, {\n    key: \"_closeBlock\",\n    value: function _closeBlock() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$trailingLineBre = _ref3.trailingLineBreaks,\n        trailingLineBreaks = _ref3$trailingLineBre === void 0 ? 1 : _ref3$trailingLineBre,\n        _ref3$blockTransform = _ref3.blockTransform,\n        blockTransform = _ref3$blockTransform === void 0 ? undefined : _ref3$blockTransform;\n      var block = this._popStackItem();\n      var blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n      addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n    }\n    /**\n     * Start building a table.\n     */\n  }, {\n    key: \"openTable\",\n    value: function openTable() {\n      this._stackItem = new TableStackItem(this._stackItem);\n    }\n    /**\n     * Start building a table row.\n     */\n  }, {\n    key: \"openTableRow\",\n    value: function openTableRow() {\n      if (!(this._stackItem instanceof TableStackItem)) {\n        throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n      }\n      this._stackItem = new TableRowStackItem(this._stackItem);\n    }\n    /**\n     * Start building a table cell.\n     *\n     * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n     * Object holding the parameters of the cell.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n     * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n     */\n  }, {\n    key: \"openTableCell\",\n    value: function openTableCell() {\n      var optionsObjectOrMaxColumnWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n        this._openTableCell(optionsObjectOrMaxColumnWidth);\n      } else {\n        this._openTableCell({\n          maxColumnWidth: optionsObjectOrMaxColumnWidth\n        });\n      }\n    }\n  }, {\n    key: \"_openTableCell\",\n    value: function _openTableCell() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$maxColumnWidth = _ref4.maxColumnWidth,\n        maxColumnWidth = _ref4$maxColumnWidth === void 0 ? undefined : _ref4$maxColumnWidth;\n      if (!(this._stackItem instanceof TableRowStackItem)) {\n        throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n      }\n      this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n    }\n    /**\n     * Finalize currently built table cell and add it to parent table row's cells.\n     *\n     * @param { object | number } [optionsObjectOrColspan]\n     * Object holding the parameters of the cell.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n     * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n     *\n     * @param { number } [rowspan] Deprecated.\n     */\n  }, {\n    key: \"closeTableCell\",\n    value: function closeTableCell() {\n      var optionsObjectOrColspan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rowspan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (typeof optionsObjectOrColspan === 'object') {\n        this._closeTableCell(optionsObjectOrColspan);\n      } else {\n        this._closeTableCell({\n          colspan: optionsObjectOrColspan,\n          rowspan: rowspan\n        });\n      }\n    }\n  }, {\n    key: \"_closeTableCell\",\n    value: function _closeTableCell() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref5$colspan = _ref5.colspan,\n        colspan = _ref5$colspan === void 0 ? 1 : _ref5$colspan,\n        _ref5$rowspan = _ref5.rowspan,\n        rowspan = _ref5$rowspan === void 0 ? 1 : _ref5$rowspan;\n      var cell = this._popStackItem();\n      var text = trimCharacter(getText(cell), '\\n');\n      cell.next.cells.push({\n        colspan: colspan,\n        rowspan: rowspan,\n        text: text\n      });\n    }\n    /**\n     * Finalize currently built table row and add it to parent table's rows.\n     */\n  }, {\n    key: \"closeTableRow\",\n    value: function closeTableRow() {\n      var row = this._popStackItem();\n      row.next.rows.push(row.cells);\n    }\n    /**\n     * Finalize currently built table and add the rendered text to the parent block.\n     *\n     * @param { object | number } [optionsObjectOrColSpacing]\n     * Object holding the parameters of the table.\n     *\n     * Number value is depreceted.\n     *\n     * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n     * Number of spaces between table columns.\n     *\n     * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n     * Number of empty lines between table rows.\n     *\n     * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n     * This table should have at least this number of line breaks to separate if from any preceding block.\n     *\n     * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n     * This table should have at least this number of line breaks to separate it from any following block.\n     *\n     * @param { number } [rowSpacing]\n     * Deprecated.\n     *\n     * @param { number } [leadingLineBreaks]\n     * Deprecated.\n     *\n     * @param { number } [trailingLineBreaks]\n     * Deprecated.\n     */\n  }, {\n    key: \"closeTable\",\n    value: function closeTable() {\n      var optionsObjectOrColSpacing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rowSpacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var leadingLineBreaks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var trailingLineBreaks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      if (typeof optionsObjectOrColSpacing === 'object') {\n        this._closeTable(optionsObjectOrColSpacing);\n      } else {\n        this._closeTable({\n          colSpacing: optionsObjectOrColSpacing,\n          leadingLineBreaks: leadingLineBreaks,\n          rowSpacing: rowSpacing,\n          trailingLineBreaks: trailingLineBreaks\n        });\n      }\n    }\n  }, {\n    key: \"_closeTable\",\n    value: function _closeTable() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref6$colSpacing = _ref6.colSpacing,\n        colSpacing = _ref6$colSpacing === void 0 ? 3 : _ref6$colSpacing,\n        _ref6$rowSpacing = _ref6.rowSpacing,\n        rowSpacing = _ref6$rowSpacing === void 0 ? 0 : _ref6$rowSpacing,\n        _ref6$leadingLineBrea = _ref6.leadingLineBreaks,\n        leadingLineBreaks = _ref6$leadingLineBrea === void 0 ? 2 : _ref6$leadingLineBrea,\n        _ref6$trailingLineBre = _ref6.trailingLineBreaks,\n        trailingLineBreaks = _ref6$trailingLineBre === void 0 ? 2 : _ref6$trailingLineBre;\n      var table = this._popStackItem();\n      var output = tableToString(table.rows, rowSpacing, colSpacing);\n      if (output) {\n        addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n      }\n    }\n    /**\n     * Return the rendered text content of this builder.\n     *\n     * @returns { string }\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return getText(this._stackItem.getRoot());\n      // There should only be the root item if everything is closed properly.\n    }\n  }]);\n  return BlockTextBuilder;\n}();\nfunction getText(stackItem) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n  var parentText = getText(stackItem);\n  var lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\nmodule.exports = {\n  BlockTextBuilder: BlockTextBuilder\n};","map":null,"metadata":{},"sourceType":"script"}