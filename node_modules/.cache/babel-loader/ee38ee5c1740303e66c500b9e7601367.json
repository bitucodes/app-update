{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar path = require(\"path\");\nvar _require = require(\"webpack-sources\"),\n  ConcatSource = _require.ConcatSource,\n  RawSource = _require.RawSource;\nvar ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nvar SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nvar createHash = require(\"./util/createHash\");\nvar validateOptions = require(\"schema-utils\");\nvar schema = require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\nvar basename = function basename(name) {\n  if (!name.includes(\"/\")) return name;\n  return name.substr(name.lastIndexOf(\"/\") + 1);\n};\nvar assetsCache = new WeakMap();\nvar getTaskForFile = function getTaskForFile(file, chunk, options, compilation) {\n  var asset = compilation.assets[file];\n  var cache = assetsCache.get(asset);\n  if (cache && cache.file === file) {\n    for (var cachedFile in cache.assets) {\n      compilation.assets[cachedFile] = cache.assets[cachedFile];\n      if (cachedFile !== file) chunk.files.push(cachedFile);\n    }\n    return;\n  }\n  var source, sourceMap;\n  if (asset.sourceAndMap) {\n    var sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = asset.map(options);\n    source = asset.source();\n  }\n  if (sourceMap) {\n    return {\n      chunk: chunk,\n      file: file,\n      asset: asset,\n      source: source,\n      sourceMap: sourceMap,\n      modules: undefined\n    };\n  }\n};\nvar SourceMapDevToolPlugin = /*#__PURE__*/function () {\n  function SourceMapDevToolPlugin(options) {\n    _classCallCheck(this, SourceMapDevToolPlugin);\n    if (arguments.length > 1) {\n      throw new Error(\"SourceMapDevToolPlugin only takes one argument (pass an options object)\");\n    }\n    validateOptions(schema, options || {}, \"SourceMap DevTool Plugin\");\n    if (!options) options = {};\n    this.sourceMapFilename = options.filename;\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# sourceMappingURL=[url]\";\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    this.namespace = options.namespace || \"\";\n    this.options = options;\n  }\n  _createClass(SourceMapDevToolPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var sourceMapFilename = this.sourceMapFilename;\n      var sourceMappingURLComment = this.sourceMappingURLComment;\n      var moduleFilenameTemplate = this.moduleFilenameTemplate;\n      var namespace = this.namespace;\n      var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n      var requestShortener = compiler.requestShortener;\n      var options = this.options;\n      options.test = options.test || /\\.(m?js|css)($|\\?)/i;\n      var matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n      compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", function (compilation) {\n        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n        compilation.hooks.afterOptimizeChunkAssets.tap({\n          name: \"SourceMapDevToolPlugin\",\n          context: true\n        }, function (context, chunks) {\n          var moduleToSourceNameMapping = new Map();\n          var reportProgress = context && context.reportProgress ? context.reportProgress : function () {};\n          var files = [];\n          var _iterator = _createForOfIteratorHelper(chunks),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var chunk = _step.value;\n              var _iterator2 = _createForOfIteratorHelper(chunk.files),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var file = _step2.value;\n                  if (matchObject(file)) {\n                    files.push({\n                      file: file,\n                      chunk: chunk\n                    });\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          reportProgress(0.0);\n          var tasks = [];\n          files.forEach(function (_ref, idx) {\n            var file = _ref.file,\n              chunk = _ref.chunk;\n            reportProgress(0.5 * idx / files.length, file, \"generate SourceMap\");\n            var task = getTaskForFile(file, chunk, options, compilation);\n            if (task) {\n              var modules = task.sourceMap.sources.map(function (source) {\n                var module = compilation.findModule(source);\n                return module || source;\n              });\n              for (var _idx = 0; _idx < modules.length; _idx++) {\n                var _module = modules[_idx];\n                if (!moduleToSourceNameMapping.get(_module)) {\n                  moduleToSourceNameMapping.set(_module, ModuleFilenameHelpers.createFilename(_module, {\n                    moduleFilenameTemplate: moduleFilenameTemplate,\n                    namespace: namespace\n                  }, requestShortener));\n                }\n              }\n              task.modules = modules;\n              tasks.push(task);\n            }\n          });\n          reportProgress(0.5, \"resolve sources\");\n          var usedNamesSet = new Set(moduleToSourceNameMapping.values());\n          var conflictDetectionSet = new Set();\n\n          // all modules in defined order (longest identifier first)\n          var allModules = Array.from(moduleToSourceNameMapping.keys()).sort(function (a, b) {\n            var ai = typeof a === \"string\" ? a : a.identifier();\n            var bi = typeof b === \"string\" ? b : b.identifier();\n            return ai.length - bi.length;\n          });\n\n          // find modules with conflicting source names\n          for (var idx = 0; idx < allModules.length; idx++) {\n            var _module2 = allModules[idx];\n            var sourceName = moduleToSourceNameMapping.get(_module2);\n            var hasName = conflictDetectionSet.has(sourceName);\n            if (!hasName) {\n              conflictDetectionSet.add(sourceName);\n              continue;\n            }\n\n            // try the fallback name first\n            sourceName = ModuleFilenameHelpers.createFilename(_module2, {\n              moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n              namespace: namespace\n            }, requestShortener);\n            hasName = usedNamesSet.has(sourceName);\n            if (!hasName) {\n              moduleToSourceNameMapping.set(_module2, sourceName);\n              usedNamesSet.add(sourceName);\n              continue;\n            }\n\n            // elsewise just append stars until we have a valid name\n            while (hasName) {\n              sourceName += \"*\";\n              hasName = usedNamesSet.has(sourceName);\n            }\n            moduleToSourceNameMapping.set(_module2, sourceName);\n            usedNamesSet.add(sourceName);\n          }\n          tasks.forEach(function (task, index) {\n            reportProgress(0.5 + 0.5 * index / tasks.length, task.file, \"attach SourceMap\");\n            var assets = Object.create(null);\n            var chunk = task.chunk;\n            var file = task.file;\n            var asset = task.asset;\n            var sourceMap = task.sourceMap;\n            var source = task.source;\n            var modules = task.modules;\n            var moduleFilenames = modules.map(function (m) {\n              return moduleToSourceNameMapping.get(m);\n            });\n            sourceMap.sources = moduleFilenames;\n            if (options.noSources) {\n              sourceMap.sourcesContent = undefined;\n            }\n            sourceMap.sourceRoot = options.sourceRoot || \"\";\n            sourceMap.file = file;\n            assetsCache.set(asset, {\n              file: file,\n              assets: assets\n            });\n            var currentSourceMappingURLComment = sourceMappingURLComment;\n            if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n            }\n            var sourceMapString = JSON.stringify(sourceMap);\n            if (sourceMapFilename) {\n              var filename = file;\n              var query = \"\";\n              var _idx2 = filename.indexOf(\"?\");\n              if (_idx2 >= 0) {\n                query = filename.substr(_idx2);\n                filename = filename.substr(0, _idx2);\n              }\n              var sourceMapFile = compilation.getPath(sourceMapFilename, {\n                chunk: chunk,\n                filename: options.fileContext ? path.relative(options.fileContext, filename) : filename,\n                query: query,\n                basename: basename(filename),\n                contentHash: createHash(\"md4\").update(sourceMapString).digest(\"hex\")\n              });\n              var sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile.replace(/\\\\/g, \"/\") : path.relative(path.dirname(file), sourceMapFile).replace(/\\\\/g, \"/\");\n              if (currentSourceMappingURLComment !== false) {\n                assets[file] = compilation.assets[file] = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[url\\]/g, sourceMapUrl));\n              }\n              assets[sourceMapFile] = compilation.assets[sourceMapFile] = new RawSource(sourceMapString);\n              chunk.files.push(sourceMapFile);\n            } else {\n              assets[file] = compilation.assets[file] = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, function () {\n                return sourceMapString;\n              }).replace(/\\[url\\]/g, function () {\n                return \"data:application/json;charset=utf-8;base64,\".concat(Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\"));\n              }));\n            }\n          });\n          reportProgress(1.0);\n        });\n      });\n    }\n  }]);\n  return SourceMapDevToolPlugin;\n}();\nmodule.exports = SourceMapDevToolPlugin;","map":null,"metadata":{},"sourceType":"script"}