{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\nvar _toConsumableArray = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar acorn = require(\"acorn-dynamic-import\").default;\nvar _require = require(\"tapable\"),\n  Tapable = _require.Tapable,\n  SyncBailHook = _require.SyncBailHook,\n  HookMap = _require.HookMap;\nvar util = require(\"util\");\nvar vm = require(\"vm\");\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nvar StackedSetMap = require(\"./util/StackedSetMap\");\nvar TrackingSet = require(\"./util/TrackingSet\");\nvar joinRanges = function joinRanges(startRange, endRange) {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\nvar defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 2019,\n  sourceType: \"module\",\n  onComment: null,\n  plugins: {\n    dynamicImport: true\n  }\n};\n\n// regexp to match at lease one \"magic comment\"\nvar webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nvar EMPTY_ARRAY = [];\nvar EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\nvar Parser = /*#__PURE__*/function (_Tapable) {\n  _inherits(Parser, _Tapable);\n  function Parser(options) {\n    var _this;\n    var sourceType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n    _classCallCheck(this, Parser);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Parser).call(this));\n    _this.hooks = {\n      evaluateTypeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluate: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateDefinedIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateCallExpressionMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"param\"]);\n      }),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(function () {\n        return new SyncBailHook([\"statement\"]);\n      }),\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      export: new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationLet: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationConst: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationVar: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      canRename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      rename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      assigned: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      assign: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      typeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      callAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      new: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    var HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      typeof: /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      new: /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n    _this._pluginCompat.tap(\"Parser\", function (options) {\n      for (var _i = 0, _Object$keys = Object.keys(HOOK_MAP_COMPAT_CONFIG); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n        var regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        var match = regexp.exec(options.name);\n        if (match) {\n          if (match[1]) {\n            _this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n          } else {\n            _this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n          }\n          return true;\n        }\n      }\n    });\n    _this.options = options;\n    _this.sourceType = sourceType;\n    _this.scope = undefined;\n    _this.state = undefined;\n    _this.comments = undefined;\n    _this.initializeEvaluating();\n    return _this;\n  }\n  _createClass(Parser, [{\n    key: \"initializeEvaluating\",\n    value: function initializeEvaluating() {\n      var _this2 = this;\n      this.hooks.evaluate.for(\"Literal\").tap(\"Parser\", function (expr) {\n        switch (typeof expr.value) {\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n        }\n        if (expr.value === null) {\n          return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n        }\n        if (expr.value instanceof RegExp) {\n          return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var leftAsBool;\n        var right;\n        if (expr.operator === \"&&\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === false) return left.setRange(expr.range);\n          if (leftAsBool !== true) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        } else if (expr.operator === \"||\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === true) return left.setRange(expr.range);\n          if (leftAsBool !== false) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var right;\n        var res;\n        if (expr.operator === \"+\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          if (left.isString()) {\n            if (right.isString()) {\n              res.setString(left.string + right.string);\n            } else if (right.isNumber()) {\n              res.setString(left.string + right.number);\n            } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n              res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix);\n            } else if (right.isWrapped()) {\n              res.setWrapped(new BasicEvaluatedExpression().setString(left.string).setRange(left.range), right.postfix);\n            } else {\n              res.setWrapped(left, null);\n            }\n          } else if (left.isNumber()) {\n            if (right.isString()) {\n              res.setString(left.number + right.string);\n            } else if (right.isNumber()) {\n              res.setNumber(left.number + right.number);\n            }\n          } else if (left.isWrapped()) {\n            if (left.postfix && left.postfix.isString() && right.isString()) {\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)));\n            } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)));\n            } else if (right.isString()) {\n              res.setWrapped(left.prefix, right);\n            } else if (right.isNumber()) {\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range));\n            } else {\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression());\n            }\n          } else {\n            if (right.isString()) {\n              res.setWrapped(null, right);\n            }\n          }\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"-\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number - right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"*\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number * right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"/\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number / right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"**\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(Math.pow(left.number, right.number));\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string === right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number === right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool === right.bool);\n          }\n        } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string !== right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number !== right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool !== right.bool);\n          }\n        } else if (expr.operator === \"&\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number & right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"|\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number | right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"^\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number ^ right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >>> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"<<\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number << right.number);\n          res.setRange(expr.range);\n          return res;\n        }\n      });\n      this.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", function (expr) {\n        if (expr.operator === \"typeof\") {\n          var res;\n          var name;\n          if (expr.argument.type === \"Identifier\") {\n            name = _this2.scope.renames.get(expr.argument.name) || expr.argument.name;\n            if (!_this2.scope.definitions.has(name)) {\n              var hook = _this2.hooks.evaluateTypeof.get(name);\n              if (hook !== undefined) {\n                res = hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n          if (expr.argument.type === \"MemberExpression\") {\n            var exprName = _this2.getNameForExpression(expr.argument);\n            if (exprName && exprName.free) {\n              var _hook = _this2.hooks.evaluateTypeof.get(exprName.name);\n              if (_hook !== undefined) {\n                res = _hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n          if (expr.argument.type === \"FunctionExpression\") {\n            return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n          }\n          var arg = _this2.evaluateExpression(expr.argument);\n          if (arg.isString() || arg.isWrapped()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n          }\n          if (arg.isNumber()) {\n            return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n          }\n          if (arg.isBoolean()) {\n            return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n          }\n          if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n          }\n        } else if (expr.operator === \"!\") {\n          var argument = _this2.evaluateExpression(expr.argument);\n          if (!argument) return;\n          if (argument.isBoolean()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n          }\n          if (argument.isTruthy()) {\n            return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n          }\n          if (argument.isFalsy()) {\n            return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n          }\n          if (argument.isString()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n          }\n          if (argument.isNumber()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n          }\n        } else if (expr.operator === \"~\") {\n          var _argument = _this2.evaluateExpression(expr.argument);\n          if (!_argument) return;\n          if (!_argument.isNumber()) return;\n          var _res = new BasicEvaluatedExpression();\n          _res.setNumber(~_argument.number);\n          _res.setRange(expr.range);\n          return _res;\n        }\n      });\n      this.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", function (expr) {\n        return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(expr.name) || expr.name;\n        if (!_this2.scope.definitions.has(expr.name)) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        } else {\n          var _hook2 = _this2.hooks.evaluateDefinedIdentifier.get(name);\n          if (_hook2 !== undefined) {\n            return _hook2.call(expr);\n          }\n        }\n      });\n      this.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(\"this\");\n        if (name) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", function (expression) {\n        var exprName = _this2.getNameForExpression(expression);\n        if (exprName) {\n          if (exprName.free) {\n            var hook = _this2.hooks.evaluateIdentifier.get(exprName.name);\n            if (hook !== undefined) {\n              var result = hook.call(expression);\n              if (result) return result;\n            }\n            return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n          } else {\n            var _hook3 = _this2.hooks.evaluateDefinedIdentifier.get(exprName.name);\n            if (_hook3 !== undefined) {\n              return _hook3.call(expression);\n            }\n          }\n        }\n      });\n      this.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", function (expr) {\n        if (expr.callee.type !== \"MemberExpression\") return;\n        if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n        var param = _this2.evaluateExpression(expr.callee.object);\n        if (!param) return;\n        var property = expr.callee.property.name || expr.callee.property.value;\n        var hook = _this2.hooks.evaluateCallExpressionMember.get(property);\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 2) return;\n        var arg1 = _this2.evaluateExpression(expr.arguments[0]);\n        var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n        if (!arg1.isString() && !arg1.isRegExp()) return;\n        arg1 = arg1.regExp || arg1.string;\n        if (!arg2.isString()) return;\n        arg2 = arg2.string;\n        return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n      });\n      [\"substr\", \"substring\"].forEach(function (fn) {\n        _this2.hooks.evaluateCallExpressionMember.for(fn).tap(\"Parser\", function (expr, param) {\n          if (!param.isString()) return;\n          var arg1;\n          var result,\n            str = param.string;\n          switch (expr.arguments.length) {\n            case 1:\n              arg1 = _this2.evaluateExpression(expr.arguments[0]);\n              if (!arg1.isNumber()) return;\n              result = str[fn](arg1.number);\n              break;\n            case 2:\n              {\n                arg1 = _this2.evaluateExpression(expr.arguments[0]);\n                var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n                if (!arg1.isNumber()) return;\n                if (!arg2.isNumber()) return;\n                result = str[fn](arg1.number, arg2.number);\n                break;\n              }\n            default:\n              return;\n          }\n          return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n        });\n      });\n\n      /**\n       * @param {string} kind \"cooked\" | \"raw\"\n       * @param {TODO[]} quasis quasis\n       * @param {TODO[]} expressions expressions\n       * @returns {BasicEvaluatedExpression[]} Simplified template\n       */\n      var getSimplifiedTemplateResult = function getSimplifiedTemplateResult(kind, quasis, expressions) {\n        var parts = [];\n        for (var i = 0; i < quasis.length; i++) {\n          parts.push(new BasicEvaluatedExpression().setString(quasis[i].value[kind]).setRange(quasis[i].range));\n          if (i > 0) {\n            var prevExpr = parts[parts.length - 2],\n              lastExpr = parts[parts.length - 1];\n            var expr = _this2.evaluateExpression(expressions[i - 1]);\n            if (!(expr.isString() || expr.isNumber())) continue;\n            prevExpr.setString(prevExpr.string + (expr.isString() ? expr.string : expr.number) + lastExpr.string);\n            prevExpr.setRange([prevExpr.range[0], lastExpr.range[1]]);\n            parts.pop();\n          }\n        }\n        return parts;\n      };\n      this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", function (node) {\n        var parts = getSimplifiedTemplateResult.call(_this2, \"cooked\", node.quasis, node.expressions);\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n        return new BasicEvaluatedExpression().setTemplateString(parts).setRange(node.range);\n      });\n      this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", function (node) {\n        if (_this2.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n        var parts = getSimplifiedTemplateResult.call(_this2, \"raw\", node.quasi.quasis, node.quasi.expressions);\n        return new BasicEvaluatedExpression().setTemplateString(parts).setRange(node.range);\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString() && !param.isWrapped()) return;\n        var stringSuffix = null;\n        var hasUnknownParams = false;\n        for (var i = expr.arguments.length - 1; i >= 0; i--) {\n          var argExpr = _this2.evaluateExpression(expr.arguments[i]);\n          if (!argExpr.isString() && !argExpr.isNumber()) {\n            hasUnknownParams = true;\n            break;\n          }\n          var value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n          var newString = value + (stringSuffix ? stringSuffix.string : \"\");\n          var newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n          stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n        }\n        if (hasUnknownParams) {\n          var prefix = param.isString() ? param : param.prefix;\n          return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n        } else if (param.isWrapped()) {\n          var postfix = stringSuffix || param.postfix;\n          return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n        } else {\n          var _newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n          return new BasicEvaluatedExpression().setString(_newString).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 1) return;\n        var result;\n        var arg = _this2.evaluateExpression(expr.arguments[0]);\n        if (arg.isString()) {\n          result = param.string.split(arg.string);\n        } else if (arg.isRegExp()) {\n          result = param.string.split(arg.regExp);\n        } else {\n          return;\n        }\n        return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", function (expr) {\n        var condition = _this2.evaluateExpression(expr.test);\n        var conditionValue = condition.asBool();\n        var res;\n        if (conditionValue === undefined) {\n          var consequent = _this2.evaluateExpression(expr.consequent);\n          var alternate = _this2.evaluateExpression(expr.alternate);\n          if (!consequent || !alternate) return;\n          res = new BasicEvaluatedExpression();\n          if (consequent.isConditional()) {\n            res.setOptions(consequent.options);\n          } else {\n            res.setOptions([consequent]);\n          }\n          if (alternate.isConditional()) {\n            res.addOptions(alternate.options);\n          } else {\n            res.addOptions([alternate]);\n          }\n        } else {\n          res = _this2.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n        }\n        res.setRange(expr.range);\n        return res;\n      });\n      this.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", function (expr) {\n        var items = expr.elements.map(function (element) {\n          return element !== null && _this2.evaluateExpression(element);\n        });\n        if (!items.every(Boolean)) return;\n        return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n      });\n    }\n  }, {\n    key: \"getRenameIdentifier\",\n    value: function getRenameIdentifier(expr) {\n      var result = this.evaluateExpression(expr);\n      if (result && result.isIdentifier()) {\n        return result.identifier;\n      }\n    }\n  }, {\n    key: \"walkClass\",\n    value: function walkClass(classy) {\n      if (classy.superClass) this.walkExpression(classy.superClass);\n      if (classy.body && classy.body.type === \"ClassBody\") {\n        var wasTopLevel = this.scope.topLevelScope;\n        this.scope.topLevelScope = false;\n        var _iterator = _createForOfIteratorHelper(classy.body.body),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var methodDefinition = _step.value;\n            if (methodDefinition.type === \"MethodDefinition\") {\n              this.walkMethodDefinition(methodDefinition);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.scope.topLevelScope = wasTopLevel;\n      }\n    }\n  }, {\n    key: \"walkMethodDefinition\",\n    value: function walkMethodDefinition(methodDefinition) {\n      if (methodDefinition.computed && methodDefinition.key) {\n        this.walkExpression(methodDefinition.key);\n      }\n      if (methodDefinition.value) {\n        this.walkExpression(methodDefinition.value);\n      }\n    } // Prewalking iterates the scope for variable declarations\n  }, {\n    key: \"prewalkStatements\",\n    value: function prewalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.prewalkStatement(statement);\n      }\n    } // Walking iterates the statements and expressions and processes them\n  }, {\n    key: \"walkStatements\",\n    value: function walkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.walkStatement(statement);\n      }\n    }\n  }, {\n    key: \"prewalkStatement\",\n    value: function prewalkStatement(statement) {\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.prewalkBlockStatement(statement);\n          break;\n        case \"ClassDeclaration\":\n          this.prewalkClassDeclaration(statement);\n          break;\n        case \"DoWhileStatement\":\n          this.prewalkDoWhileStatement(statement);\n          break;\n        case \"ExportAllDeclaration\":\n          this.prewalkExportAllDeclaration(statement);\n          break;\n        case \"ExportDefaultDeclaration\":\n          this.prewalkExportDefaultDeclaration(statement);\n          break;\n        case \"ExportNamedDeclaration\":\n          this.prewalkExportNamedDeclaration(statement);\n          break;\n        case \"ForInStatement\":\n          this.prewalkForInStatement(statement);\n          break;\n        case \"ForOfStatement\":\n          this.prewalkForOfStatement(statement);\n          break;\n        case \"ForStatement\":\n          this.prewalkForStatement(statement);\n          break;\n        case \"FunctionDeclaration\":\n          this.prewalkFunctionDeclaration(statement);\n          break;\n        case \"IfStatement\":\n          this.prewalkIfStatement(statement);\n          break;\n        case \"ImportDeclaration\":\n          this.prewalkImportDeclaration(statement);\n          break;\n        case \"LabeledStatement\":\n          this.prewalkLabeledStatement(statement);\n          break;\n        case \"SwitchStatement\":\n          this.prewalkSwitchStatement(statement);\n          break;\n        case \"TryStatement\":\n          this.prewalkTryStatement(statement);\n          break;\n        case \"VariableDeclaration\":\n          this.prewalkVariableDeclaration(statement);\n          break;\n        case \"WhileStatement\":\n          this.prewalkWhileStatement(statement);\n          break;\n        case \"WithStatement\":\n          this.prewalkWithStatement(statement);\n          break;\n      }\n    }\n  }, {\n    key: \"walkStatement\",\n    value: function walkStatement(statement) {\n      if (this.hooks.statement.call(statement) !== undefined) return;\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.walkBlockStatement(statement);\n          break;\n        case \"ClassDeclaration\":\n          this.walkClassDeclaration(statement);\n          break;\n        case \"DoWhileStatement\":\n          this.walkDoWhileStatement(statement);\n          break;\n        case \"ExportDefaultDeclaration\":\n          this.walkExportDefaultDeclaration(statement);\n          break;\n        case \"ExportNamedDeclaration\":\n          this.walkExportNamedDeclaration(statement);\n          break;\n        case \"ExpressionStatement\":\n          this.walkExpressionStatement(statement);\n          break;\n        case \"ForInStatement\":\n          this.walkForInStatement(statement);\n          break;\n        case \"ForOfStatement\":\n          this.walkForOfStatement(statement);\n          break;\n        case \"ForStatement\":\n          this.walkForStatement(statement);\n          break;\n        case \"FunctionDeclaration\":\n          this.walkFunctionDeclaration(statement);\n          break;\n        case \"IfStatement\":\n          this.walkIfStatement(statement);\n          break;\n        case \"LabeledStatement\":\n          this.walkLabeledStatement(statement);\n          break;\n        case \"ReturnStatement\":\n          this.walkReturnStatement(statement);\n          break;\n        case \"SwitchStatement\":\n          this.walkSwitchStatement(statement);\n          break;\n        case \"ThrowStatement\":\n          this.walkThrowStatement(statement);\n          break;\n        case \"TryStatement\":\n          this.walkTryStatement(statement);\n          break;\n        case \"VariableDeclaration\":\n          this.walkVariableDeclaration(statement);\n          break;\n        case \"WhileStatement\":\n          this.walkWhileStatement(statement);\n          break;\n        case \"WithStatement\":\n          this.walkWithStatement(statement);\n          break;\n      }\n    } // Real Statements\n  }, {\n    key: \"prewalkBlockStatement\",\n    value: function prewalkBlockStatement(statement) {\n      this.prewalkStatements(statement.body);\n    }\n  }, {\n    key: \"walkBlockStatement\",\n    value: function walkBlockStatement(statement) {\n      this.walkStatements(statement.body);\n    }\n  }, {\n    key: \"walkExpressionStatement\",\n    value: function walkExpressionStatement(statement) {\n      this.walkExpression(statement.expression);\n    }\n  }, {\n    key: \"prewalkIfStatement\",\n    value: function prewalkIfStatement(statement) {\n      this.prewalkStatement(statement.consequent);\n      if (statement.alternate) {\n        this.prewalkStatement(statement.alternate);\n      }\n    }\n  }, {\n    key: \"walkIfStatement\",\n    value: function walkIfStatement(statement) {\n      var result = this.hooks.statementIf.call(statement);\n      if (result === undefined) {\n        this.walkExpression(statement.test);\n        this.walkStatement(statement.consequent);\n        if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkStatement(statement.consequent);\n        } else if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"prewalkLabeledStatement\",\n    value: function prewalkLabeledStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkLabeledStatement\",\n    value: function walkLabeledStatement(statement) {\n      var hook = this.hooks.label.get(statement.label.name);\n      if (hook !== undefined) {\n        var result = hook.call(statement);\n        if (result === true) return;\n      }\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkWithStatement\",\n    value: function prewalkWithStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWithStatement\",\n    value: function walkWithStatement(statement) {\n      this.walkExpression(statement.object);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkSwitchStatement\",\n    value: function prewalkSwitchStatement(statement) {\n      this.prewalkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkSwitchStatement\",\n    value: function walkSwitchStatement(statement) {\n      this.walkExpression(statement.discriminant);\n      this.walkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkTerminatingStatement\",\n    value: function walkTerminatingStatement(statement) {\n      if (statement.argument) this.walkExpression(statement.argument);\n    }\n  }, {\n    key: \"walkReturnStatement\",\n    value: function walkReturnStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"walkThrowStatement\",\n    value: function walkThrowStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"prewalkTryStatement\",\n    value: function prewalkTryStatement(statement) {\n      this.prewalkStatement(statement.block);\n    }\n  }, {\n    key: \"walkTryStatement\",\n    value: function walkTryStatement(statement) {\n      if (this.scope.inTry) {\n        this.walkStatement(statement.block);\n      } else {\n        this.scope.inTry = true;\n        this.walkStatement(statement.block);\n        this.scope.inTry = false;\n      }\n      if (statement.handler) this.walkCatchClause(statement.handler);\n      if (statement.finalizer) this.walkStatement(statement.finalizer);\n    }\n  }, {\n    key: \"prewalkWhileStatement\",\n    value: function prewalkWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWhileStatement\",\n    value: function walkWhileStatement(statement) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkDoWhileStatement\",\n    value: function prewalkDoWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkDoWhileStatement\",\n    value: function walkDoWhileStatement(statement) {\n      this.walkStatement(statement.body);\n      this.walkExpression(statement.test);\n    }\n  }, {\n    key: \"prewalkForStatement\",\n    value: function prewalkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.prewalkStatement(statement.init);\n        }\n      }\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForStatement\",\n    value: function walkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.walkStatement(statement.init);\n        } else {\n          this.walkExpression(statement.init);\n        }\n      }\n      if (statement.test) {\n        this.walkExpression(statement.test);\n      }\n      if (statement.update) {\n        this.walkExpression(statement.update);\n      }\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkForInStatement\",\n    value: function prewalkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForInStatement\",\n    value: function walkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n      this.walkExpression(statement.right);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkForOfStatement\",\n    value: function prewalkForOfStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForOfStatement\",\n    value: function walkForOfStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n      this.walkExpression(statement.right);\n      this.walkStatement(statement.body);\n    } // Declarations\n  }, {\n    key: \"prewalkFunctionDeclaration\",\n    value: function prewalkFunctionDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkFunctionDeclaration\",\n    value: function walkFunctionDeclaration(statement) {\n      var _this3 = this;\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inScope(statement.params, function () {\n        var _iterator2 = _createForOfIteratorHelper(statement.params),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var param = _step2.value;\n            _this3.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (statement.body.type === \"BlockStatement\") {\n          _this3.detectStrictMode(statement.body.body);\n          _this3.prewalkStatement(statement.body);\n          _this3.walkStatement(statement.body);\n        } else {\n          _this3.walkExpression(statement.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"prewalkImportDeclaration\",\n    value: function prewalkImportDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.import.call(statement, source);\n      var _iterator3 = _createForOfIteratorHelper(statement.specifiers),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var specifier = _step3.value;\n          var name = specifier.local.name;\n          this.scope.renames.set(name, null);\n          this.scope.definitions.add(name);\n          switch (specifier.type) {\n            case \"ImportDefaultSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, \"default\", name);\n              break;\n            case \"ImportSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n              break;\n            case \"ImportNamespaceSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, null, name);\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"prewalkExportNamedDeclaration\",\n    value: function prewalkExportNamedDeclaration(statement) {\n      var source;\n      if (statement.source) {\n        source = statement.source.value;\n        this.hooks.exportImport.call(statement, source);\n      } else {\n        this.hooks.export.call(statement);\n      }\n      if (statement.declaration) {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          var originalDefinitions = this.scope.definitions;\n          var tracker = new TrackingSet(this.scope.definitions);\n          this.scope.definitions = tracker;\n          this.prewalkStatement(statement.declaration);\n          var newDefs = Array.from(tracker.getAddedItems());\n          this.scope.definitions = originalDefinitions;\n          for (var index = newDefs.length - 1; index >= 0; index--) {\n            var def = newDefs[index];\n            this.hooks.exportSpecifier.call(statement, def, def, index);\n          }\n        }\n      }\n      if (statement.specifiers) {\n        for (var specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n          var specifier = statement.specifiers[specifierIndex];\n          switch (specifier.type) {\n            case \"ExportSpecifier\":\n              {\n                var name = specifier.exported.name;\n                if (source) {\n                  this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n                } else {\n                  this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n                }\n                break;\n              }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkExportNamedDeclaration\",\n    value: function walkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.walkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"prewalkExportDefaultDeclaration\",\n    value: function prewalkExportDefaultDeclaration(statement) {\n      if (statement.declaration.id) {\n        var originalDefinitions = this.scope.definitions;\n        var tracker = new TrackingSet(this.scope.definitions);\n        this.scope.definitions = tracker;\n        this.prewalkStatement(statement.declaration);\n        var newDefs = Array.from(tracker.getAddedItems());\n        this.scope.definitions = originalDefinitions;\n        for (var index = 0, len = newDefs.length; index < len; index++) {\n          var def = newDefs[index];\n          this.hooks.exportSpecifier.call(statement, def, \"default\");\n        }\n      }\n    }\n  }, {\n    key: \"walkExportDefaultDeclaration\",\n    value: function walkExportDefaultDeclaration(statement) {\n      this.hooks.export.call(statement);\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.walkStatement(statement.declaration);\n        }\n      } else {\n        // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n        // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n        // These nodes must be treated as expressions.\n        if (statement.declaration.type === \"FunctionDeclaration\") {\n          this.walkFunctionDeclaration(statement.declaration);\n        } else if (statement.declaration.type === \"ClassDeclaration\") {\n          this.walkClassDeclaration(statement.declaration);\n        } else {\n          this.walkExpression(statement.declaration);\n        }\n        if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n          this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n        }\n      }\n    }\n  }, {\n    key: \"prewalkExportAllDeclaration\",\n    value: function prewalkExportAllDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n      this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n    }\n  }, {\n    key: \"prewalkVariableDeclaration\",\n    value: function prewalkVariableDeclaration(statement) {\n      var _this4 = this;\n      var hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : statement.kind === \"let\" ? this.hooks.varDeclarationLet : this.hooks.varDeclarationVar;\n      var _iterator4 = _createForOfIteratorHelper(statement.declarations),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var declarator = _step4.value;\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, function (name, decl) {\n                  var hook = hookMap.get(name);\n                  if (hook === undefined || !hook.call(decl)) {\n                    hook = _this4.hooks.varDeclaration.get(name);\n                    if (hook === undefined || !hook.call(decl)) {\n                      _this4.scope.renames.set(name, null);\n                      _this4.scope.definitions.add(name);\n                    }\n                  }\n                });\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"walkVariableDeclaration\",\n    value: function walkVariableDeclaration(statement) {\n      var _iterator5 = _createForOfIteratorHelper(statement.declarations),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var declarator = _step5.value;\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n                if (renameIdentifier && declarator.id.type === \"Identifier\") {\n                  var hook = this.hooks.canRename.get(renameIdentifier);\n                  if (hook !== undefined && hook.call(declarator.init)) {\n                    // renaming with \"var a = b;\"\n                    var _hook4 = this.hooks.rename.get(renameIdentifier);\n                    if (_hook4 === undefined || !_hook4.call(declarator.init)) {\n                      this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                      this.scope.definitions.delete(declarator.id.name);\n                    }\n                    break;\n                  }\n                }\n                this.walkPattern(declarator.id);\n                if (declarator.init) this.walkExpression(declarator.init);\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"prewalkClassDeclaration\",\n    value: function prewalkClassDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkClassDeclaration\",\n    value: function walkClassDeclaration(statement) {\n      this.walkClass(statement);\n    }\n  }, {\n    key: \"prewalkSwitchCases\",\n    value: function prewalkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        this.prewalkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkSwitchCases\",\n    value: function walkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        if (switchCase.test) {\n          this.walkExpression(switchCase.test);\n        }\n        this.walkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkCatchClause\",\n    value: function walkCatchClause(catchClause) {\n      var _this5 = this;\n      // Error binding is optional in catch clause since ECMAScript 2019\n      var errorBinding = catchClause.param === null ? EMPTY_ARRAY : [catchClause.param];\n      this.inScope(errorBinding, function () {\n        _this5.prewalkStatement(catchClause.body);\n        _this5.walkStatement(catchClause.body);\n      });\n    }\n  }, {\n    key: \"walkPattern\",\n    value: function walkPattern(pattern) {\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.walkArrayPattern(pattern);\n          break;\n        case \"AssignmentPattern\":\n          this.walkAssignmentPattern(pattern);\n          break;\n        case \"MemberExpression\":\n          this.walkMemberExpression(pattern);\n          break;\n        case \"ObjectPattern\":\n          this.walkObjectPattern(pattern);\n          break;\n        case \"RestElement\":\n          this.walkRestElement(pattern);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAssignmentPattern\",\n    value: function walkAssignmentPattern(pattern) {\n      this.walkExpression(pattern.right);\n      this.walkPattern(pattern.left);\n    }\n  }, {\n    key: \"walkObjectPattern\",\n    value: function walkObjectPattern(pattern) {\n      for (var i = 0, len = pattern.properties.length; i < len; i++) {\n        var prop = pattern.properties[i];\n        if (prop) {\n          if (prop.computed) this.walkExpression(prop.key);\n          if (prop.value) this.walkPattern(prop.value);\n        }\n      }\n    }\n  }, {\n    key: \"walkArrayPattern\",\n    value: function walkArrayPattern(pattern) {\n      for (var i = 0, len = pattern.elements.length; i < len; i++) {\n        var element = pattern.elements[i];\n        if (element) this.walkPattern(element);\n      }\n    }\n  }, {\n    key: \"walkRestElement\",\n    value: function walkRestElement(pattern) {\n      this.walkPattern(pattern.argument);\n    }\n  }, {\n    key: \"walkExpressions\",\n    value: function walkExpressions(expressions) {\n      var _iterator6 = _createForOfIteratorHelper(expressions),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var expression = _step6.value;\n          if (expression) {\n            this.walkExpression(expression);\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"walkExpression\",\n    value: function walkExpression(expression) {\n      switch (expression.type) {\n        case \"ArrayExpression\":\n          this.walkArrayExpression(expression);\n          break;\n        case \"ArrowFunctionExpression\":\n          this.walkArrowFunctionExpression(expression);\n          break;\n        case \"AssignmentExpression\":\n          this.walkAssignmentExpression(expression);\n          break;\n        case \"AwaitExpression\":\n          this.walkAwaitExpression(expression);\n          break;\n        case \"BinaryExpression\":\n          this.walkBinaryExpression(expression);\n          break;\n        case \"CallExpression\":\n          this.walkCallExpression(expression);\n          break;\n        case \"ClassExpression\":\n          this.walkClassExpression(expression);\n          break;\n        case \"ConditionalExpression\":\n          this.walkConditionalExpression(expression);\n          break;\n        case \"FunctionExpression\":\n          this.walkFunctionExpression(expression);\n          break;\n        case \"Identifier\":\n          this.walkIdentifier(expression);\n          break;\n        case \"LogicalExpression\":\n          this.walkLogicalExpression(expression);\n          break;\n        case \"MemberExpression\":\n          this.walkMemberExpression(expression);\n          break;\n        case \"NewExpression\":\n          this.walkNewExpression(expression);\n          break;\n        case \"ObjectExpression\":\n          this.walkObjectExpression(expression);\n          break;\n        case \"SequenceExpression\":\n          this.walkSequenceExpression(expression);\n          break;\n        case \"SpreadElement\":\n          this.walkSpreadElement(expression);\n          break;\n        case \"TaggedTemplateExpression\":\n          this.walkTaggedTemplateExpression(expression);\n          break;\n        case \"TemplateLiteral\":\n          this.walkTemplateLiteral(expression);\n          break;\n        case \"ThisExpression\":\n          this.walkThisExpression(expression);\n          break;\n        case \"UnaryExpression\":\n          this.walkUnaryExpression(expression);\n          break;\n        case \"UpdateExpression\":\n          this.walkUpdateExpression(expression);\n          break;\n        case \"YieldExpression\":\n          this.walkYieldExpression(expression);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAwaitExpression\",\n    value: function walkAwaitExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkArrayExpression\",\n    value: function walkArrayExpression(expression) {\n      if (expression.elements) {\n        this.walkExpressions(expression.elements);\n      }\n    }\n  }, {\n    key: \"walkSpreadElement\",\n    value: function walkSpreadElement(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkObjectExpression\",\n    value: function walkObjectExpression(expression) {\n      for (var propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n        var prop = expression.properties[propIndex];\n        if (prop.type === \"SpreadElement\") {\n          this.walkExpression(prop.argument);\n          continue;\n        }\n        if (prop.computed) {\n          this.walkExpression(prop.key);\n        }\n        if (prop.shorthand) {\n          this.scope.inShorthand = true;\n        }\n        this.walkExpression(prop.value);\n        if (prop.shorthand) {\n          this.scope.inShorthand = false;\n        }\n      }\n    }\n  }, {\n    key: \"walkFunctionExpression\",\n    value: function walkFunctionExpression(expression) {\n      var _this6 = this;\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inScope(expression.params, function () {\n        var _iterator7 = _createForOfIteratorHelper(expression.params),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var param = _step7.value;\n            _this6.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        if (expression.body.type === \"BlockStatement\") {\n          _this6.detectStrictMode(expression.body.body);\n          _this6.prewalkStatement(expression.body);\n          _this6.walkStatement(expression.body);\n        } else {\n          _this6.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkArrowFunctionExpression\",\n    value: function walkArrowFunctionExpression(expression) {\n      var _this7 = this;\n      this.inScope(expression.params, function () {\n        var _iterator8 = _createForOfIteratorHelper(expression.params),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var param = _step8.value;\n            _this7.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n        if (expression.body.type === \"BlockStatement\") {\n          _this7.detectStrictMode(expression.body.body);\n          _this7.prewalkStatement(expression.body);\n          _this7.walkStatement(expression.body);\n        } else {\n          _this7.walkExpression(expression.body);\n        }\n      });\n    }\n  }, {\n    key: \"walkSequenceExpression\",\n    value: function walkSequenceExpression(expression) {\n      if (expression.expressions) this.walkExpressions(expression.expressions);\n    }\n  }, {\n    key: \"walkUpdateExpression\",\n    value: function walkUpdateExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkUnaryExpression\",\n    value: function walkUnaryExpression(expression) {\n      if (expression.operator === \"typeof\") {\n        var exprName = this.getNameForExpression(expression.argument);\n        if (exprName && exprName.free) {\n          var hook = this.hooks.typeof.get(exprName.name);\n          if (hook !== undefined) {\n            var result = hook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkLeftRightExpression\",\n    value: function walkLeftRightExpression(expression) {\n      this.walkExpression(expression.left);\n      this.walkExpression(expression.right);\n    }\n  }, {\n    key: \"walkBinaryExpression\",\n    value: function walkBinaryExpression(expression) {\n      this.walkLeftRightExpression(expression);\n    }\n  }, {\n    key: \"walkLogicalExpression\",\n    value: function walkLogicalExpression(expression) {\n      this.walkLeftRightExpression(expression);\n    }\n  }, {\n    key: \"walkAssignmentExpression\",\n    value: function walkAssignmentExpression(expression) {\n      var _this8 = this;\n      var renameIdentifier = this.getRenameIdentifier(expression.right);\n      if (expression.left.type === \"Identifier\" && renameIdentifier) {\n        var hook = this.hooks.canRename.get(renameIdentifier);\n        if (hook !== undefined && hook.call(expression.right)) {\n          // renaming \"a = b;\"\n          var _hook5 = this.hooks.rename.get(renameIdentifier);\n          if (_hook5 === undefined || !_hook5.call(expression.right)) {\n            this.scope.renames.set(expression.left.name, renameIdentifier);\n            this.scope.definitions.delete(expression.left.name);\n          }\n          return;\n        }\n      }\n      if (expression.left.type === \"Identifier\") {\n        var assignedHook = this.hooks.assigned.get(expression.left.name);\n        if (assignedHook === undefined || !assignedHook.call(expression)) {\n          this.walkExpression(expression.right);\n        }\n        this.scope.renames.set(expression.left.name, null);\n        var assignHook = this.hooks.assign.get(expression.left.name);\n        if (assignHook === undefined || !assignHook.call(expression)) {\n          this.walkExpression(expression.left);\n        }\n        return;\n      }\n      this.walkExpression(expression.right);\n      this.walkPattern(expression.left);\n      this.enterPattern(expression.left, function (name, decl) {\n        _this8.scope.renames.set(name, null);\n      });\n    }\n  }, {\n    key: \"walkConditionalExpression\",\n    value: function walkConditionalExpression(expression) {\n      var result = this.hooks.expressionConditionalOperator.call(expression);\n      if (result === undefined) {\n        this.walkExpression(expression.test);\n        this.walkExpression(expression.consequent);\n        if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkExpression(expression.consequent);\n        } else if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"walkNewExpression\",\n    value: function walkNewExpression(expression) {\n      var callee = this.evaluateExpression(expression.callee);\n      if (callee.isIdentifier()) {\n        var hook = this.hooks.new.get(callee.identifier);\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result === true) {\n            return;\n          }\n        }\n      }\n      this.walkExpression(expression.callee);\n      if (expression.arguments) {\n        this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkYieldExpression\",\n    value: function walkYieldExpression(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkTemplateLiteral\",\n    value: function walkTemplateLiteral(expression) {\n      if (expression.expressions) {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkTaggedTemplateExpression\",\n    value: function walkTaggedTemplateExpression(expression) {\n      if (expression.tag) {\n        this.walkExpression(expression.tag);\n      }\n      if (expression.quasi && expression.quasi.expressions) {\n        this.walkExpressions(expression.quasi.expressions);\n      }\n    }\n  }, {\n    key: \"walkClassExpression\",\n    value: function walkClassExpression(expression) {\n      this.walkClass(expression);\n    }\n  }, {\n    key: \"_walkIIFE\",\n    value: function _walkIIFE(functionExpression, options, currentThis) {\n      var _this9 = this;\n      var renameArgOrThis = function renameArgOrThis(argOrThis) {\n        var renameIdentifier = _this9.getRenameIdentifier(argOrThis);\n        if (renameIdentifier) {\n          var hook = _this9.hooks.canRename.get(renameIdentifier);\n          if (hook !== undefined && hook.call(argOrThis)) {\n            var _hook6 = _this9.hooks.rename.get(renameIdentifier);\n            if (_hook6 === undefined || !_hook6.call(argOrThis)) {\n              return renameIdentifier;\n            }\n          }\n        }\n        _this9.walkExpression(argOrThis);\n      };\n      var params = functionExpression.params;\n      var renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n      var args = options.map(renameArgOrThis);\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inScope(params.filter(function (identifier, idx) {\n        return !args[idx];\n      }), function () {\n        if (renameThis) {\n          _this9.scope.renames.set(\"this\", renameThis);\n        }\n        for (var i = 0; i < args.length; i++) {\n          var param = args[i];\n          if (!param) continue;\n          if (!params[i] || params[i].type !== \"Identifier\") continue;\n          _this9.scope.renames.set(params[i].name, param);\n        }\n        if (functionExpression.body.type === \"BlockStatement\") {\n          _this9.prewalkStatement(functionExpression.body);\n          _this9.walkStatement(functionExpression.body);\n        } else {\n          _this9.walkExpression(functionExpression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkCallExpression\",\n    value: function walkCallExpression(expression) {\n      if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n        // (function() { }.call/bind(?, ))\n        this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n      } else if (expression.callee.type === \"FunctionExpression\") {\n        // (function() { }())\n        this._walkIIFE(expression.callee, expression.arguments, null);\n      } else if (expression.callee.type === \"Import\") {\n        var result = this.hooks.importCall.call(expression);\n        if (result === true) return;\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      } else {\n        var callee = this.evaluateExpression(expression.callee);\n        if (callee.isIdentifier()) {\n          var callHook = this.hooks.call.get(callee.identifier);\n          if (callHook !== undefined) {\n            var _result = callHook.call(expression);\n            if (_result === true) return;\n          }\n          var identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n          if (identifier !== callee.identifier) {\n            var callAnyHook = this.hooks.callAnyMember.get(identifier);\n            if (callAnyHook !== undefined) {\n              var _result2 = callAnyHook.call(expression);\n              if (_result2 === true) return;\n            }\n          }\n        }\n        if (expression.callee) this.walkExpression(expression.callee);\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkMemberExpression\",\n    value: function walkMemberExpression(expression) {\n      var exprName = this.getNameForExpression(expression);\n      if (exprName && exprName.free) {\n        var expressionHook = this.hooks.expression.get(exprName.name);\n        if (expressionHook !== undefined) {\n          var result = expressionHook.call(expression);\n          if (result === true) return;\n        }\n        var expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n        if (expressionAnyMemberHook !== undefined) {\n          var _result3 = expressionAnyMemberHook.call(expression);\n          if (_result3 === true) return;\n        }\n      }\n      this.walkExpression(expression.object);\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkThisExpression\",\n    value: function walkThisExpression(expression) {\n      var expressionHook = this.hooks.expression.get(\"this\");\n      if (expressionHook !== undefined) {\n        expressionHook.call(expression);\n      }\n    }\n  }, {\n    key: \"walkIdentifier\",\n    value: function walkIdentifier(expression) {\n      if (!this.scope.definitions.has(expression.name)) {\n        var hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n  }, {\n    key: \"inScope\",\n    value: function inScope(params, fn) {\n      var _this10 = this;\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      this.scope.renames.set(\"this\", null);\n      var _iterator9 = _createForOfIteratorHelper(params),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var param = _step9.value;\n          if (typeof param !== \"string\") {\n            this.enterPattern(param, function (param) {\n              _this10.scope.renames.set(param, null);\n              _this10.scope.definitions.add(param);\n            });\n          } else if (param) {\n            this.scope.renames.set(param, null);\n            this.scope.definitions.add(param);\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"detectStrictMode\",\n    value: function detectStrictMode(statements) {\n      var isStrict = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\" && statements[0].expression.value === \"use strict\";\n      if (isStrict) {\n        this.scope.isStrict = true;\n      }\n    }\n  }, {\n    key: \"enterPattern\",\n    value: function enterPattern(pattern, onIdent) {\n      if (!pattern) return;\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.enterArrayPattern(pattern, onIdent);\n          break;\n        case \"AssignmentPattern\":\n          this.enterAssignmentPattern(pattern, onIdent);\n          break;\n        case \"Identifier\":\n          this.enterIdentifier(pattern, onIdent);\n          break;\n        case \"ObjectPattern\":\n          this.enterObjectPattern(pattern, onIdent);\n          break;\n        case \"RestElement\":\n          this.enterRestElement(pattern, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"enterIdentifier\",\n    value: function enterIdentifier(pattern, onIdent) {\n      onIdent(pattern.name, pattern);\n    }\n  }, {\n    key: \"enterObjectPattern\",\n    value: function enterObjectPattern(pattern, onIdent) {\n      for (var propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n        var prop = pattern.properties[propIndex];\n        this.enterPattern(prop.value, onIdent);\n      }\n    }\n  }, {\n    key: \"enterArrayPattern\",\n    value: function enterArrayPattern(pattern, onIdent) {\n      for (var elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n        var element = pattern.elements[elementIndex];\n        this.enterPattern(element, onIdent);\n      }\n    }\n  }, {\n    key: \"enterRestElement\",\n    value: function enterRestElement(pattern, onIdent) {\n      this.enterPattern(pattern.argument, onIdent);\n    }\n  }, {\n    key: \"enterAssignmentPattern\",\n    value: function enterAssignmentPattern(pattern, onIdent) {\n      this.enterPattern(pattern.left, onIdent);\n    }\n  }, {\n    key: \"evaluateExpression\",\n    value: function evaluateExpression(expression) {\n      try {\n        var hook = this.hooks.evaluate.get(expression.type);\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result !== undefined) return result;\n        }\n      } catch (e) {\n        console.warn(e);\n        // ignore error\n      }\n\n      return new BasicEvaluatedExpression().setRange(expression.range);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            return this.parseString(expression.left) + this.parseString(expression.right);\n          }\n          break;\n        case \"Literal\":\n          return expression.value + \"\";\n      }\n      throw new Error(expression.type + \" is not supported as parameter for require\");\n    }\n  }, {\n    key: \"parseCalculatedString\",\n    value: function parseCalculatedString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            var left = this.parseCalculatedString(expression.left);\n            var right = this.parseCalculatedString(expression.right);\n            if (left.code) {\n              return {\n                range: left.range,\n                value: left.value,\n                code: true,\n                conditional: false\n              };\n            } else if (right.code) {\n              return {\n                range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n                value: left.value + right.value,\n                code: true,\n                conditional: false\n              };\n            } else {\n              return {\n                range: [left.range[0], right.range[1]],\n                value: left.value + right.value,\n                code: false,\n                conditional: false\n              };\n            }\n          }\n          break;\n        case \"ConditionalExpression\":\n          {\n            var consequent = this.parseCalculatedString(expression.consequent);\n            var alternate = this.parseCalculatedString(expression.alternate);\n            var items = [];\n            if (consequent.conditional) {\n              items.push.apply(items, _toConsumableArray(consequent.conditional));\n            } else if (!consequent.code) {\n              items.push(consequent);\n            } else {\n              break;\n            }\n            if (alternate.conditional) {\n              items.push.apply(items, _toConsumableArray(alternate.conditional));\n            } else if (!alternate.code) {\n              items.push(alternate);\n            } else {\n              break;\n            }\n            return {\n              range: undefined,\n              value: \"\",\n              code: true,\n              conditional: items\n            };\n          }\n        case \"Literal\":\n          return {\n            range: expression.range,\n            value: expression.value + \"\",\n            code: false,\n            conditional: false\n          };\n      }\n      return {\n        range: undefined,\n        value: \"\",\n        code: true,\n        conditional: false\n      };\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(source, initialState) {\n      var ast;\n      var comments;\n      if (typeof source === \"object\" && source !== null) {\n        ast = source;\n        comments = source.comments;\n      } else {\n        comments = [];\n        ast = Parser.parse(source, {\n          sourceType: this.sourceType,\n          onComment: comments\n        });\n      }\n      var oldScope = this.scope;\n      var oldState = this.state;\n      var oldComments = this.comments;\n      this.scope = {\n        topLevelScope: true,\n        inTry: false,\n        inShorthand: false,\n        isStrict: false,\n        definitions: new StackedSetMap(),\n        renames: new StackedSetMap()\n      };\n      var state = this.state = initialState || {};\n      this.comments = comments;\n      if (this.hooks.program.call(ast, comments) === undefined) {\n        this.detectStrictMode(ast.body);\n        this.prewalkStatements(ast.body);\n        this.walkStatements(ast.body);\n      }\n      this.scope = oldScope;\n      this.state = oldState;\n      this.comments = oldComments;\n      return state;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(source) {\n      var ast = Parser.parse(\"(\" + source + \")\", {\n        sourceType: this.sourceType,\n        locations: false\n      });\n      if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n        throw new Error(\"evaluate: Source is not a expression\");\n      }\n      return this.evaluateExpression(ast.body[0].expression);\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments(range) {\n      return this.comments.filter(function (comment) {\n        return comment.range[0] >= range[0] && comment.range[1] <= range[1];\n      });\n    }\n  }, {\n    key: \"parseCommentOptions\",\n    value: function parseCommentOptions(range) {\n      var comments = this.getComments(range);\n      if (comments.length === 0) {\n        return EMPTY_COMMENT_OPTIONS;\n      }\n      var options = {};\n      var errors = [];\n      var _iterator10 = _createForOfIteratorHelper(comments),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var comment = _step10.value;\n          var value = comment.value;\n          if (value && webpackCommentRegExp.test(value)) {\n            // try compile only if webpack options comment is present\n            try {\n              var val = vm.runInNewContext(\"(function(){return {\".concat(value, \"};})()\"));\n              Object.assign(options, val);\n            } catch (e) {\n              e.comment = comment;\n              errors.push(e);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      return {\n        options: options,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"getNameForExpression\",\n    value: function getNameForExpression(expression) {\n      var expr = expression;\n      var exprName = [];\n      while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n        exprName.push(expr.computed ? expr.property.value : expr.property.name);\n        expr = expr.object;\n      }\n      var free;\n      if (expr.type === \"Identifier\") {\n        free = !this.scope.definitions.has(expr.name);\n        exprName.push(this.scope.renames.get(expr.name) || expr.name);\n      } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n        free = true;\n        exprName.push(this.scope.renames.get(\"this\"));\n      } else if (expr.type === \"ThisExpression\") {\n        free = this.scope.topLevelScope;\n        exprName.push(\"this\");\n      } else {\n        return null;\n      }\n      var prefix = \"\";\n      for (var i = exprName.length - 1; i >= 2; i--) {\n        prefix += exprName[i] + \".\";\n      }\n      if (exprName.length > 1) {\n        prefix += exprName[1];\n      }\n      var name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n      var nameGeneral = prefix;\n      return {\n        name: name,\n        nameGeneral: nameGeneral,\n        free: free\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(code, options) {\n      var type = options ? options.sourceType : \"module\";\n      var parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n      if (type === \"auto\") {\n        parserOptions.sourceType = \"module\";\n      }\n      var ast;\n      var error;\n      var threw = false;\n      try {\n        ast = acorn.parse(code, parserOptions);\n      } catch (e) {\n        error = e;\n        threw = true;\n      }\n      if (threw && type === \"auto\") {\n        parserOptions.sourceType = \"script\";\n        if (Array.isArray(parserOptions.onComment)) {\n          parserOptions.onComment.length = 0;\n        }\n        try {\n          ast = acorn.parse(code, parserOptions);\n          threw = false;\n        } catch (e) {\n          threw = true;\n        }\n      }\n      if (threw) {\n        throw error;\n      }\n      return ast;\n    }\n  }]);\n  return Parser;\n}(Tapable); // TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}