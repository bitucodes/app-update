{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n// Generated by CoffeeScript 2.5.1\nvar AnsiPainter, Layout, RenderKid, Styles, blockStyleApplier, cloneAndMergeDeep, inlineStyleApplier, isPlainObject, stripAnsi, terminalWidth, tools;\ninlineStyleApplier = require('./renderKid/styleApplier/inline');\nblockStyleApplier = require('./renderKid/styleApplier/block');\nisPlainObject = require('lodash/isPlainObject');\nvar _require = require('./tools');\ncloneAndMergeDeep = _require.cloneAndMergeDeep;\nAnsiPainter = require('./AnsiPainter');\nStyles = require('./renderKid/Styles');\nLayout = require('./Layout');\ntools = require('./tools');\nstripAnsi = require('strip-ansi');\nterminalWidth = require('./tools').getCols();\nmodule.exports = RenderKid = function () {\n  var self;\n  var RenderKid = /*#__PURE__*/function () {\n    function RenderKid() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      _classCallCheck(this, RenderKid);\n      this.tools = self.tools;\n      this._config = cloneAndMergeDeep(self._defaultConfig, config);\n      this._initStyles();\n    }\n    _createClass(RenderKid, [{\n      key: \"_initStyles\",\n      value: function _initStyles() {\n        return this._styles = new Styles();\n      }\n    }, {\n      key: \"style\",\n      value: function style() {\n        return this._styles.setRule.apply(this._styles, arguments);\n      }\n    }, {\n      key: \"_getStyleFor\",\n      value: function _getStyleFor(el) {\n        return this._styles.getStyleFor(el);\n      }\n    }, {\n      key: \"render\",\n      value: function render(input) {\n        var withColors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return this._paint(this._renderDom(this._toDom(input)), withColors);\n      }\n    }, {\n      key: \"_toDom\",\n      value: function _toDom(input) {\n        if (typeof input === 'string') {\n          return this._parse(input);\n        } else if (isPlainObject(input) || Array.isArray(input)) {\n          return this._objToDom(input);\n        } else {\n          throw Error(\"Invalid input type. Only strings, arrays and objects are accepted\");\n        }\n      }\n    }, {\n      key: \"_objToDom\",\n      value: function _objToDom(o) {\n        var injectFakeRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        if (injectFakeRoot) {\n          o = {\n            body: o\n          };\n        }\n        return tools.objectToDom(o);\n      }\n    }, {\n      key: \"_paint\",\n      value: function _paint(text, withColors) {\n        var painted;\n        painted = AnsiPainter.paint(text);\n        if (withColors) {\n          return painted;\n        } else {\n          return stripAnsi(painted);\n        }\n      }\n    }, {\n      key: \"_parse\",\n      value: function _parse(string) {\n        var injectFakeRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        if (injectFakeRoot) {\n          string = '<body>' + string + '</body>';\n        }\n        return tools.stringToDom(string);\n      }\n    }, {\n      key: \"_renderDom\",\n      value: function _renderDom(dom) {\n        var bodyTag, layout, rootBlock;\n        bodyTag = dom[0];\n        layout = new Layout(this._config.layout);\n        rootBlock = layout.getRootBlock();\n        this._renderBlockNode(bodyTag, null, rootBlock);\n        return layout.get();\n      }\n    }, {\n      key: \"_renderChildrenOf\",\n      value: function _renderChildrenOf(parentNode, parentBlock) {\n        var i, len, node, nodes;\n        nodes = parentNode.children;\n        for (i = 0, len = nodes.length; i < len; i++) {\n          node = nodes[i];\n          this._renderNode(node, parentNode, parentBlock);\n        }\n      }\n    }, {\n      key: \"_renderNode\",\n      value: function _renderNode(node, parentNode, parentBlock) {\n        if (node.type === 'text') {\n          this._renderText(node, parentNode, parentBlock);\n        } else if (node.name === 'br') {\n          this._renderBr(node, parentNode, parentBlock);\n        } else if (this._isBlock(node)) {\n          this._renderBlockNode(node, parentNode, parentBlock);\n        } else if (this._isNone(node)) {\n          return;\n        } else {\n          this._renderInlineNode(node, parentNode, parentBlock);\n        }\n      }\n    }, {\n      key: \"_renderText\",\n      value: function _renderText(node, parentNode, parentBlock) {\n        var ref, text;\n        text = node.data;\n        text = text.replace(/\\s+/g, ' '); // let's only trim if the parent is an inline element\n\n        if ((parentNode != null ? (ref = parentNode.styles) != null ? ref.display : void 0 : void 0) !== 'inline') {\n          text = text.trim();\n        }\n        if (text.length === 0) {\n          return;\n        }\n        text = text.replace(/&nl;/g, \"\\n\");\n        return parentBlock.write(text);\n      }\n    }, {\n      key: \"_renderBlockNode\",\n      value: function _renderBlockNode(node, parentNode, parentBlock) {\n        var after, before, block, blockConfig;\n        var _blockStyleApplier$ap = blockStyleApplier.applyTo(node, this._getStyleFor(node));\n        before = _blockStyleApplier$ap.before;\n        after = _blockStyleApplier$ap.after;\n        blockConfig = _blockStyleApplier$ap.blockConfig;\n        block = parentBlock.openBlock(blockConfig);\n        if (before !== '') {\n          block.write(before);\n        }\n        this._renderChildrenOf(node, block);\n        if (after !== '') {\n          block.write(after);\n        }\n        return block.close();\n      }\n    }, {\n      key: \"_renderInlineNode\",\n      value: function _renderInlineNode(node, parentNode, parentBlock) {\n        var after, before;\n        var _inlineStyleApplier$a = inlineStyleApplier.applyTo(node, this._getStyleFor(node));\n        before = _inlineStyleApplier$a.before;\n        after = _inlineStyleApplier$a.after;\n        if (before !== '') {\n          parentBlock.write(before);\n        }\n        this._renderChildrenOf(node, parentBlock);\n        if (after !== '') {\n          return parentBlock.write(after);\n        }\n      }\n    }, {\n      key: \"_renderBr\",\n      value: function _renderBr(node, parentNode, parentBlock) {\n        return parentBlock.write(\"\\n\");\n      }\n    }, {\n      key: \"_isBlock\",\n      value: function _isBlock(node) {\n        return !(node.type === 'text' || node.name === 'br' || this._getStyleFor(node).display !== 'block');\n      }\n    }, {\n      key: \"_isNone\",\n      value: function _isNone(node) {\n        return !(node.type === 'text' || node.name === 'br' || this._getStyleFor(node).display !== 'none');\n      }\n    }]);\n    return RenderKid;\n  }();\n  ;\n  self = RenderKid;\n  RenderKid.AnsiPainter = AnsiPainter;\n  RenderKid.Layout = Layout;\n  RenderKid.quote = tools.quote;\n  RenderKid.tools = tools;\n  RenderKid._defaultConfig = {\n    layout: {\n      terminalWidth: terminalWidth\n    }\n  };\n  return RenderKid;\n}.call(void 0);","map":null,"metadata":{},"sourceType":"script"}