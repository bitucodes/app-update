{"ast":null,"code":"/**\n * Clean-css - https://github.com/jakubpawlowicz/clean-css\n * Released under the terms of MIT license\n *\n * Copyright (C) 2017 JakubPawlowicz.com\n */\n\nvar level0Optimize = require('./optimizer/level-0/optimize');\nvar level1Optimize = require('./optimizer/level-1/optimize');\nvar level2Optimize = require('./optimizer/level-2/optimize');\nvar validator = require('./optimizer/validator');\nvar compatibilityFrom = require('./options/compatibility');\nvar fetchFrom = require('./options/fetch');\nvar formatFrom = require('./options/format').formatFrom;\nvar inlineFrom = require('./options/inline');\nvar inlineRequestFrom = require('./options/inline-request');\nvar inlineTimeoutFrom = require('./options/inline-timeout');\nvar OptimizationLevel = require('./options/optimization-level').OptimizationLevel;\nvar optimizationLevelFrom = require('./options/optimization-level').optimizationLevelFrom;\nvar rebaseFrom = require('./options/rebase');\nvar rebaseToFrom = require('./options/rebase-to');\nvar inputSourceMapTracker = require('./reader/input-source-map-tracker');\nvar readSources = require('./reader/read-sources');\nvar serializeStyles = require('./writer/simple');\nvar serializeStylesAndSourceMap = require('./writer/source-maps');\nvar CleanCSS = module.exports = function CleanCSS(options) {\n  options = options || {};\n  this.options = {\n    compatibility: compatibilityFrom(options.compatibility),\n    fetch: fetchFrom(options.fetch),\n    format: formatFrom(options.format),\n    inline: inlineFrom(options.inline),\n    inlineRequest: inlineRequestFrom(options.inlineRequest),\n    inlineTimeout: inlineTimeoutFrom(options.inlineTimeout),\n    level: optimizationLevelFrom(options.level),\n    rebase: rebaseFrom(options.rebase),\n    rebaseTo: rebaseToFrom(options.rebaseTo),\n    returnPromise: !!options.returnPromise,\n    sourceMap: !!options.sourceMap,\n    sourceMapInlineSources: !!options.sourceMapInlineSources\n  };\n};\n\n// for compatibility with optimize-css-assets-webpack-plugin\nCleanCSS.process = function (input, opts) {\n  var cleanCss;\n  var optsTo = opts.to;\n  delete opts.to;\n  cleanCss = new CleanCSS(Object.assign({\n    returnPromise: true,\n    rebaseTo: optsTo\n  }, opts));\n  return cleanCss.minify(input).then(function (output) {\n    return {\n      css: output.styles\n    };\n  });\n};\nCleanCSS.prototype.minify = function (input, maybeSourceMap, maybeCallback) {\n  var options = this.options;\n  if (options.returnPromise) {\n    return new Promise(function (resolve, reject) {\n      minify(input, options, maybeSourceMap, function (errors, output) {\n        return errors ? reject(errors) : resolve(output);\n      });\n    });\n  } else {\n    return minify(input, options, maybeSourceMap, maybeCallback);\n  }\n};\nfunction minify(input, options, maybeSourceMap, maybeCallback) {\n  var sourceMap = typeof maybeSourceMap != 'function' ? maybeSourceMap : null;\n  var callback = typeof maybeCallback == 'function' ? maybeCallback : typeof maybeSourceMap == 'function' ? maybeSourceMap : null;\n  var context = {\n    stats: {\n      efficiency: 0,\n      minifiedSize: 0,\n      originalSize: 0,\n      startedAt: Date.now(),\n      timeSpent: 0\n    },\n    cache: {\n      specificity: {}\n    },\n    errors: [],\n    inlinedStylesheets: [],\n    inputSourceMapTracker: inputSourceMapTracker(),\n    localOnly: !callback,\n    options: options,\n    source: null,\n    sourcesContent: {},\n    validator: validator(options.compatibility),\n    warnings: []\n  };\n  if (sourceMap) {\n    context.inputSourceMapTracker.track(undefined, sourceMap);\n  }\n  return runner(context.localOnly)(function () {\n    return readSources(input, context, function (tokens) {\n      var serialize = context.options.sourceMap ? serializeStylesAndSourceMap : serializeStyles;\n      var optimizedTokens = optimize(tokens, context);\n      var optimizedStyles = serialize(optimizedTokens, context);\n      var output = withMetadata(optimizedStyles, context);\n      return callback ? callback(context.errors.length > 0 ? context.errors : null, output) : output;\n    });\n  });\n}\nfunction runner(localOnly) {\n  // to always execute code asynchronously when a callback is given\n  // more at blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n  return localOnly ? function (callback) {\n    return callback();\n  } : process.nextTick;\n}\nfunction optimize(tokens, context) {\n  var optimized;\n  optimized = level0Optimize(tokens, context);\n  optimized = OptimizationLevel.One in context.options.level ? level1Optimize(tokens, context) : tokens;\n  optimized = OptimizationLevel.Two in context.options.level ? level2Optimize(tokens, context, true) : optimized;\n  return optimized;\n}\nfunction withMetadata(output, context) {\n  output.stats = calculateStatsFrom(output.styles, context);\n  output.errors = context.errors;\n  output.inlinedStylesheets = context.inlinedStylesheets;\n  output.warnings = context.warnings;\n  return output;\n}\nfunction calculateStatsFrom(styles, context) {\n  var finishedAt = Date.now();\n  var timeSpent = finishedAt - context.stats.startedAt;\n  delete context.stats.startedAt;\n  context.stats.timeSpent = timeSpent;\n  context.stats.efficiency = 1 - styles.length / context.stats.originalSize;\n  context.stats.minifiedSize = styles.length;\n  return context.stats;\n}","map":null,"metadata":{},"sourceType":"script"}