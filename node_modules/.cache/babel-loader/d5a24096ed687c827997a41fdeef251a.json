{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n// Generated by CoffeeScript 2.5.1\nvar Block, SpecialString, cloneAndMergeDeep, terminalWidth;\nSpecialString = require('./SpecialString');\nterminalWidth = require('../tools').getCols();\nvar _require = require('../tools');\ncloneAndMergeDeep = _require.cloneAndMergeDeep;\nmodule.exports = Block = function () {\n  var self;\n  var Block = /*#__PURE__*/function () {\n    function Block(_layout, _parent) {\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var _name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      _classCallCheck(this, Block);\n      this._layout = _layout;\n      this._parent = _parent;\n      this._name = _name;\n      this._config = cloneAndMergeDeep(self.defaultConfig, config);\n      this._closed = false;\n      this._wasOpenOnce = false;\n      this._active = false;\n      this._buffer = '';\n      this._didSeparateBlock = false;\n      this._linePrependor = new this._config.linePrependor.fn(this._config.linePrependor.options);\n      this._lineAppendor = new this._config.lineAppendor.fn(this._config.lineAppendor.options);\n      this._blockPrependor = new this._config.blockPrependor.fn(this._config.blockPrependor.options);\n      this._blockAppendor = new this._config.blockAppendor.fn(this._config.blockAppendor.options);\n    }\n    _createClass(Block, [{\n      key: \"_activate\",\n      value: function _activate() {\n        var deactivateParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        if (this._active) {\n          throw Error(\"This block is already active. This is probably a bug in RenderKid itself\");\n        }\n        if (this._closed) {\n          throw Error(\"This block is closed and cannot be activated. This is probably a bug in RenderKid itself\");\n        }\n        this._active = true;\n        this._layout._activeBlock = this;\n        if (deactivateParent) {\n          if (this._parent != null) {\n            this._parent._deactivate(false);\n          }\n        }\n        return this;\n      }\n    }, {\n      key: \"_deactivate\",\n      value: function _deactivate() {\n        var activateParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this._ensureActive();\n        this._flushBuffer();\n        if (activateParent) {\n          if (this._parent != null) {\n            this._parent._activate(false);\n          }\n        }\n        this._active = false;\n        return this;\n      }\n    }, {\n      key: \"_ensureActive\",\n      value: function _ensureActive() {\n        if (!this._wasOpenOnce) {\n          throw Error(\"This block has never been open before. This is probably a bug in RenderKid itself.\");\n        }\n        if (!this._active) {\n          throw Error(\"This block is not active. This is probably a bug in RenderKid itself.\");\n        }\n        if (this._closed) {\n          throw Error(\"This block is already closed. This is probably a bug in RenderKid itself.\");\n        }\n      }\n    }, {\n      key: \"_open\",\n      value: function _open() {\n        if (this._wasOpenOnce) {\n          throw Error(\"Block._open() has been called twice. This is probably a RenderKid bug.\");\n        }\n        this._wasOpenOnce = true;\n        if (this._parent != null) {\n          this._parent.write(this._whatToPrependToBlock());\n        }\n        this._activate();\n        return this;\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        this._deactivate();\n        this._closed = true;\n        if (this._parent != null) {\n          this._parent.write(this._whatToAppendToBlock());\n        }\n        return this;\n      }\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return this._wasOpenOnce && !this._closed;\n      }\n    }, {\n      key: \"write\",\n      value: function write(str) {\n        this._ensureActive();\n        if (str === '') {\n          return;\n        }\n        str = String(str);\n        this._buffer += str;\n        return this;\n      }\n    }, {\n      key: \"openBlock\",\n      value: function openBlock(config, name) {\n        var block;\n        this._ensureActive();\n        block = new Block(this._layout, this, config, name);\n        block._open();\n        return block;\n      }\n    }, {\n      key: \"_flushBuffer\",\n      value: function _flushBuffer() {\n        var str;\n        if (this._buffer === '') {\n          return;\n        }\n        str = this._buffer;\n        this._buffer = '';\n        this._writeInline(str);\n      }\n    }, {\n      key: \"_toPrependToLine\",\n      value: function _toPrependToLine() {\n        var fromParent;\n        fromParent = '';\n        if (this._parent != null) {\n          fromParent = this._parent._toPrependToLine();\n        }\n        return this._linePrependor.render(fromParent);\n      }\n    }, {\n      key: \"_toAppendToLine\",\n      value: function _toAppendToLine() {\n        var fromParent;\n        fromParent = '';\n        if (this._parent != null) {\n          fromParent = this._parent._toAppendToLine();\n        }\n        return this._lineAppendor.render(fromParent);\n      }\n    }, {\n      key: \"_whatToPrependToBlock\",\n      value: function _whatToPrependToBlock() {\n        return this._blockPrependor.render();\n      }\n    }, {\n      key: \"_whatToAppendToBlock\",\n      value: function _whatToAppendToBlock() {\n        return this._blockAppendor.render();\n      }\n    }, {\n      key: \"_writeInline\",\n      value: function _writeInline(str) {\n        var i, j, k, l, lineBreaksToAppend, m, ref, ref1, ref2, remaining; // special characters (such as <bg-white>) don't require\n        // any wrapping...\n\n        if (new SpecialString(str).isOnlySpecialChars()) {\n          // ... and directly get appended to the layout.\n          this._layout._append(str);\n          return;\n        } // we'll be removing from the original string till it's empty\n\n        remaining = str; // we might need to add a few line breaks at the end of the text.\n\n        lineBreaksToAppend = 0; // if text starts with line breaks...\n\n        if (m = remaining.match(/^\\n+/)) {\n          // ... we want to write the exact same number of line breaks\n          // to the layout.\n          for (i = j = 1, ref = m[0].length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n            this._writeLine('');\n          }\n          remaining = remaining.substr(m[0].length, remaining.length);\n        } // and if the text ends with line breaks...\n\n        if (m = remaining.match(/\\n+$/)) {\n          // we want to write the exact same number of line breaks\n          // to the end of the layout.\n          lineBreaksToAppend = m[0].length;\n          remaining = remaining.substr(0, remaining.length - m[0].length);\n        } // now let's parse the body of the text:\n\n        while (remaining.length > 0) {\n          // anything other than a break line...\n          if (m = remaining.match(/^[^\\n]+/)) {\n            // ... should be wrapped as a block of text.\n            this._writeLine(m[0]);\n            remaining = remaining.substr(m[0].length, remaining.length); // for any number of line breaks we find inside the text...\n          } else if (m = remaining.match(/^\\n+/)) {\n            // ... we write one less break line to the layout.\n            for (i = k = 1, ref1 = m[0].length; 1 <= ref1 ? k < ref1 : k > ref1; i = 1 <= ref1 ? ++k : --k) {\n              this._writeLine('');\n            }\n            remaining = remaining.substr(m[0].length, remaining.length);\n          }\n        } // if we had line breaks to append to the layout...\n\n        if (lineBreaksToAppend > 0) {\n          // ... we append the exact same number of line breaks to the layout.\n          for (i = l = 1, ref2 = lineBreaksToAppend; 1 <= ref2 ? l <= ref2 : l >= ref2; i = 1 <= ref2 ? ++l : --l) {\n            this._writeLine('');\n          }\n        }\n      } // wraps a line into multiple lines if necessary, adds horizontal margins,\n      // etc, and appends it to the layout.\n    }, {\n      key: \"_writeLine\",\n      value: function _writeLine(str) {\n        var line, lineContent, lineContentLength, remaining, roomLeft, toAppend, toAppendLength, toPrepend, toPrependLength; // we'll be cutting from our string as we go\n\n        remaining = new SpecialString(str);\n        while (true) {\n          // left margin...\n          // this will continue until nothing is left of our block.\n          toPrepend = this._toPrependToLine(); // ... and its length\n\n          toPrependLength = new SpecialString(toPrepend).length; // right margin...\n\n          toAppend = this._toAppendToLine(); // ... and its length\n\n          toAppendLength = new SpecialString(toAppend).length; // how much room is left for content\n\n          roomLeft = this._layout._config.terminalWidth - (toPrependLength + toAppendLength); // how much room each line of content will have\n\n          lineContentLength = Math.min(this._config.width, roomLeft); // cut line content, only for the amount needed\n\n          lineContent = remaining.cut(0, lineContentLength, true); // line will consist of both margins and the content\n\n          line = toPrepend + lineContent.str + toAppend; // send it off to layout\n\n          this._layout._appendLine(line);\n          if (remaining.isEmpty()) {\n            break;\n          }\n        }\n      }\n    }]);\n    return Block;\n  }();\n  ;\n  self = Block;\n  Block.defaultConfig = {\n    blockPrependor: {\n      fn: require('./block/blockPrependor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    blockAppendor: {\n      fn: require('./block/blockAppendor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    linePrependor: {\n      fn: require('./block/linePrependor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    lineAppendor: {\n      fn: require('./block/lineAppendor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    lineWrapper: {\n      fn: require('./block/lineWrapper/Default'),\n      options: {\n        lineWidth: null\n      }\n    },\n    width: terminalWidth,\n    prefixRaw: '',\n    suffixRaw: ''\n  };\n  return Block;\n}.call(void 0);","map":null,"metadata":{},"sourceType":"script"}