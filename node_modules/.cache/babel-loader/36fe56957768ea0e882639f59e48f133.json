{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar crypto = require(\"crypto\");\nvar SortableSet = require(\"../util/SortableSet\");\nvar GraphHelpers = require(\"../GraphHelpers\");\nvar _require = require(\"../util/SetHelpers\"),\n  isSubset = _require.isSubset;\nvar deterministicGrouping = require(\"../util/deterministicGrouping\");\nvar contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nvar deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */deterministicGrouping;\nvar hashFilename = function hashFilename(name) {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\nvar sortByIdentifier = function sortByIdentifier(a, b) {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\nvar getRequests = function getRequests(chunk) {\n  var requests = 0;\n  var _iterator = _createForOfIteratorHelper(chunk.groupsIterable),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunkGroup = _step.value;\n      requests = Math.max(requests, chunkGroup.chunks.length);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return requests;\n};\nvar getModulesSize = function getModulesSize(modules) {\n  var sum = 0;\n  var _iterator2 = _createForOfIteratorHelper(modules),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var m = _step2.value;\n      sum += m.size();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nvar isOverlap = function isOverlap(a, b) {\n  var _iterator3 = _createForOfIteratorHelper(a),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      if (b.has(item)) return true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return false;\n};\nvar compareEntries = function compareEntries(a, b) {\n  // 1. by priority\n  var diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority;\n  // 2. by number of chunks\n  var diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount;\n  // 3. by size reduction\n  var aSizeReduce = a.size * (a.chunks.size - 1);\n  var bSizeReduce = b.size * (b.chunks.size - 1);\n  var diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce;\n  // 4. by number of modules (to be able to compare by identifier)\n  var modulesA = a.modules;\n  var modulesB = b.modules;\n  var diff = modulesA.size - modulesB.size;\n  if (diff) return diff;\n  // 5. by module identifiers\n  modulesA.sort();\n  modulesB.sort();\n  var aI = modulesA[Symbol.iterator]();\n  var bI = modulesB[Symbol.iterator]();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    var aItem = aI.next();\n    var bItem = bI.next();\n    if (aItem.done) return 0;\n    var aModuleIdentifier = aItem.value.identifier();\n    var bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\nvar INITIAL_CHUNK_FILTER = function INITIAL_CHUNK_FILTER(chunk) {\n  return chunk.canBeInitial();\n};\nvar ASYNC_CHUNK_FILTER = function ASYNC_CHUNK_FILTER(chunk) {\n  return !chunk.canBeInitial();\n};\nvar ALL_CHUNK_FILTER = function ALL_CHUNK_FILTER(chunk) {\n  return true;\n};\nmodule.exports = /*#__PURE__*/function () {\n  function SplitChunksPlugin(options) {\n    _classCallCheck(this, SplitChunksPlugin);\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n  _createClass(SplitChunksPlugin, [{\n    key: \"apply\",\n    /**\n     * @param {Compiler} compiler webpack compiler\n     * @returns {void}\n     */\n    value: function apply(compiler) {\n      var _this = this;\n      compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", function (compilation) {\n        var alreadyOptimized = false;\n        compilation.hooks.unseal.tap(\"SplitChunksPlugin\", function () {\n          alreadyOptimized = false;\n        });\n        compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", function (chunks) {\n          if (alreadyOptimized) return;\n          alreadyOptimized = true;\n          // Give each selected chunk an index (to create strings from chunks)\n          var indexMap = new Map();\n          var index = 1;\n          var _iterator4 = _createForOfIteratorHelper(chunks),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var chunk = _step4.value;\n              indexMap.set(chunk, index++);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          var getKey = function getKey(chunks) {\n            return Array.from(chunks, function (c) {\n              return indexMap.get(c);\n            }).sort().join();\n          };\n          /** @type {Map<string, Set<Chunk>>} */\n          var chunkSetsInGraph = new Map();\n          var _iterator5 = _createForOfIteratorHelper(compilation.modules),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _module = _step5.value;\n              var chunksKey = getKey(_module.chunksIterable);\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(_module.chunksIterable));\n              }\n            }\n\n            // group these set of chunks by count\n            // to allow to check less sets via isSubset\n            // (only smaller sets can be subset)\n            /** @type {Map<number, Array<Set<Chunk>>>} */\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          var chunkSetsByCount = new Map();\n          var _iterator6 = _createForOfIteratorHelper(chunkSetsInGraph.values()),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var chunksSet = _step6.value;\n              var count = chunksSet.size;\n              var array = chunkSetsByCount.get(count);\n              if (array === undefined) {\n                array = [];\n                chunkSetsByCount.set(count, array);\n              }\n              array.push(chunksSet);\n            }\n\n            // Create a list of possible combinations\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          var combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n          var getCombinations = function getCombinations(key) {\n            var chunksSet = chunkSetsInGraph.get(key);\n            var array = [chunksSet];\n            if (chunksSet.size > 1) {\n              var _iterator7 = _createForOfIteratorHelper(chunkSetsByCount),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _step7$value = _slicedToArray(_step7.value, 2),\n                    count = _step7$value[0],\n                    setArray = _step7$value[1];\n                  // \"equal\" is not needed because they would have been merge in the first step\n                  if (count < chunksSet.size) {\n                    var _iterator8 = _createForOfIteratorHelper(setArray),\n                      _step8;\n                    try {\n                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                        var set = _step8.value;\n                        if (isSubset(chunksSet, set)) {\n                          array.push(set);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator8.e(err);\n                    } finally {\n                      _iterator8.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n            return array;\n          };\n\n          /**\n           * @typedef {Object} SelectedChunksResult\n           * @property {Chunk[]} chunks the list of chunks\n           * @property {string} key a key of the list\n           */\n\n          /**\n           * @typedef {function(Chunk): boolean} ChunkFilterFunction\n           */\n\n          /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n          var selectedChunksCacheByChunksSet = new WeakMap();\n\n          /**\n           * get list and key by applying the filter function to the list\n           * It is cached for performance reasons\n           * @param {Set<Chunk>} chunks list of chunks\n           * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n           * @returns {SelectedChunksResult} list and key\n           */\n          var getSelectedChunks = function getSelectedChunks(chunks, chunkFilter) {\n            var entry = selectedChunksCacheByChunksSet.get(chunks);\n            if (entry === undefined) {\n              entry = new WeakMap();\n              selectedChunksCacheByChunksSet.set(chunks, entry);\n            }\n            /** @type {SelectedChunksResult} */\n            var entry2 = entry.get(chunkFilter);\n            if (entry2 === undefined) {\n              /** @type {Chunk[]} */\n              var selectedChunks = [];\n              var _iterator9 = _createForOfIteratorHelper(chunks),\n                _step9;\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var chunk = _step9.value;\n                  if (chunkFilter(chunk)) selectedChunks.push(chunk);\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n              entry2 = {\n                chunks: selectedChunks,\n                key: getKey(selectedChunks)\n              };\n              entry.set(chunkFilter, entry2);\n            }\n            return entry2;\n          };\n\n          /**\n           * @typedef {Object} ChunksInfoItem\n           * @property {SortableSet} modules\n           * @property {TODO} cacheGroup\n           * @property {string} name\n           * @property {number} size\n           * @property {Set<Chunk>} chunks\n           * @property {Set<Chunk>} reuseableChunks\n           * @property {Set<string>} chunksKeys\n           */\n\n          // Map a list of chunks to a list of modules\n          // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n          /** @type {Map<string, ChunksInfoItem>} */\n          var chunksInfoMap = new Map();\n\n          /**\n           * @param {TODO} cacheGroup the current cache group\n           * @param {Chunk[]} selectedChunks chunks selected for this module\n           * @param {string} selectedChunksKey a key of selectedChunks\n           * @param {Module} module the current module\n           * @returns {void}\n           */\n          var addModuleToChunksInfoMap = function addModuleToChunksInfoMap(cacheGroup, selectedChunks, selectedChunksKey, module) {\n            // Break if minimum number of chunks is not reached\n            if (selectedChunks.length < cacheGroup.minChunks) return;\n            // Determine name for split chunk\n            var name = cacheGroup.getName(module, selectedChunks, cacheGroup.key);\n            // Create key for maps\n            // When it has a name we use the name as key\n            // Elsewise we create the key from chunks and cache group key\n            // This automatically merges equal names\n            var key = name && \"name:\".concat(name) || \"chunks:\".concat(selectedChunksKey, \" key:\").concat(cacheGroup.key);\n            // Add module to maps\n            var info = chunksInfoMap.get(key);\n            if (info === undefined) {\n              chunksInfoMap.set(key, info = {\n                modules: new SortableSet(undefined, sortByIdentifier),\n                cacheGroup: cacheGroup,\n                name: name,\n                size: 0,\n                chunks: new Set(),\n                reuseableChunks: new Set(),\n                chunksKeys: new Set()\n              });\n            } else {\n              if (info.cacheGroup !== cacheGroup) {\n                if (info.cacheGroup.priority < cacheGroup.priority) {\n                  info.cacheGroup = cacheGroup;\n                }\n              }\n            }\n            info.modules.add(module);\n            info.size += module.size();\n            if (!info.chunksKeys.has(selectedChunksKey)) {\n              info.chunksKeys.add(selectedChunksKey);\n              var _iterator10 = _createForOfIteratorHelper(selectedChunks),\n                _step10;\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var chunk = _step10.value;\n                  info.chunks.add(chunk);\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            }\n          };\n\n          // Walk through all modules\n          var _iterator11 = _createForOfIteratorHelper(compilation.modules),\n            _step11;\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var _module2 = _step11.value;\n              // Get cache group\n              var cacheGroups = _this.options.getCacheGroups(_module2);\n              if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n                continue;\n              }\n\n              // Prepare some values\n              var _chunksKey = getKey(_module2.chunksIterable);\n              var combs = combinationsCache.get(_chunksKey);\n              if (combs === undefined) {\n                combs = getCombinations(_chunksKey);\n                combinationsCache.set(_chunksKey, combs);\n              }\n              var _iterator13 = _createForOfIteratorHelper(cacheGroups),\n                _step13;\n              try {\n                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                  var cacheGroupSource = _step13.value;\n                  var cacheGroup = {\n                    key: cacheGroupSource.key,\n                    priority: cacheGroupSource.priority || 0,\n                    chunksFilter: cacheGroupSource.chunksFilter || _this.options.chunksFilter,\n                    minSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : _this.options.minSize,\n                    maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : _this.options.maxSize,\n                    minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : _this.options.minChunks,\n                    maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxAsyncRequests,\n                    maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxInitialRequests,\n                    getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : _this.options.getName,\n                    filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : _this.options.filename,\n                    automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : _this.options.automaticNameDelimiter,\n                    reuseExistingChunk: cacheGroupSource.reuseExistingChunk\n                  };\n                  // For all combination of chunk selection\n                  var _iterator14 = _createForOfIteratorHelper(combs),\n                    _step14;\n                  try {\n                    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                      var chunkCombination = _step14.value;\n                      // Break if minimum number of chunks is not reached\n                      if (chunkCombination.size < cacheGroup.minChunks) continue;\n                      // Select chunks by configuration\n                      var _getSelectedChunks = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter),\n                        selectedChunks = _getSelectedChunks.chunks,\n                        selectedChunksKey = _getSelectedChunks.key;\n                      addModuleToChunksInfoMap(cacheGroup, selectedChunks, selectedChunksKey, _module2);\n                    }\n                  } catch (err) {\n                    _iterator14.e(err);\n                  } finally {\n                    _iterator14.f();\n                  }\n                }\n              } catch (err) {\n                _iterator13.e(err);\n              } finally {\n                _iterator13.f();\n              }\n            }\n\n            /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string}>} */\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n          var maxSizeQueueMap = new Map();\n          var _loop = function _loop() {\n            // Find best matching entry\n            var bestEntryKey = void 0;\n            var bestEntry = void 0;\n            var _iterator15 = _createForOfIteratorHelper(chunksInfoMap),\n              _step15;\n            try {\n              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                var pair = _step15.value;\n                var key = pair[0];\n                var info = pair[1];\n                if (info.size >= info.cacheGroup.minSize) {\n                  if (bestEntry === undefined) {\n                    bestEntry = info;\n                    bestEntryKey = key;\n                  } else if (compareEntries(bestEntry, info) < 0) {\n                    bestEntry = info;\n                    bestEntryKey = key;\n                  }\n                }\n              }\n\n              // No suitable item left\n            } catch (err) {\n              _iterator15.e(err);\n            } finally {\n              _iterator15.f();\n            }\n            if (bestEntry === undefined) return \"break\";\n            var item = bestEntry;\n            chunksInfoMap.delete(bestEntryKey);\n            var chunkName = item.name;\n            // Variable for the new chunk (lazy created)\n            /** @type {Chunk} */\n            var newChunk = void 0;\n            // When no chunk name, check if we can reuse a chunk instead of creating a new one\n            var isReused = false;\n            if (item.cacheGroup.reuseExistingChunk) {\n              var _iterator16 = _createForOfIteratorHelper(item.chunks),\n                _step16;\n              try {\n                outer: for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                  var _chunk = _step16.value;\n                  if (_chunk.getNumberOfModules() !== item.modules.size) continue;\n                  if (_chunk.hasEntryModule()) continue;\n                  var _iterator17 = _createForOfIteratorHelper(item.modules),\n                    _step17;\n                  try {\n                    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                      var _module3 = _step17.value;\n                      if (!_chunk.containsModule(_module3)) continue outer;\n                    }\n                  } catch (err) {\n                    _iterator17.e(err);\n                  } finally {\n                    _iterator17.f();\n                  }\n                  if (!newChunk || !newChunk.name) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length < newChunk.name.length) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length === newChunk.name.length && _chunk.name < newChunk.name) {\n                    newChunk = _chunk;\n                  }\n                  chunkName = undefined;\n                  isReused = true;\n                }\n              } catch (err) {\n                _iterator16.e(err);\n              } finally {\n                _iterator16.f();\n              }\n            }\n            // Check if maxRequests condition can be fulfilled\n\n            var usedChunks = Array.from(item.chunks).filter(function (chunk) {\n              // skip if we address ourself\n              return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n            });\n\n            // Skip when no chunk selected\n            if (usedChunks.length === 0) return \"continue\";\n            var chunkInLimit = usedChunks.filter(function (chunk) {\n              // respect max requests when not enforced\n              var maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n              return !isFinite(maxRequests) || getRequests(chunk) < maxRequests;\n            });\n            if (chunkInLimit.length < usedChunks.length) {\n              var _iterator18 = _createForOfIteratorHelper(item.modules),\n                _step18;\n              try {\n                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                  var _module4 = _step18.value;\n                  addModuleToChunksInfoMap(item.cacheGroup, chunkInLimit, getKey(chunkInLimit), _module4);\n                }\n              } catch (err) {\n                _iterator18.e(err);\n              } finally {\n                _iterator18.f();\n              }\n              return \"continue\";\n            }\n\n            // Create the new chunk if not reusing one\n            if (!isReused) {\n              newChunk = compilation.addChunk(chunkName);\n            }\n            // Walk through all chunks\n            var _iterator19 = _createForOfIteratorHelper(usedChunks),\n              _step19;\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _chunk4 = _step19.value;\n                // Add graph connections for splitted chunk\n                _chunk4.split(newChunk);\n              }\n\n              // Add a note to the chunk\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n            newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n            if (item.cacheGroup.key) {\n              newChunk.chunkReason += \" (cache group: \".concat(item.cacheGroup.key, \")\");\n            }\n            if (chunkName) {\n              newChunk.chunkReason += \" (name: \".concat(chunkName, \")\");\n              // If the chosen name is already an entry point we remove the entry point\n              var entrypoint = compilation.entrypoints.get(chunkName);\n              if (entrypoint) {\n                compilation.entrypoints.delete(chunkName);\n                entrypoint.remove();\n                newChunk.entryModule = undefined;\n              }\n            }\n            if (item.cacheGroup.filename) {\n              if (!newChunk.isOnlyInitial()) {\n                throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + \"(cache group: \".concat(item.cacheGroup.key, \")\"));\n              }\n              newChunk.filenameTemplate = item.cacheGroup.filename;\n            }\n            if (!isReused) {\n              // Add all modules to the new chunk\n              var _iterator20 = _createForOfIteratorHelper(item.modules),\n                _step20;\n              try {\n                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                  var _module5 = _step20.value;\n                  if (typeof _module5.chunkCondition === \"function\") {\n                    if (!_module5.chunkCondition(newChunk)) continue;\n                  }\n                  // Add module to new chunk\n                  GraphHelpers.connectChunkAndModule(newChunk, _module5);\n                  // Remove module from used chunks\n                  var _iterator21 = _createForOfIteratorHelper(usedChunks),\n                    _step21;\n                  try {\n                    for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                      var _chunk2 = _step21.value;\n                      _chunk2.removeModule(_module5);\n                      _module5.rewriteChunkInReasons(_chunk2, [newChunk]);\n                    }\n                  } catch (err) {\n                    _iterator21.e(err);\n                  } finally {\n                    _iterator21.f();\n                  }\n                }\n              } catch (err) {\n                _iterator20.e(err);\n              } finally {\n                _iterator20.f();\n              }\n            } else {\n              // Remove all modules from used chunks\n              var _iterator22 = _createForOfIteratorHelper(item.modules),\n                _step22;\n              try {\n                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                  var _module6 = _step22.value;\n                  var _iterator23 = _createForOfIteratorHelper(usedChunks),\n                    _step23;\n                  try {\n                    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                      var _chunk3 = _step23.value;\n                      _chunk3.removeModule(_module6);\n                      _module6.rewriteChunkInReasons(_chunk3, [newChunk]);\n                    }\n                  } catch (err) {\n                    _iterator23.e(err);\n                  } finally {\n                    _iterator23.f();\n                  }\n                }\n              } catch (err) {\n                _iterator22.e(err);\n              } finally {\n                _iterator22.f();\n              }\n            }\n            if (item.cacheGroup.maxSize > 0) {\n              var oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n              maxSizeQueueMap.set(newChunk, {\n                minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSize),\n                maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n                automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter\n              });\n            }\n\n            // remove all modules from other entries and update size\n            var _iterator24 = _createForOfIteratorHelper(chunksInfoMap),\n              _step24;\n            try {\n              for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                var _step24$value = _slicedToArray(_step24.value, 2),\n                  _key = _step24$value[0],\n                  _info = _step24$value[1];\n                if (isOverlap(_info.chunks, item.chunks)) {\n                  var oldSize = _info.modules.size;\n                  var _iterator25 = _createForOfIteratorHelper(item.modules),\n                    _step25;\n                  try {\n                    for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                      var _module7 = _step25.value;\n                      _info.modules.delete(_module7);\n                    }\n                  } catch (err) {\n                    _iterator25.e(err);\n                  } finally {\n                    _iterator25.f();\n                  }\n                  if (_info.modules.size === 0) {\n                    chunksInfoMap.delete(_key);\n                    continue;\n                  }\n                  if (_info.modules.size !== oldSize) {\n                    _info.size = getModulesSize(_info.modules);\n                    if (_info.size < _info.cacheGroup.minSize) {\n                      chunksInfoMap.delete(_key);\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator24.e(err);\n            } finally {\n              _iterator24.f();\n            }\n          };\n          while (chunksInfoMap.size > 0) {\n            var _ret = _loop();\n            if (_ret === \"break\") break;\n            if (_ret === \"continue\") continue;\n          }\n\n          // Make sure that maxSize is fulfilled\n          var _iterator12 = _createForOfIteratorHelper(compilation.chunks.slice()),\n            _step12;\n          try {\n            var _loop2 = function _loop2() {\n              var chunk = _step12.value;\n              var _ref = maxSizeQueueMap.get(chunk) || _this.options.fallbackCacheGroup,\n                minSize = _ref.minSize,\n                maxSize = _ref.maxSize,\n                automaticNameDelimiter = _ref.automaticNameDelimiter;\n              if (!maxSize) return \"continue\";\n              var results = deterministicGroupingForModules({\n                maxSize: maxSize,\n                minSize: minSize,\n                items: chunk.modulesIterable,\n                getKey: function getKey(module) {\n                  var ident = contextify(compilation.options.context, module.identifier());\n                  var name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n                  var fullKey = name + automaticNameDelimiter + hashFilename(ident);\n                  return fullKey.replace(/[\\\\/?]/g, \"_\");\n                },\n                getSize: function getSize(module) {\n                  return module.size();\n                }\n              });\n              results.sort(function (a, b) {\n                if (a.key < b.key) return -1;\n                if (a.key > b.key) return 1;\n                return 0;\n              });\n              for (var i = 0; i < results.length; i++) {\n                var group = results[i];\n                var key = _this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n                var name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n                if (name && name.length > 100) {\n                  name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n                }\n                var newPart = void 0;\n                if (i !== results.length - 1) {\n                  newPart = compilation.addChunk(name);\n                  chunk.split(newPart);\n                  newPart.chunkReason = chunk.chunkReason;\n                  // Add all modules to the new chunk\n                  var _iterator26 = _createForOfIteratorHelper(group.items),\n                    _step26;\n                  try {\n                    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                      var _module8 = _step26.value;\n                      if (typeof _module8.chunkCondition === \"function\") {\n                        if (!_module8.chunkCondition(newPart)) continue;\n                      }\n                      // Add module to new chunk\n                      GraphHelpers.connectChunkAndModule(newPart, _module8);\n                      // Remove module from used chunks\n                      chunk.removeModule(_module8);\n                      _module8.rewriteChunkInReasons(chunk, [newPart]);\n                    }\n                  } catch (err) {\n                    _iterator26.e(err);\n                  } finally {\n                    _iterator26.f();\n                  }\n                } else {\n                  // change the chunk to be a part\n                  newPart = chunk;\n                  chunk.name = name;\n                }\n              }\n            };\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var _ret2 = _loop2();\n              if (_ret2 === \"continue\") continue;\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"normalizeOptions\",\n    value: function normalizeOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n        minSize: options.minSize || 0,\n        maxSize: options.maxSize || 0,\n        minChunks: options.minChunks || 1,\n        maxAsyncRequests: options.maxAsyncRequests || 1,\n        maxInitialRequests: options.maxInitialRequests || 1,\n        hidePathInfo: options.hidePathInfo || false,\n        filename: options.filename || undefined,\n        getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n          cacheGroups: options.cacheGroups,\n          name: options.name,\n          automaticNameDelimiter: options.automaticNameDelimiter\n        }),\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n      };\n    }\n  }, {\n    key: \"normalizeName\",\n    value: function normalizeName(_ref2) {\n      var name = _ref2.name,\n        automaticNameDelimiter = _ref2.automaticNameDelimiter,\n        automaticNamePrefix = _ref2.automaticNamePrefix;\n      if (name === true) {\n        /** @type {WeakMap<Chunk[], Record<string, string>>} */\n        var cache = new WeakMap();\n        var fn = function fn(module, chunks, cacheGroup) {\n          var cacheEntry = cache.get(chunks);\n          if (cacheEntry === undefined) {\n            cacheEntry = {};\n            cache.set(chunks, cacheEntry);\n          } else if (cacheGroup in cacheEntry) {\n            return cacheEntry[cacheGroup];\n          }\n          var names = chunks.map(function (c) {\n            return c.name;\n          });\n          if (!names.every(Boolean)) {\n            cacheEntry[cacheGroup] = undefined;\n            return;\n          }\n          names.sort();\n          var prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n          var namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n          var name = namePrefix + names.join(automaticNameDelimiter);\n          // Filenames and paths can't be too long otherwise an\n          // ENAMETOOLONG error is raised. If the generated name if too\n          // long, it is truncated and a hash is appended. The limit has\n          // been set to 100 to prevent `[name].[chunkhash].[ext]` from\n          // generating a 256+ character string.\n          if (name.length > 100) {\n            name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n          }\n          cacheEntry[cacheGroup] = name;\n          return name;\n        };\n        return fn;\n      }\n      if (typeof name === \"string\") {\n        var _fn = function _fn() {\n          return name;\n        };\n        return _fn;\n      }\n      if (typeof name === \"function\") return name;\n    }\n  }, {\n    key: \"normalizeChunksFilter\",\n    value: function normalizeChunksFilter(chunks) {\n      if (chunks === \"initial\") {\n        return INITIAL_CHUNK_FILTER;\n      }\n      if (chunks === \"async\") {\n        return ASYNC_CHUNK_FILTER;\n      }\n      if (chunks === \"all\") {\n        return ALL_CHUNK_FILTER;\n      }\n      if (typeof chunks === \"function\") return chunks;\n    }\n  }, {\n    key: \"normalizeFallbackCacheGroup\",\n    value: function normalizeFallbackCacheGroup(_ref3, _ref4) {\n      var _ref3$minSize = _ref3.minSize,\n        minSize = _ref3$minSize === void 0 ? undefined : _ref3$minSize,\n        _ref3$maxSize = _ref3.maxSize,\n        maxSize = _ref3$maxSize === void 0 ? undefined : _ref3$maxSize,\n        _ref3$automaticNameDe = _ref3.automaticNameDelimiter,\n        automaticNameDelimiter = _ref3$automaticNameDe === void 0 ? undefined : _ref3$automaticNameDe;\n      var _ref4$minSize = _ref4.minSize,\n        defaultMinSize = _ref4$minSize === void 0 ? undefined : _ref4$minSize,\n        _ref4$maxSize = _ref4.maxSize,\n        defaultMaxSize = _ref4$maxSize === void 0 ? undefined : _ref4$maxSize,\n        _ref4$automaticNameDe = _ref4.automaticNameDelimiter,\n        defaultAutomaticNameDelimiter = _ref4$automaticNameDe === void 0 ? undefined : _ref4$automaticNameDe;\n      return {\n        minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n        maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n        automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n      };\n    }\n  }, {\n    key: \"normalizeCacheGroups\",\n    value: function normalizeCacheGroups(_ref5) {\n      var cacheGroups = _ref5.cacheGroups,\n        name = _ref5.name,\n        automaticNameDelimiter = _ref5.automaticNameDelimiter;\n      if (typeof cacheGroups === \"function\") {\n        // TODO webpack 5 remove this\n        if (cacheGroups.length !== 1) {\n          return function (module) {\n            return cacheGroups(module, module.getChunks());\n          };\n        }\n        return cacheGroups;\n      }\n      if (cacheGroups && typeof cacheGroups === \"object\") {\n        var _fn2 = function _fn2(module) {\n          var results;\n          for (var _i = 0, _Object$keys = Object.keys(cacheGroups); _i < _Object$keys.length; _i++) {\n            var key = _Object$keys[_i];\n            var option = cacheGroups[key];\n            if (option === false) continue;\n            if (option instanceof RegExp || typeof option === \"string\") {\n              option = {\n                test: option\n              };\n            }\n            if (typeof option === \"function\") {\n              var result = option(module);\n              if (result) {\n                if (results === undefined) results = [];\n                var _iterator27 = _createForOfIteratorHelper(Array.isArray(result) ? result : [result]),\n                  _step27;\n                try {\n                  var _loop3 = function _loop3() {\n                    var r = _step27.value;\n                    var result = Object.assign({\n                      key: key\n                    }, r);\n                    if (result.name) result.getName = function () {\n                      return result.name;\n                    };\n                    if (result.chunks) {\n                      result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                    }\n                    results.push(result);\n                  };\n                  for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                    _loop3();\n                  }\n                } catch (err) {\n                  _iterator27.e(err);\n                } finally {\n                  _iterator27.f();\n                }\n              }\n            } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n              if (results === undefined) results = [];\n              results.push({\n                key: key,\n                priority: option.priority,\n                getName: SplitChunksPlugin.normalizeName({\n                  name: option.name || name,\n                  automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                  automaticNamePrefix: option.automaticNamePrefix\n                }) || function () {},\n                chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n                enforce: option.enforce,\n                minSize: option.minSize,\n                maxSize: option.maxSize,\n                minChunks: option.minChunks,\n                maxAsyncRequests: option.maxAsyncRequests,\n                maxInitialRequests: option.maxInitialRequests,\n                filename: option.filename,\n                reuseExistingChunk: option.reuseExistingChunk\n              });\n            }\n          }\n          return results;\n        };\n        return _fn2;\n      }\n      var fn = function fn() {};\n      return fn;\n    }\n  }, {\n    key: \"checkTest\",\n    value: function checkTest(test, module) {\n      if (test === undefined) return true;\n      if (typeof test === \"function\") {\n        if (test.length !== 1) {\n          return test(module, module.getChunks());\n        }\n        return test(module);\n      }\n      if (typeof test === \"boolean\") return test;\n      if (typeof test === \"string\") {\n        if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n          return true;\n        }\n        var _iterator28 = _createForOfIteratorHelper(module.chunksIterable),\n          _step28;\n        try {\n          for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n            var chunk = _step28.value;\n            if (chunk.name && chunk.name.startsWith(test)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator28.e(err);\n        } finally {\n          _iterator28.f();\n        }\n        return false;\n      }\n      if (test instanceof RegExp) {\n        if (module.nameForCondition && test.test(module.nameForCondition())) {\n          return true;\n        }\n        var _iterator29 = _createForOfIteratorHelper(module.chunksIterable),\n          _step29;\n        try {\n          for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n            var _chunk5 = _step29.value;\n            if (_chunk5.name && test.test(_chunk5.name)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator29.e(err);\n        } finally {\n          _iterator29.f();\n        }\n        return false;\n      }\n      return false;\n    }\n  }]);\n  return SplitChunksPlugin;\n}();","map":null,"metadata":{},"sourceType":"script"}