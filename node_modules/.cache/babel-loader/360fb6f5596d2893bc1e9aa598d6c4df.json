{"ast":null,"code":"import { decode } from \"@webassemblyjs/wasm-parser\";\nimport { traverse } from \"@webassemblyjs/ast\";\nimport { cloneNode } from \"@webassemblyjs/ast/lib/clone\";\nimport { shrinkPaddedLEB128 } from \"@webassemblyjs/wasm-opt\";\nimport { getSectionForNode } from \"@webassemblyjs/helper-wasm-bytecode\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\nimport { applyOperations } from \"./apply\";\nfunction hashNode(node) {\n  return JSON.stringify(node);\n}\nfunction preprocess(ab) {\n  var optBin = shrinkPaddedLEB128(new Uint8Array(ab));\n  return optBin.buffer;\n}\nfunction sortBySectionOrder(nodes) {\n  nodes.sort(function (a, b) {\n    var sectionA = getSectionForNode(a);\n    var sectionB = getSectionForNode(b);\n    var aId = constants.sections[sectionA];\n    var bId = constants.sections[sectionB];\n    if (typeof aId !== \"number\" || typeof bId !== \"number\") {\n      throw new Error(\"Section id not found\");\n    } // $FlowIgnore ensured above\n\n    return aId > bId;\n  });\n}\nexport function edit(ab, visitors) {\n  ab = preprocess(ab);\n  var ast = decode(ab);\n  return editWithAST(ast, ab, visitors);\n}\nexport function editWithAST(ast, ab, visitors) {\n  var operations = [];\n  var uint8Buffer = new Uint8Array(ab);\n  var nodeBefore;\n  function before(type, path) {\n    nodeBefore = cloneNode(path.node);\n  }\n  function after(type, path) {\n    if (path.node._deleted === true) {\n      operations.push({\n        kind: \"delete\",\n        node: path.node\n      }); // $FlowIgnore\n    } else if (hashNode(nodeBefore) !== hashNode(path.node)) {\n      operations.push({\n        kind: \"update\",\n        oldNode: nodeBefore,\n        node: path.node\n      });\n    }\n  }\n  traverse(ast, visitors, before, after);\n  uint8Buffer = applyOperations(ast, uint8Buffer, operations);\n  return uint8Buffer.buffer;\n}\nexport function add(ab, newNodes) {\n  ab = preprocess(ab);\n  var ast = decode(ab);\n  return addWithAST(ast, ab, newNodes);\n}\nexport function addWithAST(ast, ab, newNodes) {\n  // Sort nodes by insertion order\n  sortBySectionOrder(newNodes);\n  var uint8Buffer = new Uint8Array(ab); // Map node into operations\n\n  var operations = newNodes.map(function (n) {\n    return {\n      kind: \"add\",\n      node: n\n    };\n  });\n  uint8Buffer = applyOperations(ast, uint8Buffer, operations);\n  return uint8Buffer.buffer;\n}","map":null,"metadata":{},"sourceType":"module"}