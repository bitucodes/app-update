{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _uglifyEs = require('uglify-es');\nvar _uglifyEs2 = _interopRequireDefault(_uglifyEs);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar buildUglifyOptions = function buildUglifyOptions() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    ecma = _ref.ecma,\n    warnings = _ref.warnings,\n    _ref$parse = _ref.parse,\n    parse = _ref$parse === undefined ? {} : _ref$parse,\n    _ref$compress = _ref.compress,\n    compress = _ref$compress === undefined ? {} : _ref$compress,\n    mangle = _ref.mangle,\n    output = _ref.output,\n    toplevel = _ref.toplevel,\n    nameCache = _ref.nameCache,\n    ie8 = _ref.ie8,\n    keep_classnames = _ref.keep_classnames,\n    keep_fnames = _ref.keep_fnames,\n    safari10 = _ref.safari10;\n  return {\n    ecma: ecma,\n    warnings: warnings,\n    parse: Object.assign({}, parse),\n    compress: typeof compress === 'boolean' ? compress : Object.assign({}, compress),\n    // eslint-disable-next-line no-nested-ternary\n    mangle: mangle == null ? true : typeof mangle === 'boolean' ? mangle : Object.assign({}, mangle),\n    output: Object.assign({\n      shebang: true,\n      comments: false,\n      beautify: false,\n      semicolons: true\n    }, output),\n    // Ignoring sourceMap from options\n    sourceMap: null,\n    toplevel: toplevel,\n    nameCache: nameCache,\n    ie8: ie8,\n    keep_classnames: keep_classnames,\n    keep_fnames: keep_fnames,\n    safari10: safari10\n  };\n}; /* eslint-disable\n     arrow-body-style\n   */\n\nvar buildComments = function buildComments(options, uglifyOptions, extractedComments) {\n  var condition = {};\n  var commentsOpts = uglifyOptions.output.comments;\n\n  // /^\\**!|@preserve|@license|@cc_on/\n  if (typeof options.extractComments === 'boolean') {\n    condition.preserve = commentsOpts;\n    condition.extract = /^\\**!|@preserve|@license|@cc_on/;\n  } else if (typeof options.extractComments === 'string' || options.extractComments instanceof RegExp) {\n    // extractComments specifies the extract condition and commentsOpts specifies the preserve condition\n    condition.preserve = commentsOpts;\n    condition.extract = options.extractComments;\n  } else if (typeof options.extractComments === 'function') {\n    condition.preserve = false;\n    condition.extract = options.extractComments;\n  } else if (Object.prototype.hasOwnProperty.call(options.extractComments, 'condition')) {\n    // Extract condition is given in extractComments.condition\n    condition.preserve = commentsOpts;\n    condition.extract = options.extractComments.condition;\n  } else {\n    // No extract condition is given. Extract comments that match commentsOpts instead of preserving them\n    condition.preserve = false;\n    condition.extract = commentsOpts;\n  }\n\n  // Ensure that both conditions are functions\n  ['preserve', 'extract'].forEach(function (key) {\n    var regexStr = void 0;\n    var regex = void 0;\n    switch (typeof condition[key]) {\n      case 'boolean':\n        condition[key] = condition[key] ? function () {\n          return true;\n        } : function () {\n          return false;\n        };\n        break;\n      case 'function':\n        break;\n      case 'string':\n        if (condition[key] === 'all') {\n          condition[key] = function () {\n            return true;\n          };\n          break;\n        }\n        if (condition[key] === 'some') {\n          condition[key] = function (astNode, comment) {\n            return comment.type === 'comment2' && /@preserve|@license|@cc_on/i.test(comment.value);\n          };\n          break;\n        }\n        regexStr = condition[key];\n        condition[key] = function (astNode, comment) {\n          return new RegExp(regexStr).test(comment.value);\n        };\n        break;\n      default:\n        regex = condition[key];\n        condition[key] = function (astNode, comment) {\n          return regex.test(comment.value);\n        };\n    }\n  });\n\n  // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n  return function (astNode, comment) {\n    if (condition.extract(astNode, comment)) {\n      extractedComments.push(comment.type === 'comment2' ? \"/*\".concat(comment.value, \"*/\") : \"//\".concat(comment.value));\n    }\n    return condition.preserve(astNode, comment);\n  };\n};\nvar minify = function minify(options) {\n  var file = options.file,\n    input = options.input,\n    inputSourceMap = options.inputSourceMap,\n    extractComments = options.extractComments,\n    minifyFn = options.minify;\n  if (minifyFn) {\n    return minifyFn(_defineProperty({}, file, input), inputSourceMap);\n  }\n\n  // Copy uglify options\n  var uglifyOptions = buildUglifyOptions(options.uglifyOptions);\n\n  // Add source map data\n  if (inputSourceMap) {\n    uglifyOptions.sourceMap = {\n      content: inputSourceMap\n    };\n  }\n  var extractedComments = [];\n  if (extractComments) {\n    uglifyOptions.output.comments = buildComments(options, uglifyOptions, extractedComments);\n  }\n  var _uglify$minify = _uglifyEs2.default.minify(_defineProperty({}, file, input), uglifyOptions),\n    error = _uglify$minify.error,\n    map = _uglify$minify.map,\n    code = _uglify$minify.code,\n    warnings = _uglify$minify.warnings;\n  return {\n    error: error,\n    map: map,\n    code: code,\n    warnings: warnings,\n    extractedComments: extractedComments\n  };\n};\nexports.default = minify;","map":null,"metadata":{},"sourceType":"script"}