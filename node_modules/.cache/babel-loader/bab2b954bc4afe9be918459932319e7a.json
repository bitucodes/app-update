{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _get = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar NativeModule = require(\"module\");\nvar _require = require(\"webpack-sources\"),\n  CachedSource = _require.CachedSource,\n  LineToLineMappedSource = _require.LineToLineMappedSource,\n  OriginalSource = _require.OriginalSource,\n  RawSource = _require.RawSource,\n  SourceMapSource = _require.SourceMapSource;\nvar _require2 = require(\"loader-runner\"),\n  getContext = _require2.getContext,\n  runLoaders = _require2.runLoaders;\nvar WebpackError = require(\"./WebpackError\");\nvar Module = require(\"./Module\");\nvar ModuleParseError = require(\"./ModuleParseError\");\nvar ModuleBuildError = require(\"./ModuleBuildError\");\nvar ModuleError = require(\"./ModuleError\");\nvar ModuleWarning = require(\"./ModuleWarning\");\nvar createHash = require(\"./util/createHash\");\nvar contextify = require(\"./util/identifier\").contextify;\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\nvar asString = function asString(buf) {\n  if (Buffer.isBuffer(buf)) {\n    return buf.toString(\"utf-8\");\n  }\n  return buf;\n};\nvar asBuffer = function asBuffer(str) {\n  if (!Buffer.isBuffer(str)) {\n    return Buffer.from(str, \"utf-8\");\n  }\n  return str;\n};\nvar NonErrorEmittedError = /*#__PURE__*/function (_WebpackError) {\n  _inherits(NonErrorEmittedError, _WebpackError);\n  function NonErrorEmittedError(error) {\n    var _this;\n    _classCallCheck(this, NonErrorEmittedError);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NonErrorEmittedError).call(this));\n    _this.name = \"NonErrorEmittedError\";\n    _this.message = \"(Emitted value instead of an instance of Error) \" + error;\n    Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    return _this;\n  }\n  return NonErrorEmittedError;\n}(WebpackError);\n/**\n * @typedef {Object} CachedSourceEntry\n * @property {TODO} source the generated source\n * @property {string} hash the hash value\n */\nvar NormalModule = /*#__PURE__*/function (_Module) {\n  _inherits(NormalModule, _Module);\n  function NormalModule(_ref) {\n    var _this2;\n    var type = _ref.type,\n      request = _ref.request,\n      userRequest = _ref.userRequest,\n      rawRequest = _ref.rawRequest,\n      loaders = _ref.loaders,\n      resource = _ref.resource,\n      matchResource = _ref.matchResource,\n      parser = _ref.parser,\n      generator = _ref.generator,\n      resolveOptions = _ref.resolveOptions;\n    _classCallCheck(this, NormalModule);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(NormalModule).call(this, type, getContext(resource)));\n\n    // Info from Factory\n    _this2.request = request;\n    _this2.userRequest = userRequest;\n    _this2.rawRequest = rawRequest;\n    _this2.binary = type.startsWith(\"webassembly\");\n    _this2.parser = parser;\n    _this2.generator = generator;\n    _this2.resource = resource;\n    _this2.matchResource = matchResource;\n    _this2.loaders = loaders;\n    if (resolveOptions !== undefined) _this2.resolveOptions = resolveOptions;\n\n    // Info from Build\n    _this2.error = null;\n    _this2._source = null;\n    _this2._buildHash = \"\";\n    _this2.buildTimestamp = undefined;\n    /** @private @type {Map<string, CachedSourceEntry>} */\n    _this2._cachedSources = new Map();\n\n    // Options for the NormalModule set by plugins\n    // TODO refactor this -> options object filled from Factory\n    _this2.useSourceMap = false;\n    _this2.lineToLine = false;\n\n    // Cache\n    _this2._lastSuccessfulBuildMeta = {};\n    return _this2;\n  }\n  _createClass(NormalModule, [{\n    key: \"identifier\",\n    value: function identifier() {\n      return this.request;\n    }\n  }, {\n    key: \"readableIdentifier\",\n    value: function readableIdentifier(requestShortener) {\n      return requestShortener.shorten(this.userRequest);\n    }\n  }, {\n    key: \"libIdent\",\n    value: function libIdent(options) {\n      return contextify(options.context, this.userRequest);\n    }\n  }, {\n    key: \"nameForCondition\",\n    value: function nameForCondition() {\n      var resource = this.matchResource || this.resource;\n      var idx = resource.indexOf(\"?\");\n      if (idx >= 0) return resource.substr(0, idx);\n      return resource;\n    }\n  }, {\n    key: \"updateCacheModule\",\n    value: function updateCacheModule(module) {\n      this.type = module.type;\n      this.request = module.request;\n      this.userRequest = module.userRequest;\n      this.rawRequest = module.rawRequest;\n      this.parser = module.parser;\n      this.generator = module.generator;\n      this.resource = module.resource;\n      this.matchResource = module.matchResource;\n      this.loaders = module.loaders;\n      this.resolveOptions = module.resolveOptions;\n    }\n  }, {\n    key: \"createSourceForAsset\",\n    value: function createSourceForAsset(name, content, sourceMap) {\n      if (!sourceMap) {\n        return new RawSource(content);\n      }\n      if (typeof sourceMap === \"string\") {\n        return new OriginalSource(content, sourceMap);\n      }\n      return new SourceMapSource(content, name, sourceMap);\n    }\n  }, {\n    key: \"createLoaderContext\",\n    value: function createLoaderContext(resolver, options, compilation, fs) {\n      var _this3 = this;\n      var requestShortener = compilation.runtimeTemplate.requestShortener;\n      var loaderContext = {\n        version: 2,\n        emitWarning: function emitWarning(warning) {\n          if (!(warning instanceof Error)) {\n            warning = new NonErrorEmittedError(warning);\n          }\n          var currentLoader = _this3.getCurrentLoader(loaderContext);\n          _this3.warnings.push(new ModuleWarning(_this3, warning, {\n            from: requestShortener.shorten(currentLoader.loader)\n          }));\n        },\n        emitError: function emitError(error) {\n          if (!(error instanceof Error)) {\n            error = new NonErrorEmittedError(error);\n          }\n          var currentLoader = _this3.getCurrentLoader(loaderContext);\n          _this3.errors.push(new ModuleError(_this3, error, {\n            from: requestShortener.shorten(currentLoader.loader)\n          }));\n        },\n        // TODO remove in webpack 5\n        exec: function exec(code, filename) {\n          // @ts-ignore Argument of type 'this' is not assignable to parameter of type 'Module'.\n          var module = new NativeModule(filename, _this3);\n          // @ts-ignore _nodeModulePaths is deprecated and undocumented Node.js API\n          module.paths = NativeModule._nodeModulePaths(_this3.context);\n          module.filename = filename;\n          module._compile(code, filename);\n          return module.exports;\n        },\n        resolve: function resolve(context, request, callback) {\n          resolver.resolve({}, context, request, {}, callback);\n        },\n        emitFile: function emitFile(name, content, sourceMap) {\n          if (!_this3.buildInfo.assets) {\n            _this3.buildInfo.assets = Object.create(null);\n          }\n          _this3.buildInfo.assets[name] = _this3.createSourceForAsset(name, content, sourceMap);\n        },\n        rootContext: options.context,\n        webpack: true,\n        sourceMap: !!this.useSourceMap,\n        _module: this,\n        _compilation: compilation,\n        _compiler: compilation.compiler,\n        fs: fs\n      };\n      compilation.hooks.normalModuleLoader.call(loaderContext, this);\n      if (options.loader) {\n        Object.assign(loaderContext, options.loader);\n      }\n      return loaderContext;\n    }\n  }, {\n    key: \"getCurrentLoader\",\n    value: function getCurrentLoader(loaderContext) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : loaderContext.loaderIndex;\n      if (this.loaders && this.loaders.length && index < this.loaders.length && index >= 0 && this.loaders[index]) {\n        return this.loaders[index];\n      }\n      return null;\n    }\n  }, {\n    key: \"createSource\",\n    value: function createSource(source, resourceBuffer, sourceMap) {\n      // if there is no identifier return raw source\n      if (!this.identifier) {\n        return new RawSource(source);\n      }\n\n      // from here on we assume we have an identifier\n      var identifier = this.identifier();\n      if (this.lineToLine && resourceBuffer) {\n        return new LineToLineMappedSource(source, identifier, asString(resourceBuffer));\n      }\n      if (this.useSourceMap && sourceMap) {\n        return new SourceMapSource(source, identifier, sourceMap);\n      }\n      if (Buffer.isBuffer(source)) {\n        // @ts-ignore\n        // TODO We need to fix @types/webpack-sources to allow RawSource to take a Buffer | string\n        return new RawSource(source);\n      }\n      return new OriginalSource(source, identifier);\n    }\n  }, {\n    key: \"doBuild\",\n    value: function doBuild(options, compilation, resolver, fs, callback) {\n      var _this4 = this;\n      var loaderContext = this.createLoaderContext(resolver, options, compilation, fs);\n      runLoaders({\n        resource: this.resource,\n        loaders: this.loaders,\n        context: loaderContext,\n        readResource: fs.readFile.bind(fs)\n      }, function (err, result) {\n        if (result) {\n          _this4.buildInfo.cacheable = result.cacheable;\n          _this4.buildInfo.fileDependencies = new Set(result.fileDependencies);\n          _this4.buildInfo.contextDependencies = new Set(result.contextDependencies);\n        }\n        if (err) {\n          if (!(err instanceof Error)) {\n            err = new NonErrorEmittedError(err);\n          }\n          var currentLoader = _this4.getCurrentLoader(loaderContext);\n          var error = new ModuleBuildError(_this4, err, {\n            from: currentLoader && compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader)\n          });\n          return callback(error);\n        }\n        var resourceBuffer = result.resourceBuffer;\n        var source = result.result[0];\n        var sourceMap = result.result.length >= 1 ? result.result[1] : null;\n        var extraInfo = result.result.length >= 2 ? result.result[2] : null;\n        if (!Buffer.isBuffer(source) && typeof source !== \"string\") {\n          var _currentLoader = _this4.getCurrentLoader(loaderContext, 0);\n          var _err = new Error(\"Final loader (\".concat(_currentLoader ? compilation.runtimeTemplate.requestShortener.shorten(_currentLoader.loader) : \"unknown\", \") didn't return a Buffer or String\"));\n          var _error = new ModuleBuildError(_this4, _err);\n          return callback(_error);\n        }\n        _this4._source = _this4.createSource(_this4.binary ? asBuffer(source) : asString(source), resourceBuffer, sourceMap);\n        _this4._ast = typeof extraInfo === \"object\" && extraInfo !== null && extraInfo.webpackAST !== undefined ? extraInfo.webpackAST : null;\n        return callback();\n      });\n    }\n  }, {\n    key: \"markModuleAsErrored\",\n    value: function markModuleAsErrored(error) {\n      // Restore build meta from successful build to keep importing state\n      this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta);\n      this.error = error;\n      this.errors.push(this.error);\n      this._source = new RawSource(\"throw new Error(\" + JSON.stringify(this.error.message) + \");\");\n      this._ast = null;\n    }\n  }, {\n    key: \"applyNoParseRule\",\n    value: function applyNoParseRule(rule, content) {\n      // must start with \"rule\" if rule is a string\n      if (typeof rule === \"string\") {\n        return content.indexOf(rule) === 0;\n      }\n      if (typeof rule === \"function\") {\n        return rule(content);\n      }\n      // we assume rule is a regexp\n      return rule.test(content);\n    } // check if module should not be parsed\n    // returns \"true\" if the module should !not! be parsed\n    // returns \"false\" if the module !must! be parsed\n  }, {\n    key: \"shouldPreventParsing\",\n    value: function shouldPreventParsing(noParseRule, request) {\n      // if no noParseRule exists, return false\n      // the module !must! be parsed.\n      if (!noParseRule) {\n        return false;\n      }\n\n      // we only have one rule to check\n      if (!Array.isArray(noParseRule)) {\n        // returns \"true\" if the module is !not! to be parsed\n        return this.applyNoParseRule(noParseRule, request);\n      }\n      for (var i = 0; i < noParseRule.length; i++) {\n        var rule = noParseRule[i];\n        // early exit on first truthy match\n        // this module is !not! to be parsed\n        if (this.applyNoParseRule(rule, request)) {\n          return true;\n        }\n      }\n      // no match found, so this module !should! be parsed\n      return false;\n    }\n  }, {\n    key: \"_initBuildHash\",\n    value: function _initBuildHash(compilation) {\n      var hash = createHash(compilation.outputOptions.hashFunction);\n      if (this._source) {\n        hash.update(\"source\");\n        this._source.updateHash(hash);\n      }\n      hash.update(\"meta\");\n      hash.update(JSON.stringify(this.buildMeta));\n      this._buildHash = hash.digest(\"hex\");\n    }\n  }, {\n    key: \"build\",\n    value: function build(options, compilation, resolver, fs, callback) {\n      var _this5 = this;\n      this.buildTimestamp = Date.now();\n      this.built = true;\n      this._source = null;\n      this._ast = null;\n      this._buildHash = \"\";\n      this.error = null;\n      this.errors.length = 0;\n      this.warnings.length = 0;\n      this.buildMeta = {};\n      this.buildInfo = {\n        cacheable: false,\n        fileDependencies: new Set(),\n        contextDependencies: new Set()\n      };\n      return this.doBuild(options, compilation, resolver, fs, function (err) {\n        _this5._cachedSources.clear();\n\n        // if we have an error mark module as failed and exit\n        if (err) {\n          _this5.markModuleAsErrored(err);\n          _this5._initBuildHash(compilation);\n          return callback();\n        }\n\n        // check if this module should !not! be parsed.\n        // if so, exit here;\n        var noParseRule = options.module && options.module.noParse;\n        if (_this5.shouldPreventParsing(noParseRule, _this5.request)) {\n          _this5._initBuildHash(compilation);\n          return callback();\n        }\n        var handleParseError = function handleParseError(e) {\n          var source = _this5._source.source();\n          var error = new ModuleParseError(_this5, source, e);\n          _this5.markModuleAsErrored(error);\n          _this5._initBuildHash(compilation);\n          return callback();\n        };\n        var handleParseResult = function handleParseResult(result) {\n          _this5._lastSuccessfulBuildMeta = _this5.buildMeta;\n          _this5._initBuildHash(compilation);\n          return callback();\n        };\n        try {\n          var result = _this5.parser.parse(_this5._ast || _this5._source.source(), {\n            current: _this5,\n            module: _this5,\n            compilation: compilation,\n            options: options\n          }, function (err, result) {\n            if (err) {\n              handleParseError(err);\n            } else {\n              handleParseResult(result);\n            }\n          });\n          if (result !== undefined) {\n            // parse is sync\n            handleParseResult(result);\n          }\n        } catch (e) {\n          handleParseError(e);\n        }\n      });\n    }\n  }, {\n    key: \"getHashDigest\",\n    value: function getHashDigest(dependencyTemplates) {\n      // TODO webpack 5 refactor\n      var dtHash = dependencyTemplates.get(\"hash\");\n      return \"\".concat(this.hash, \"-\").concat(dtHash);\n    }\n  }, {\n    key: \"source\",\n    value: function source(dependencyTemplates, runtimeTemplate) {\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"javascript\";\n      var hashDigest = this.getHashDigest(dependencyTemplates);\n      var cacheEntry = this._cachedSources.get(type);\n      if (cacheEntry !== undefined && cacheEntry.hash === hashDigest) {\n        // We can reuse the cached source\n        return cacheEntry.source;\n      }\n      var source = this.generator.generate(this, dependencyTemplates, runtimeTemplate, type);\n      var cachedSource = new CachedSource(source);\n      this._cachedSources.set(type, {\n        source: cachedSource,\n        hash: hashDigest\n      });\n      return cachedSource;\n    }\n  }, {\n    key: \"originalSource\",\n    value: function originalSource() {\n      return this._source;\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      // always try to rebuild in case of an error\n      if (this.error) return true;\n\n      // always rebuild when module is not cacheable\n      if (!this.buildInfo.cacheable) return true;\n\n      // Check timestamps of all dependencies\n      // Missing timestamp -> need rebuild\n      // Timestamp bigger than buildTimestamp -> need rebuild\n      var _iterator = _createForOfIteratorHelper(this.buildInfo.fileDependencies),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var file = _step.value;\n          var timestamp = fileTimestamps.get(file);\n          if (!timestamp) return true;\n          if (timestamp >= this.buildTimestamp) return true;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.buildInfo.contextDependencies),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _file = _step2.value;\n          var _timestamp = contextTimestamps.get(_file);\n          if (!_timestamp) return true;\n          if (_timestamp >= this.buildTimestamp) return true;\n        }\n        // elsewise -> no rebuild needed\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this._source ? this._source.size() : -1;\n    }\n    /**\n     * @param {Hash} hash the hash used to track dependencies\n     * @returns {void}\n     */\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(this._buildHash);\n      _get(_getPrototypeOf(NormalModule.prototype), \"updateHash\", this).call(this, hash);\n    }\n  }]);\n  return NormalModule;\n}(Module);\nmodule.exports = NormalModule;","map":null,"metadata":{},"sourceType":"script"}