{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar parseJson = require(\"json-parse-better-errors\");\nvar asyncLib = require(\"neo-async\");\nvar path = require(\"path\");\nvar util = require(\"util\");\nvar _require = require(\"tapable\"),\n  Tapable = _require.Tapable,\n  SyncHook = _require.SyncHook,\n  SyncBailHook = _require.SyncBailHook,\n  AsyncParallelHook = _require.AsyncParallelHook,\n  AsyncSeriesHook = _require.AsyncSeriesHook;\nvar Compilation = require(\"./Compilation\");\nvar Stats = require(\"./Stats\");\nvar Watching = require(\"./Watching\");\nvar NormalModuleFactory = require(\"./NormalModuleFactory\");\nvar ContextModuleFactory = require(\"./ContextModuleFactory\");\nvar ResolverFactory = require(\"./ResolverFactory\");\nvar RequestShortener = require(\"./RequestShortener\");\nvar _require2 = require(\"./util/identifier\"),\n  makePathsRelative = _require2.makePathsRelative;\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n * @property {Set<string>} compilationDependencies\n */\n\n/** @typedef {string|string[]} EntryValues */\n/** @typedef {Record<string, EntryValues>} EntryOptionValues */\n\n/**\n * @callback EntryOptionValuesFunction\n * @returns {EntryOptionValues | EntryValues} the computed value\n */\n\n/** @typedef {EntryOptionValuesFunction | EntryOptionValues | EntryValues} EntryOptions */\nvar Compiler = /*#__PURE__*/function (_Tapable) {\n  _inherits(Compiler, _Tapable);\n  function Compiler(context) {\n    var _this;\n    _classCallCheck(this, Compiler);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Compiler).call(this));\n    _this.hooks = {\n      /** @type {SyncBailHook<Compilation>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<Stats>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n      /** @type {AsyncSeriesHook<>} */\n      additionalPass: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<Compiler>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {AsyncSeriesHook<Compiler>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {AsyncSeriesHook<Compilation>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n      /** @type {SyncHook<NormalModuleFactory>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n      /** @type {SyncHook<ContextModuleFactory>}  */\n      contextModuleFactory: new SyncHook([\"contextModulefactory\"]),\n      /** @type {AsyncSeriesHook<CompilationParams>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n      /** @type {SyncHook<CompilationParams>} */\n      compile: new SyncHook([\"params\"]),\n      /** @type {AsyncParallelHook<Compilation>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<Compiler>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {SyncHook<Error>} */\n      failed: new SyncHook([\"error\"]),\n      /** @type {SyncHook<string, string>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n      /** @type {SyncHook} */\n      watchClose: new SyncHook([]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n      /** @type {SyncHook} */\n      environment: new SyncHook([]),\n      /** @type {SyncHook} */\n      afterEnvironment: new SyncHook([]),\n      /** @type {SyncHook<Compiler>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n      /** @type {SyncHook<Compiler>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n      /** @type {SyncBailHook<string, EntryOptions>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    };\n    _this._pluginCompat.tap(\"Compiler\", function (options) {\n      switch (options.name) {\n        case \"additional-pass\":\n        case \"before-run\":\n        case \"run\":\n        case \"emit\":\n        case \"after-emit\":\n        case \"before-compile\":\n        case \"make\":\n        case \"after-compile\":\n        case \"watch-run\":\n          options.async = true;\n          break;\n      }\n    });\n\n    /** @type {string=} */\n    _this.name = undefined;\n    /** @type {Compilation=} */\n    _this.parentCompilation = undefined;\n    /** @type {string} */\n    _this.outputPath = \"\";\n    _this.outputFileSystem = null;\n    _this.inputFileSystem = null;\n\n    /** @type {string|null} */\n    _this.recordsInputPath = null;\n    /** @type {string|null} */\n    _this.recordsOutputPath = null;\n    _this.records = {};\n    /** @type {Map<string, number>} */\n    _this.fileTimestamps = new Map();\n    /** @type {Map<string, number>} */\n    _this.contextTimestamps = new Map();\n    /** @type {ResolverFactory} */\n    _this.resolverFactory = new ResolverFactory();\n\n    // TODO remove in webpack 5\n    _this.resolvers = {\n      normal: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver normal\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          _this.resolverFactory.plugin(\"resolver normal\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      loader: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver loader\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n          _this.resolverFactory.plugin(\"resolver loader\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      context: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver context\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n          _this.resolverFactory.plugin(\"resolver context\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      }\n    };\n    _this.options = {};\n    _this.context = context;\n    _this.requestShortener = new RequestShortener(context);\n\n    /** @type {boolean} */\n    _this.running = false;\n    return _this;\n  }\n  _createClass(Compiler, [{\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      if (this.running) return handler(new ConcurrentCompilationError());\n      this.running = true;\n      this.fileTimestamps = new Map();\n      this.contextTimestamps = new Map();\n      return new Watching(this, watchOptions, handler);\n    }\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this2 = this;\n      if (this.running) return callback(new ConcurrentCompilationError());\n      var finalCallback = function finalCallback(err, stats) {\n        _this2.running = false;\n        if (callback !== undefined) return callback(err, stats);\n      };\n      var startTime = Date.now();\n      this.running = true;\n      var onCompiled = function onCompiled(err, compilation) {\n        if (err) return finalCallback(err);\n        if (_this2.hooks.shouldEmit.call(compilation) === false) {\n          var stats = new Stats(compilation);\n          stats.startTime = startTime;\n          stats.endTime = Date.now();\n          _this2.hooks.done.callAsync(stats, function (err) {\n            if (err) return finalCallback(err);\n            return finalCallback(null, stats);\n          });\n          return;\n        }\n        _this2.emitAssets(compilation, function (err) {\n          if (err) return finalCallback(err);\n          if (compilation.hooks.needAdditionalPass.call()) {\n            compilation.needAdditionalPass = true;\n            var _stats = new Stats(compilation);\n            _stats.startTime = startTime;\n            _stats.endTime = Date.now();\n            _this2.hooks.done.callAsync(_stats, function (err) {\n              if (err) return finalCallback(err);\n              _this2.hooks.additionalPass.callAsync(function (err) {\n                if (err) return finalCallback(err);\n                _this2.compile(onCompiled);\n              });\n            });\n            return;\n          }\n          _this2.emitRecords(function (err) {\n            if (err) return finalCallback(err);\n            var stats = new Stats(compilation);\n            stats.startTime = startTime;\n            stats.endTime = Date.now();\n            _this2.hooks.done.callAsync(stats, function (err) {\n              if (err) return finalCallback(err);\n              return finalCallback(null, stats);\n            });\n          });\n        });\n      };\n      this.hooks.beforeRun.callAsync(this, function (err) {\n        if (err) return finalCallback(err);\n        _this2.hooks.run.callAsync(_this2, function (err) {\n          if (err) return finalCallback(err);\n          _this2.readRecords(function (err) {\n            if (err) return finalCallback(err);\n            _this2.compile(onCompiled);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"runAsChild\",\n    value: function runAsChild(callback) {\n      var _this3 = this;\n      this.compile(function (err, compilation) {\n        if (err) return callback(err);\n        _this3.parentCompilation.children.push(compilation);\n        for (var _i = 0, _Object$keys = Object.keys(compilation.assets); _i < _Object$keys.length; _i++) {\n          var name = _Object$keys[_i];\n          _this3.parentCompilation.assets[name] = compilation.assets[name];\n        }\n        var entries = Array.from(compilation.entrypoints.values(), function (ep) {\n          return ep.chunks;\n        }).reduce(function (array, chunks) {\n          return array.concat(chunks);\n        }, []);\n        return callback(null, entries, compilation);\n      });\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      if (this.inputFileSystem && this.inputFileSystem.purge) {\n        this.inputFileSystem.purge();\n      }\n    }\n  }, {\n    key: \"emitAssets\",\n    value: function emitAssets(compilation, callback) {\n      var _this4 = this;\n      var outputPath;\n      var emitFiles = function emitFiles(err) {\n        if (err) return callback(err);\n        asyncLib.forEach(compilation.assets, function (source, file, callback) {\n          var targetFile = file;\n          var queryStringIdx = targetFile.indexOf(\"?\");\n          if (queryStringIdx >= 0) {\n            targetFile = targetFile.substr(0, queryStringIdx);\n          }\n          var writeOut = function writeOut(err) {\n            if (err) return callback(err);\n            var targetPath = _this4.outputFileSystem.join(outputPath, targetFile);\n            if (source.existsAt === targetPath) {\n              source.emitted = false;\n              return callback();\n            }\n            var content = source.source();\n            if (!Buffer.isBuffer(content)) {\n              content = Buffer.from(content, \"utf8\");\n            }\n            source.existsAt = targetPath;\n            source.emitted = true;\n            _this4.outputFileSystem.writeFile(targetPath, content, callback);\n          };\n          if (targetFile.match(/\\/|\\\\/)) {\n            var dir = path.dirname(targetFile);\n            _this4.outputFileSystem.mkdirp(_this4.outputFileSystem.join(outputPath, dir), writeOut);\n          } else {\n            writeOut();\n          }\n        }, function (err) {\n          if (err) return callback(err);\n          _this4.hooks.afterEmit.callAsync(compilation, function (err) {\n            if (err) return callback(err);\n            return callback();\n          });\n        });\n      };\n      this.hooks.emit.callAsync(compilation, function (err) {\n        if (err) return callback(err);\n        outputPath = compilation.getPath(_this4.outputPath);\n        _this4.outputFileSystem.mkdirp(outputPath, emitFiles);\n      });\n    }\n  }, {\n    key: \"emitRecords\",\n    value: function emitRecords(callback) {\n      var _this5 = this;\n      if (!this.recordsOutputPath) return callback();\n      var idx1 = this.recordsOutputPath.lastIndexOf(\"/\");\n      var idx2 = this.recordsOutputPath.lastIndexOf(\"\\\\\");\n      var recordsOutputPathDirectory = null;\n      if (idx1 > idx2) {\n        recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);\n      } else if (idx1 < idx2) {\n        recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);\n      }\n      var writeFile = function writeFile() {\n        _this5.outputFileSystem.writeFile(_this5.recordsOutputPath, JSON.stringify(_this5.records, undefined, 2), callback);\n      };\n      if (!recordsOutputPathDirectory) {\n        return writeFile();\n      }\n      this.outputFileSystem.mkdirp(recordsOutputPathDirectory, function (err) {\n        if (err) return callback(err);\n        writeFile();\n      });\n    }\n  }, {\n    key: \"readRecords\",\n    value: function readRecords(callback) {\n      var _this6 = this;\n      if (!this.recordsInputPath) {\n        this.records = {};\n        return callback();\n      }\n      this.inputFileSystem.stat(this.recordsInputPath, function (err) {\n        // It doesn't exist\n        // We can ignore this.\n        if (err) return callback();\n        _this6.inputFileSystem.readFile(_this6.recordsInputPath, function (err, content) {\n          if (err) return callback(err);\n          try {\n            _this6.records = parseJson(content.toString(\"utf-8\"));\n          } catch (e) {\n            e.message = \"Cannot parse records: \" + e.message;\n            return callback(e);\n          }\n          return callback();\n        });\n      });\n    }\n  }, {\n    key: \"createChildCompiler\",\n    value: function createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n      var childCompiler = new Compiler(this.context);\n      if (Array.isArray(plugins)) {\n        var _iterator = _createForOfIteratorHelper(plugins),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var plugin = _step.value;\n            plugin.apply(childCompiler);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      for (var name in this.hooks) {\n        if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name)) {\n          if (childCompiler.hooks[name]) {\n            childCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n          }\n        }\n      }\n      childCompiler.name = compilerName;\n      childCompiler.outputPath = this.outputPath;\n      childCompiler.inputFileSystem = this.inputFileSystem;\n      childCompiler.outputFileSystem = null;\n      childCompiler.resolverFactory = this.resolverFactory;\n      childCompiler.fileTimestamps = this.fileTimestamps;\n      childCompiler.contextTimestamps = this.contextTimestamps;\n      var relativeCompilerName = makePathsRelative(this.context, compilerName);\n      if (!this.records[relativeCompilerName]) {\n        this.records[relativeCompilerName] = [];\n      }\n      if (this.records[relativeCompilerName][compilerIndex]) {\n        childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n      } else {\n        this.records[relativeCompilerName].push(childCompiler.records = {});\n      }\n      childCompiler.options = Object.create(this.options);\n      childCompiler.options.output = Object.create(childCompiler.options.output);\n      for (var _name in outputOptions) {\n        childCompiler.options.output[_name] = outputOptions[_name];\n      }\n      childCompiler.parentCompilation = compilation;\n      compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n      return childCompiler;\n    }\n  }, {\n    key: \"isChild\",\n    value: function isChild() {\n      return !!this.parentCompilation;\n    }\n  }, {\n    key: \"createCompilation\",\n    value: function createCompilation() {\n      return new Compilation(this);\n    }\n  }, {\n    key: \"newCompilation\",\n    value: function newCompilation(params) {\n      var compilation = this.createCompilation();\n      compilation.fileTimestamps = this.fileTimestamps;\n      compilation.contextTimestamps = this.contextTimestamps;\n      compilation.name = this.name;\n      compilation.records = this.records;\n      compilation.compilationDependencies = params.compilationDependencies;\n      this.hooks.thisCompilation.call(compilation, params);\n      this.hooks.compilation.call(compilation, params);\n      return compilation;\n    }\n  }, {\n    key: \"createNormalModuleFactory\",\n    value: function createNormalModuleFactory() {\n      var normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolverFactory, this.options.module || {});\n      this.hooks.normalModuleFactory.call(normalModuleFactory);\n      return normalModuleFactory;\n    }\n  }, {\n    key: \"createContextModuleFactory\",\n    value: function createContextModuleFactory() {\n      var contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n      this.hooks.contextModuleFactory.call(contextModuleFactory);\n      return contextModuleFactory;\n    }\n  }, {\n    key: \"newCompilationParams\",\n    value: function newCompilationParams() {\n      var params = {\n        normalModuleFactory: this.createNormalModuleFactory(),\n        contextModuleFactory: this.createContextModuleFactory(),\n        compilationDependencies: new Set()\n      };\n      return params;\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(callback) {\n      var _this7 = this;\n      var params = this.newCompilationParams();\n      this.hooks.beforeCompile.callAsync(params, function (err) {\n        if (err) return callback(err);\n        _this7.hooks.compile.call(params);\n        var compilation = _this7.newCompilation(params);\n        _this7.hooks.make.callAsync(compilation, function (err) {\n          if (err) return callback(err);\n          compilation.finish();\n          compilation.seal(function (err) {\n            if (err) return callback(err);\n            _this7.hooks.afterCompile.callAsync(compilation, function (err) {\n              if (err) return callback(err);\n              return callback(null, compilation);\n            });\n          });\n        });\n      });\n    }\n  }]);\n  return Compiler;\n}(Tapable);\nmodule.exports = Compiler;","map":null,"metadata":{},"sourceType":"script"}