{"ast":null,"code":"'use strict';\n\nvar BB = require('bluebird');\nvar fs = require('fs');\nvar index = require('./lib/entry-index');\nvar memo = require('./lib/memoization');\nvar pipe = require('mississippi').pipe;\nvar pipeline = require('mississippi').pipeline;\nvar read = require('./lib/content/read');\nvar through = require('mississippi').through;\nmodule.exports = function get(cache, key, opts) {\n  return getData(false, cache, key, opts);\n};\nmodule.exports.byDigest = function getByDigest(cache, digest, opts) {\n  return getData(true, cache, digest, opts);\n};\nfunction getData(byDigest, cache, key, opts) {\n  opts = opts || {};\n  var memoized = byDigest ? memo.get.byDigest(cache, key, opts) : memo.get(cache, key, opts);\n  if (memoized && opts.memoize !== false) {\n    return BB.resolve(byDigest ? memoized : {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    });\n  }\n  return (byDigest ? BB.resolve(null) : index.find(cache, key, opts)).then(function (entry) {\n    if (!entry && !byDigest) {\n      throw new index.NotFoundError(cache, key);\n    }\n    return read(cache, byDigest ? key : entry.integrity, {\n      integrity: opts.integrity,\n      size: opts.size\n    }).then(function (data) {\n      return byDigest ? data : {\n        metadata: entry.metadata,\n        data: data,\n        size: entry.size,\n        integrity: entry.integrity\n      };\n    }).then(function (res) {\n      if (opts.memoize && byDigest) {\n        memo.put.byDigest(cache, key, res, opts);\n      } else if (opts.memoize) {\n        memo.put(cache, entry, res.data, opts);\n      }\n      return res;\n    });\n  });\n}\nmodule.exports.stream = getStream;\nfunction getStream(cache, key, opts) {\n  opts = opts || {};\n  var stream = through();\n  var memoized = memo.get(cache, key, opts);\n  if (memoized && opts.memoize !== false) {\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(memoized.entry.metadata);\n      ev === 'integrity' && cb(memoized.entry.integrity);\n      ev === 'size' && cb(memoized.entry.size);\n    });\n    stream.write(memoized.data, function () {\n      return stream.end();\n    });\n    return stream;\n  }\n  index.find(cache, key).then(function (entry) {\n    if (!entry) {\n      return stream.emit('error', new index.NotFoundError(cache, key));\n    }\n    var memoStream;\n    if (opts.memoize) {\n      var memoData = [];\n      var memoLength = 0;\n      memoStream = through(function (c, en, cb) {\n        memoData && memoData.push(c);\n        memoLength += c.length;\n        cb(null, c, en);\n      }, function (cb) {\n        memoData && memo.put(cache, entry, Buffer.concat(memoData, memoLength), opts);\n        cb();\n      });\n    } else {\n      memoStream = through();\n    }\n    opts.size = opts.size == null ? entry.size : opts.size;\n    stream.emit('metadata', entry.metadata);\n    stream.emit('integrity', entry.integrity);\n    stream.emit('size', entry.size);\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(entry.metadata);\n      ev === 'integrity' && cb(entry.integrity);\n      ev === 'size' && cb(entry.size);\n    });\n    pipe(read.readStream(cache, entry.integrity, opts), memoStream, stream);\n  }, function (err) {\n    return stream.emit('error', err);\n  });\n  return stream;\n}\nmodule.exports.stream.byDigest = getStreamDigest;\nfunction getStreamDigest(cache, integrity, opts) {\n  opts = opts || {};\n  var memoized = memo.get.byDigest(cache, integrity, opts);\n  if (memoized && opts.memoize !== false) {\n    var stream = through();\n    stream.write(memoized, function () {\n      return stream.end();\n    });\n    return stream;\n  } else {\n    var _stream = read.readStream(cache, integrity, opts);\n    if (opts.memoize) {\n      var memoData = [];\n      var memoLength = 0;\n      var memoStream = through(function (c, en, cb) {\n        memoData && memoData.push(c);\n        memoLength += c.length;\n        cb(null, c, en);\n      }, function (cb) {\n        memoData && memo.put.byDigest(cache, integrity, Buffer.concat(memoData, memoLength), opts);\n        cb();\n      });\n      _stream = pipeline(_stream, memoStream);\n    }\n    return _stream;\n  }\n}\nmodule.exports.info = info;\nfunction info(cache, key, opts) {\n  opts = opts || {};\n  var memoized = memo.get(cache, key, opts);\n  if (memoized && opts.memoize !== false) {\n    return BB.resolve(memoized.entry);\n  } else {\n    return index.find(cache, key);\n  }\n}\nmodule.exports.hasContent = read.hasContent;\nmodule.exports.copy = function cp(cache, key, dest, opts) {\n  return copy(false, cache, key, dest, opts);\n};\nmodule.exports.copy.byDigest = function cpDigest(cache, digest, dest, opts) {\n  return copy(true, cache, digest, dest, opts);\n};\nfunction copy(byDigest, cache, key, dest, opts) {\n  opts = opts || {};\n  if (read.copy) {\n    return (byDigest ? BB.resolve(null) : index.find(cache, key, opts)).then(function (entry) {\n      if (!entry && !byDigest) {\n        throw new index.NotFoundError(cache, key);\n      }\n      return read.copy(cache, byDigest ? key : entry.integrity, dest, opts).then(function () {\n        return byDigest ? key : {\n          metadata: entry.metadata,\n          size: entry.size,\n          integrity: entry.integrity\n        };\n      });\n    });\n  } else {\n    return getData(byDigest, cache, key, opts).then(function (res) {\n      return fs.writeFileAsync(dest, byDigest ? res : res.data).then(function () {\n        return byDigest ? key : {\n          metadata: res.metadata,\n          size: res.size,\n          integrity: res.integrity\n        };\n      });\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}