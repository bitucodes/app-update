{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/*global $hash$ $requestTimeout$ installedModules $require$ hotDownloadManifest hotDownloadUpdateChunk hotDisposeChunk modules */\nmodule.exports = function () {\n  var hotApplyOnUpdate = true;\n  // eslint-disable-next-line no-unused-vars\n  var hotCurrentHash = $hash$;\n  var hotRequestTimeout = $requestTimeout$;\n  var hotCurrentModuleData = {};\n  var hotCurrentChildModule;\n  // eslint-disable-next-line no-unused-vars\n  var hotCurrentParents = [];\n  // eslint-disable-next-line no-unused-vars\n  var hotCurrentParentsTemp = [];\n\n  // eslint-disable-next-line no-unused-vars\n  function hotCreateRequire(moduleId) {\n    var me = installedModules[moduleId];\n    if (!me) return $require$;\n    var fn = function fn(request) {\n      if (me.hot.active) {\n        if (installedModules[request]) {\n          if (installedModules[request].parents.indexOf(moduleId) === -1) {\n            installedModules[request].parents.push(moduleId);\n          }\n        } else {\n          hotCurrentParents = [moduleId];\n          hotCurrentChildModule = request;\n        }\n        if (me.children.indexOf(request) === -1) {\n          me.children.push(request);\n        }\n      } else {\n        console.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\n        hotCurrentParents = [];\n      }\n      return $require$(request);\n    };\n    var ObjectFactory = function ObjectFactory(name) {\n      return {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          return $require$[name];\n        },\n        set: function set(value) {\n          $require$[name] = value;\n        }\n      };\n    };\n    for (var name in $require$) {\n      if (Object.prototype.hasOwnProperty.call($require$, name) && name !== \"e\" && name !== \"t\") {\n        Object.defineProperty(fn, name, ObjectFactory(name));\n      }\n    }\n    fn.e = function (chunkId) {\n      if (hotStatus === \"ready\") hotSetStatus(\"prepare\");\n      hotChunksLoading++;\n      return $require$.e(chunkId).then(finishChunkLoading, function (err) {\n        finishChunkLoading();\n        throw err;\n      });\n      function finishChunkLoading() {\n        hotChunksLoading--;\n        if (hotStatus === \"prepare\") {\n          if (!hotWaitingFilesMap[chunkId]) {\n            hotEnsureUpdateChunk(chunkId);\n          }\n          if (hotChunksLoading === 0 && hotWaitingFiles === 0) {\n            hotUpdateDownloaded();\n          }\n        }\n      }\n    };\n    fn.t = function (value, mode) {\n      if (mode & 1) value = fn(value);\n      return $require$.t(value, mode & ~1);\n    };\n    return fn;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  function hotCreateModule(moduleId) {\n    var hot = {\n      // private stuff\n      _acceptedDependencies: {},\n      _declinedDependencies: {},\n      _selfAccepted: false,\n      _selfDeclined: false,\n      _disposeHandlers: [],\n      _main: hotCurrentChildModule !== moduleId,\n      // Module API\n      active: true,\n      accept: function accept(dep, callback) {\n        if (dep === undefined) hot._selfAccepted = true;else if (typeof dep === \"function\") hot._selfAccepted = dep;else if (typeof dep === \"object\") for (var i = 0; i < dep.length; i++) {\n          hot._acceptedDependencies[dep[i]] = callback || function () {};\n        } else hot._acceptedDependencies[dep] = callback || function () {};\n      },\n      decline: function decline(dep) {\n        if (dep === undefined) hot._selfDeclined = true;else if (typeof dep === \"object\") for (var i = 0; i < dep.length; i++) {\n          hot._declinedDependencies[dep[i]] = true;\n        } else hot._declinedDependencies[dep] = true;\n      },\n      dispose: function dispose(callback) {\n        hot._disposeHandlers.push(callback);\n      },\n      addDisposeHandler: function addDisposeHandler(callback) {\n        hot._disposeHandlers.push(callback);\n      },\n      removeDisposeHandler: function removeDisposeHandler(callback) {\n        var idx = hot._disposeHandlers.indexOf(callback);\n        if (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n      },\n      // Management API\n      check: hotCheck,\n      apply: hotApply,\n      status: function status(l) {\n        if (!l) return hotStatus;\n        hotStatusHandlers.push(l);\n      },\n      addStatusHandler: function addStatusHandler(l) {\n        hotStatusHandlers.push(l);\n      },\n      removeStatusHandler: function removeStatusHandler(l) {\n        var idx = hotStatusHandlers.indexOf(l);\n        if (idx >= 0) hotStatusHandlers.splice(idx, 1);\n      },\n      //inherit from previous dispose call\n      data: hotCurrentModuleData[moduleId]\n    };\n    hotCurrentChildModule = undefined;\n    return hot;\n  }\n  var hotStatusHandlers = [];\n  var hotStatus = \"idle\";\n  function hotSetStatus(newStatus) {\n    hotStatus = newStatus;\n    for (var i = 0; i < hotStatusHandlers.length; i++) {\n      hotStatusHandlers[i].call(null, newStatus);\n    }\n  }\n\n  // while downloading\n  var hotWaitingFiles = 0;\n  var hotChunksLoading = 0;\n  var hotWaitingFilesMap = {};\n  var hotRequestedFilesMap = {};\n  var hotAvailableFilesMap = {};\n  var hotDeferred;\n\n  // The update info\n  var hotUpdate, hotUpdateNewHash;\n  function toModuleId(id) {\n    var isNumber = +id + \"\" === id;\n    return isNumber ? +id : id;\n  }\n  function hotCheck(apply) {\n    if (hotStatus !== \"idle\") {\n      throw new Error(\"check() is only allowed in idle status\");\n    }\n    hotApplyOnUpdate = apply;\n    hotSetStatus(\"check\");\n    return hotDownloadManifest(hotRequestTimeout).then(function (update) {\n      if (!update) {\n        hotSetStatus(\"idle\");\n        return null;\n      }\n      hotRequestedFilesMap = {};\n      hotWaitingFilesMap = {};\n      hotAvailableFilesMap = update.c;\n      hotUpdateNewHash = update.h;\n      hotSetStatus(\"prepare\");\n      var promise = new Promise(function (resolve, reject) {\n        hotDeferred = {\n          resolve: resolve,\n          reject: reject\n        };\n      });\n      hotUpdate = {};\n      /*foreachInstalledChunks*/\n      // eslint-disable-next-line no-lone-blocks\n      {\n        /*globals chunkId */\n        hotEnsureUpdateChunk(chunkId);\n      }\n      if (hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\n        hotUpdateDownloaded();\n      }\n      return promise;\n    });\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  function hotAddUpdateChunk(chunkId, moreModules) {\n    if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId]) return;\n    hotRequestedFilesMap[chunkId] = false;\n    for (var moduleId in moreModules) {\n      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n        hotUpdate[moduleId] = moreModules[moduleId];\n      }\n    }\n    if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\n      hotUpdateDownloaded();\n    }\n  }\n  function hotEnsureUpdateChunk(chunkId) {\n    if (!hotAvailableFilesMap[chunkId]) {\n      hotWaitingFilesMap[chunkId] = true;\n    } else {\n      hotRequestedFilesMap[chunkId] = true;\n      hotWaitingFiles++;\n      hotDownloadUpdateChunk(chunkId);\n    }\n  }\n  function hotUpdateDownloaded() {\n    hotSetStatus(\"ready\");\n    var deferred = hotDeferred;\n    hotDeferred = null;\n    if (!deferred) return;\n    if (hotApplyOnUpdate) {\n      // Wrap deferred object in Promise to mark it as a well-handled Promise to\n      // avoid triggering uncaught exception warning in Chrome.\n      // See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\n      Promise.resolve().then(function () {\n        return hotApply(hotApplyOnUpdate);\n      }).then(function (result) {\n        deferred.resolve(result);\n      }, function (err) {\n        deferred.reject(err);\n      });\n    } else {\n      var outdatedModules = [];\n      for (var id in hotUpdate) {\n        if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n          outdatedModules.push(toModuleId(id));\n        }\n      }\n      deferred.resolve(outdatedModules);\n    }\n  }\n  function hotApply(options) {\n    if (hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\n    options = options || {};\n    var cb;\n    var i;\n    var j;\n    var module;\n    var moduleId;\n    function getAffectedStuff(updateModuleId) {\n      var outdatedModules = [updateModuleId];\n      var outdatedDependencies = {};\n      var queue = outdatedModules.slice().map(function (id) {\n        return {\n          chain: [id],\n          id: id\n        };\n      });\n      while (queue.length > 0) {\n        var queueItem = queue.pop();\n        var moduleId = queueItem.id;\n        var chain = queueItem.chain;\n        module = installedModules[moduleId];\n        if (!module || module.hot._selfAccepted) continue;\n        if (module.hot._selfDeclined) {\n          return {\n            type: \"self-declined\",\n            chain: chain,\n            moduleId: moduleId\n          };\n        }\n        if (module.hot._main) {\n          return {\n            type: \"unaccepted\",\n            chain: chain,\n            moduleId: moduleId\n          };\n        }\n        for (var i = 0; i < module.parents.length; i++) {\n          var parentId = module.parents[i];\n          var parent = installedModules[parentId];\n          if (!parent) continue;\n          if (parent.hot._declinedDependencies[moduleId]) {\n            return {\n              type: \"declined\",\n              chain: chain.concat([parentId]),\n              moduleId: moduleId,\n              parentId: parentId\n            };\n          }\n          if (outdatedModules.indexOf(parentId) !== -1) continue;\n          if (parent.hot._acceptedDependencies[moduleId]) {\n            if (!outdatedDependencies[parentId]) outdatedDependencies[parentId] = [];\n            addAllToSet(outdatedDependencies[parentId], [moduleId]);\n            continue;\n          }\n          delete outdatedDependencies[parentId];\n          outdatedModules.push(parentId);\n          queue.push({\n            chain: chain.concat([parentId]),\n            id: parentId\n          });\n        }\n      }\n      return {\n        type: \"accepted\",\n        moduleId: updateModuleId,\n        outdatedModules: outdatedModules,\n        outdatedDependencies: outdatedDependencies\n      };\n    }\n    function addAllToSet(a, b) {\n      for (var i = 0; i < b.length; i++) {\n        var item = b[i];\n        if (a.indexOf(item) === -1) a.push(item);\n      }\n    }\n\n    // at begin all updates modules are outdated\n    // the \"outdated\" status can propagate to parents if they don't accept the children\n    var outdatedDependencies = {};\n    var outdatedModules = [];\n    var appliedUpdate = {};\n    var warnUnexpectedRequire = function warnUnexpectedRequire() {\n      console.warn(\"[HMR] unexpected require(\" + result.moduleId + \") to disposed module\");\n    };\n    for (var id in hotUpdate) {\n      if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n        moduleId = toModuleId(id);\n        /** @type {TODO} */\n        var result;\n        if (hotUpdate[id]) {\n          result = getAffectedStuff(moduleId);\n        } else {\n          result = {\n            type: \"disposed\",\n            moduleId: id\n          };\n        }\n        /** @type {Error|false} */\n        var abortError = false;\n        var doApply = false;\n        var doDispose = false;\n        var chainInfo = \"\";\n        if (result.chain) {\n          chainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n        }\n        switch (result.type) {\n          case \"self-declined\":\n            if (options.onDeclined) options.onDeclined(result);\n            if (!options.ignoreDeclined) abortError = new Error(\"Aborted because of self decline: \" + result.moduleId + chainInfo);\n            break;\n          case \"declined\":\n            if (options.onDeclined) options.onDeclined(result);\n            if (!options.ignoreDeclined) abortError = new Error(\"Aborted because of declined dependency: \" + result.moduleId + \" in \" + result.parentId + chainInfo);\n            break;\n          case \"unaccepted\":\n            if (options.onUnaccepted) options.onUnaccepted(result);\n            if (!options.ignoreUnaccepted) abortError = new Error(\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo);\n            break;\n          case \"accepted\":\n            if (options.onAccepted) options.onAccepted(result);\n            doApply = true;\n            break;\n          case \"disposed\":\n            if (options.onDisposed) options.onDisposed(result);\n            doDispose = true;\n            break;\n          default:\n            throw new Error(\"Unexception type \" + result.type);\n        }\n        if (abortError) {\n          hotSetStatus(\"abort\");\n          return Promise.reject(abortError);\n        }\n        if (doApply) {\n          appliedUpdate[moduleId] = hotUpdate[moduleId];\n          addAllToSet(outdatedModules, result.outdatedModules);\n          for (moduleId in result.outdatedDependencies) {\n            if (Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {\n              if (!outdatedDependencies[moduleId]) outdatedDependencies[moduleId] = [];\n              addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);\n            }\n          }\n        }\n        if (doDispose) {\n          addAllToSet(outdatedModules, [result.moduleId]);\n          appliedUpdate[moduleId] = warnUnexpectedRequire;\n        }\n      }\n    }\n\n    // Store self accepted outdated modules to require them later by the module system\n    var outdatedSelfAcceptedModules = [];\n    for (i = 0; i < outdatedModules.length; i++) {\n      moduleId = outdatedModules[i];\n      if (installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted) outdatedSelfAcceptedModules.push({\n        module: moduleId,\n        errorHandler: installedModules[moduleId].hot._selfAccepted\n      });\n    }\n\n    // Now in \"dispose\" phase\n    hotSetStatus(\"dispose\");\n    Object.keys(hotAvailableFilesMap).forEach(function (chunkId) {\n      if (hotAvailableFilesMap[chunkId] === false) {\n        hotDisposeChunk(chunkId);\n      }\n    });\n    var idx;\n    var queue = outdatedModules.slice();\n    while (queue.length > 0) {\n      moduleId = queue.pop();\n      module = installedModules[moduleId];\n      if (!module) continue;\n      var data = {};\n\n      // Call dispose handlers\n      var disposeHandlers = module.hot._disposeHandlers;\n      for (j = 0; j < disposeHandlers.length; j++) {\n        cb = disposeHandlers[j];\n        cb(data);\n      }\n      hotCurrentModuleData[moduleId] = data;\n\n      // disable module (this disables requires from this module)\n      module.hot.active = false;\n\n      // remove module from cache\n      delete installedModules[moduleId];\n\n      // when disposing there is no need to call dispose handler\n      delete outdatedDependencies[moduleId];\n\n      // remove \"parents\" references from all children\n      for (j = 0; j < module.children.length; j++) {\n        var child = installedModules[module.children[j]];\n        if (!child) continue;\n        idx = child.parents.indexOf(moduleId);\n        if (idx >= 0) {\n          child.parents.splice(idx, 1);\n        }\n      }\n    }\n\n    // remove outdated dependency from module children\n    var dependency;\n    var moduleOutdatedDependencies;\n    for (moduleId in outdatedDependencies) {\n      if (Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\n        module = installedModules[moduleId];\n        if (module) {\n          moduleOutdatedDependencies = outdatedDependencies[moduleId];\n          for (j = 0; j < moduleOutdatedDependencies.length; j++) {\n            dependency = moduleOutdatedDependencies[j];\n            idx = module.children.indexOf(dependency);\n            if (idx >= 0) module.children.splice(idx, 1);\n          }\n        }\n      }\n    }\n\n    // Not in \"apply\" phase\n    hotSetStatus(\"apply\");\n    hotCurrentHash = hotUpdateNewHash;\n\n    // insert new code\n    for (moduleId in appliedUpdate) {\n      if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n        modules[moduleId] = appliedUpdate[moduleId];\n      }\n    }\n\n    // call accept handlers\n    var error = null;\n    for (moduleId in outdatedDependencies) {\n      if (Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\n        module = installedModules[moduleId];\n        if (module) {\n          moduleOutdatedDependencies = outdatedDependencies[moduleId];\n          var callbacks = [];\n          for (i = 0; i < moduleOutdatedDependencies.length; i++) {\n            dependency = moduleOutdatedDependencies[i];\n            cb = module.hot._acceptedDependencies[dependency];\n            if (cb) {\n              if (callbacks.indexOf(cb) !== -1) continue;\n              callbacks.push(cb);\n            }\n          }\n          for (i = 0; i < callbacks.length; i++) {\n            cb = callbacks[i];\n            try {\n              cb(moduleOutdatedDependencies);\n            } catch (err) {\n              if (options.onErrored) {\n                options.onErrored({\n                  type: \"accept-errored\",\n                  moduleId: moduleId,\n                  dependencyId: moduleOutdatedDependencies[i],\n                  error: err\n                });\n              }\n              if (!options.ignoreErrored) {\n                if (!error) error = err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Load self accepted modules\n    for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {\n      var item = outdatedSelfAcceptedModules[i];\n      moduleId = item.module;\n      hotCurrentParents = [moduleId];\n      try {\n        $require$(moduleId);\n      } catch (err) {\n        if (typeof item.errorHandler === \"function\") {\n          try {\n            item.errorHandler(err);\n          } catch (err2) {\n            if (options.onErrored) {\n              options.onErrored({\n                type: \"self-accept-error-handler-errored\",\n                moduleId: moduleId,\n                error: err2,\n                originalError: err\n              });\n            }\n            if (!options.ignoreErrored) {\n              if (!error) error = err2;\n            }\n            if (!error) error = err;\n          }\n        } else {\n          if (options.onErrored) {\n            options.onErrored({\n              type: \"self-accept-errored\",\n              moduleId: moduleId,\n              error: err\n            });\n          }\n          if (!options.ignoreErrored) {\n            if (!error) error = err;\n          }\n        }\n      }\n    }\n\n    // handle errors in accept handlers and self accepted module load\n    if (error) {\n      hotSetStatus(\"fail\");\n      return Promise.reject(error);\n    }\n    hotSetStatus(\"idle\");\n    return new Promise(function (resolve) {\n      resolve(outdatedModules);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}