{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _toConsumableArray = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _slicedToArray = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar Generator = require(\"../Generator\");\nvar Template = require(\"../Template\");\nvar WebAssemblyUtils = require(\"./WebAssemblyUtils\");\nvar _require = require(\"webpack-sources\"),\n  RawSource = _require.RawSource;\nvar _require2 = require(\"@webassemblyjs/wasm-edit\"),\n  editWithAST = _require2.editWithAST,\n  addWithAST = _require2.addWithAST;\nvar _require3 = require(\"@webassemblyjs/wasm-parser\"),\n  decode = _require3.decode;\nvar t = require(\"@webassemblyjs/ast\");\nvar _require4 = require(\"@webassemblyjs/helper-module-context\"),\n  moduleContextFromModuleAST = _require4.moduleContextFromModuleAST;\nvar WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\nvar compose = function compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return fns.reduce(function (prevFn, nextFn) {\n    return function (value) {\n      return nextFn(prevFn(value));\n    };\n  }, function (value) {\n    return value;\n  });\n};\n\n// TODO replace with @callback\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state - unused state\n * @returns {ArrayBufferTransform} transform\n */\nvar removeStartFunc = function removeStartFunc(state) {\n  return function (bin) {\n    return editWithAST(state.ast, bin, {\n      Start: function Start(path) {\n        path.remove();\n      }\n    });\n  };\n};\n\n/**\n * Get imported globals\n *\n * @param {Object} ast - Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\nvar getImportedGlobals = function getImportedGlobals(ast) {\n  var importedGlobals = [];\n  t.traverse(ast, {\n    ModuleImport: function ModuleImport(_ref) {\n      var node = _ref.node;\n      if (t.isGlobalType(node.descr) === true) {\n        importedGlobals.push(node);\n      }\n    }\n  });\n  return importedGlobals;\n};\nvar getCountImportedFunc = function getCountImportedFunc(ast) {\n  var count = 0;\n  t.traverse(ast, {\n    ModuleImport: function ModuleImport(_ref2) {\n      var node = _ref2.node;\n      if (t.isFuncImportDescr(node.descr) === true) {\n        count++;\n      }\n    }\n  });\n  return count;\n};\n\n/**\n * Get next type index\n *\n * @param {Object} ast - Module's AST\n * @returns {t.Index} - index\n */\nvar getNextTypeIndex = function getNextTypeIndex(ast) {\n  var typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n  if (typeSectionMetadata === undefined) {\n    return t.indexLiteral(0);\n  }\n  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast - Module's AST\n * @param {Number} countImportedFunc - number of imported funcs\n * @returns {t.Index} - index\n */\nvar getNextFuncIndex = function getNextFuncIndex(ast, countImportedFunc) {\n  var funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n  if (funcSectionMetadata === undefined) {\n    return t.indexLiteral(0 + countImportedFunc);\n  }\n  var vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n  return t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n\n/**\n * Create a init instruction for a global\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\nvar createDefaultInitForGlobal = function createDefaultInitForGlobal(globalType) {\n  if (globalType.valtype[0] === \"i\") {\n    // create NumberLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.numberLiteralFromRaw(66)]);\n  } else if (globalType.valtype[0] === \"f\") {\n    // create FloatLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.floatLiteral(66, false, false, \"66\")]);\n  } else {\n    throw new Error(\"unknown type: \" + globalType.valtype);\n  }\n};\n\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same time\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state - unused state\n * @returns {ArrayBufferTransform} transform\n */\nvar rewriteImportedGlobals = function rewriteImportedGlobals(state) {\n  return function (bin) {\n    var additionalInitCode = state.additionalInitCode;\n    var newGlobals = [];\n    bin = editWithAST(state.ast, bin, {\n      ModuleImport: function ModuleImport(path) {\n        if (t.isGlobalType(path.node.descr) === true) {\n          var globalType = path.node.descr;\n          globalType.mutability = \"var\";\n          var init = createDefaultInitForGlobal(globalType);\n          newGlobals.push(t.global(globalType, [init]));\n          path.remove();\n        }\n      },\n      // in order to preserve non-imported global's order we need to re-inject\n      // those as well\n      Global: function Global(path) {\n        var node = path.node;\n        var _node$init = _slicedToArray(node.init, 1),\n          init = _node$init[0];\n        if (init.id === \"get_global\") {\n          node.globalType.mutability = \"var\";\n          var initialGlobalidx = init.args[0];\n          node.init = [createDefaultInitForGlobal(node.globalType)];\n          additionalInitCode.push(\n          /**\n           * get_global in global initilizer only work for imported globals.\n           * They have the same indices than the init params, so use the\n           * same index.\n           */\n          t.instruction(\"get_local\", [initialGlobalidx]), t.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)]));\n        }\n        newGlobals.push(node);\n        path.remove();\n      }\n    });\n\n    // Add global declaration instructions\n    return addWithAST(state.ast, bin, newGlobals);\n  };\n};\n\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {Set<string>} state.externalExports Module\n * @returns {ArrayBufferTransform} transform\n */\nvar rewriteExportNames = function rewriteExportNames(_ref3) {\n  var ast = _ref3.ast,\n    module = _ref3.module,\n    externalExports = _ref3.externalExports;\n  return function (bin) {\n    return editWithAST(ast, bin, {\n      ModuleExport: function ModuleExport(path) {\n        var isExternal = externalExports.has(path.node.name);\n        if (isExternal) {\n          path.remove();\n          return;\n        }\n        var usedName = module.isUsed(path.node.name);\n        if (!usedName) {\n          path.remove();\n          return;\n        }\n        path.node.name = usedName;\n      }\n    });\n  };\n};\n\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\nvar rewriteImports = function rewriteImports(_ref4) {\n  var ast = _ref4.ast,\n    usedDependencyMap = _ref4.usedDependencyMap;\n  return function (bin) {\n    return editWithAST(ast, bin, {\n      ModuleImport: function ModuleImport(path) {\n        var result = usedDependencyMap.get(path.node.module + \":\" + path.node.name);\n        if (result !== undefined) {\n          path.node.module = result.module;\n          path.node.name = result.name;\n        }\n      }\n    });\n  };\n};\n\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast - Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\nvar addInitFunction = function addInitFunction(_ref5) {\n  var ast = _ref5.ast,\n    initFuncId = _ref5.initFuncId,\n    startAtFuncOffset = _ref5.startAtFuncOffset,\n    importedGlobals = _ref5.importedGlobals,\n    additionalInitCode = _ref5.additionalInitCode,\n    nextFuncIndex = _ref5.nextFuncIndex,\n    nextTypeIndex = _ref5.nextTypeIndex;\n  return function (bin) {\n    var funcParams = importedGlobals.map(function (importedGlobal) {\n      // used for debugging\n      var id = t.identifier(\"\".concat(importedGlobal.module, \".\").concat(importedGlobal.name));\n      return t.funcParam(importedGlobal.descr.valtype, id);\n    });\n    var funcBody = importedGlobals.reduce(function (acc, importedGlobal, index) {\n      var args = [t.indexLiteral(index)];\n      var body = [t.instruction(\"get_local\", args), t.instruction(\"set_global\", args)];\n      return [].concat(_toConsumableArray(acc), body);\n    }, []);\n    if (typeof startAtFuncOffset === \"number\") {\n      funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n    }\n    var _iterator = _createForOfIteratorHelper(additionalInitCode),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var instr = _step.value;\n        funcBody.push(instr);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var funcResults = [];\n\n    // Code section\n    var funcSignature = t.signature(funcParams, funcResults);\n    var func = t.func(initFuncId, funcSignature, funcBody);\n\n    // Type section\n    var functype = t.typeInstruction(undefined, funcSignature);\n\n    // Func section\n    var funcindex = t.indexInFuncSection(nextTypeIndex);\n\n    // Export section\n    var moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr(\"Func\", nextFuncIndex));\n    return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n  };\n};\n\n/**\n * Extract mangle mappings from module\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\nvar getUsedDependencyMap = function getUsedDependencyMap(module, mangle) {\n  /** @type {Map<string, UsedWasmDependency>} */\n  var map = new Map();\n  var _iterator2 = _createForOfIteratorHelper(WebAssemblyUtils.getUsedDependencies(module, mangle)),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var usedDep = _step2.value;\n      var dep = usedDep.dependency;\n      var request = dep.request;\n      var exportName = dep.name;\n      map.set(request + \":\" + exportName, usedDep);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return map;\n};\nvar WebAssemblyGenerator = /*#__PURE__*/function (_Generator) {\n  _inherits(WebAssemblyGenerator, _Generator);\n  function WebAssemblyGenerator(options) {\n    var _this;\n    _classCallCheck(this, WebAssemblyGenerator);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebAssemblyGenerator).call(this));\n    _this.options = options;\n    return _this;\n  }\n\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n   * @param {RuntimeTemplate} runtimeTemplate the runtime template\n   * @param {string} type which kind of code should be generated\n   * @returns {Source} generated code\n   */\n  _createClass(WebAssemblyGenerator, [{\n    key: \"generate\",\n    value: function generate(module, dependencyTemplates, runtimeTemplate, type) {\n      var bin = module.originalSource().source();\n      var initFuncId = t.identifier(Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : \"__webpack_init__\");\n\n      // parse it\n      var ast = decode(bin, {\n        ignoreDataSection: true,\n        ignoreCodeSection: true,\n        ignoreCustomNameSection: true\n      });\n      var moduleContext = moduleContextFromModuleAST(ast.body[0]);\n      var importedGlobals = getImportedGlobals(ast);\n      var countImportedFunc = getCountImportedFunc(ast);\n      var startAtFuncOffset = moduleContext.getStart();\n      var nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n      var nextTypeIndex = getNextTypeIndex(ast);\n      var usedDependencyMap = getUsedDependencyMap(module, this.options.mangleImports);\n      var externalExports = new Set(module.dependencies.filter(function (d) {\n        return d instanceof WebAssemblyExportImportedDependency;\n      }).map(function (d) {\n        var wasmDep = /** @type {WebAssemblyExportImportedDependency} */d;\n        return wasmDep.exportName;\n      }));\n\n      /** @type {t.Instruction[]} */\n      var additionalInitCode = [];\n      var transform = compose(rewriteExportNames({\n        ast: ast,\n        module: module,\n        externalExports: externalExports\n      }), removeStartFunc({\n        ast: ast\n      }), rewriteImportedGlobals({\n        ast: ast,\n        additionalInitCode: additionalInitCode\n      }), rewriteImports({\n        ast: ast,\n        usedDependencyMap: usedDependencyMap\n      }), addInitFunction({\n        ast: ast,\n        initFuncId: initFuncId,\n        importedGlobals: importedGlobals,\n        additionalInitCode: additionalInitCode,\n        startAtFuncOffset: startAtFuncOffset,\n        nextFuncIndex: nextFuncIndex,\n        nextTypeIndex: nextTypeIndex\n      }));\n      var newBin = transform(bin);\n      return new RawSource(newBin);\n    }\n  }]);\n  return WebAssemblyGenerator;\n}(Generator);\nmodule.exports = WebAssemblyGenerator;","map":null,"metadata":{},"sourceType":"script"}