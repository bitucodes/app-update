{"ast":null,"code":"\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar similarity = function similarity(a, b) {\n  var l = Math.min(a.length, b.length);\n  var dist = 0;\n  for (var i = 0; i < l; i++) {\n    var ca = a.charCodeAt(i);\n    var cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n  return dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\nvar getName = function getName(a, b) {\n  var l = Math.min(a.length, b.length);\n  var r = \"\";\n  for (var i = 0; i < l; i++) {\n    var ca = a.charAt(i);\n    var cb = b.charAt(i);\n    r += ca;\n    if (ca === cb) {\n      continue;\n    }\n    return r;\n  }\n  return a;\n};\n\n/**\n * @template T\n */\nvar Node =\n/**\n * @param {T} item item\n * @param {string} key key\n * @param {number} size size\n */\nfunction Node(item, key, size) {\n  _classCallCheck(this, Node);\n  this.item = item;\n  this.key = key;\n  this.size = size;\n};\n/**\n * @template T\n */\nvar Group =\n/**\n * @param {Node<T>[]} nodes nodes\n * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n */\nfunction Group(nodes, similarities) {\n  _classCallCheck(this, Group);\n  this.nodes = nodes;\n  this.similarities = similarities;\n  this.size = nodes.reduce(function (size, node) {\n    return size + node.size;\n  }, 0);\n  /** @type {string} */\n  this.key = undefined;\n};\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = function (_ref) {\n  var maxSize = _ref.maxSize,\n    minSize = _ref.minSize,\n    items = _ref.items,\n    getSize = _ref.getSize,\n    getKey = _ref.getKey;\n  /** @type {Group<T>[]} */\n  var result = [];\n  var nodes = Array.from(items, function (item) {\n    return new Node(item, getKey(item), getSize(item));\n  });\n\n  /** @type {Node<T>[]} */\n  var initialNodes = [];\n\n  // return nodes bigger than maxSize directly as group\n  for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {\n    var node = _nodes[_i];\n    if (node.size >= maxSize) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n  if (initialNodes.length > 0) {\n    // lexically ordering of keys\n    initialNodes.sort(function (a, b) {\n      if (a.key < b.key) return -1;\n      if (a.key > b.key) return 1;\n      return 0;\n    });\n\n    // calculate similarities between lexically adjacent nodes\n    /** @type {number[]} */\n    var similarities = [];\n    for (var i = 1; i < initialNodes.length; i++) {\n      var a = initialNodes[i - 1];\n      var b = initialNodes[i];\n      similarities.push(similarity(a.key, b.key));\n    }\n    var queue = [new Group(initialNodes, similarities)];\n    while (queue.length) {\n      var group = queue.pop();\n      // only groups bigger than maxSize need to be splitted\n      if (group.size < maxSize) {\n        result.push(group);\n        continue;\n      }\n\n      // find unsplittable area from left and right\n      // going minSize from left and right\n      var left = 0;\n      var leftSize = 0;\n      while (leftSize < minSize) {\n        leftSize += group.nodes[left].size;\n        left++;\n      }\n      var right = group.nodes.length - 1;\n      var rightSize = 0;\n      while (rightSize < minSize) {\n        rightSize += group.nodes[right].size;\n        right--;\n      }\n      if (left - 1 > right) {\n        // can't split group while holding minSize\n        // because minSize is preferred of maxSize we return\n        // the group here even while it's too big\n        // To avoid this make sure maxSize > minSize * 3\n        result.push(group);\n        continue;\n      }\n      if (left <= right) {\n        // when there is a area between left and right\n        // we look for best split point\n        // we split at the minimum similarity\n        // here key space is separated the most\n        var best = left - 1;\n        var bestSimilarity = group.similarities[best];\n        for (var _i2 = left; _i2 <= right; _i2++) {\n          var _similarity = group.similarities[_i2];\n          if (_similarity < bestSimilarity) {\n            best = _i2;\n            bestSimilarity = _similarity;\n          }\n        }\n        left = best + 1;\n        right = best;\n      }\n\n      // create two new groups for left and right area\n      // and queue them up\n      var rightNodes = [group.nodes[right + 1]];\n      /** @type {number[]} */\n      var rightSimilaries = [];\n      for (var _i3 = right + 2; _i3 < group.nodes.length; _i3++) {\n        rightSimilaries.push(group.similarities[_i3 - 1]);\n        rightNodes.push(group.nodes[_i3]);\n      }\n      queue.push(new Group(rightNodes, rightSimilaries));\n      var leftNodes = [group.nodes[0]];\n      /** @type {number[]} */\n      var leftSimilaries = [];\n      for (var _i4 = 1; _i4 < left; _i4++) {\n        leftSimilaries.push(group.similarities[_i4 - 1]);\n        leftNodes.push(group.nodes[_i4]);\n      }\n      queue.push(new Group(leftNodes, leftSimilaries));\n    }\n  }\n\n  // lexically ordering\n  result.sort(function (a, b) {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  });\n\n  // give every group a name\n  for (var _i5 = 0; _i5 < result.length; _i5++) {\n    var _group = result[_i5];\n    var first = _group.nodes[0];\n    var last = _group.nodes[_group.nodes.length - 1];\n    var name = getName(first.key, last.key);\n    _group.key = name;\n  }\n\n  // return the results\n  return result.map(function (group) {\n    /** @type {GroupedItems} */\n    return {\n      key: group.key,\n      items: group.nodes.map(function (node) {\n        return node.item;\n      }),\n      size: group.size\n    };\n  });\n};","map":null,"metadata":{},"sourceType":"script"}