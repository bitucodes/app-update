{"ast":null,"code":"'use strict';\n\nvar _taggedTemplateLiteral = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _wrapNativeSuper = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\nvar _templateObject;\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar BB = require('bluebird');\nvar contentPath = require('./content/path');\nvar crypto = require('crypto');\nvar fixOwner = require('./util/fix-owner');\nvar fs = require('graceful-fs');\nvar hashToSegments = require('./util/hash-to-segments');\nvar ms = require('mississippi');\nvar path = require('path');\nvar ssri = require('ssri');\nvar Y = require('./util/y.js');\nvar indexV = require('../package.json')['cache-version'].index;\nvar appendFileAsync = BB.promisify(fs.appendFile);\nvar readFileAsync = BB.promisify(fs.readFile);\nvar readdirAsync = BB.promisify(fs.readdir);\nvar concat = ms.concat;\nvar from = ms.from;\nmodule.exports.NotFoundError = /*#__PURE__*/function (_Error) {\n  _inherits(NotFoundError, _Error);\n  function NotFoundError(cache, key) {\n    var _this;\n    _classCallCheck(this, NotFoundError);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NotFoundError).call(this, Y(_templateObject || (_templateObject = _taggedTemplateLiteral([\"No cache entry for `\", \"` found in `\", \"`\"], [\"No cache entry for \\\\`\", \"\\\\` found in \\\\`\", \"\\\\`\"])), key, cache)));\n    _this.code = 'ENOENT';\n    _this.cache = cache;\n    _this.key = key;\n    return _this;\n  }\n  return NotFoundError;\n}(_wrapNativeSuper(Error));\nmodule.exports.insert = insert;\nfunction insert(cache, key, integrity, opts) {\n  opts = opts || {};\n  var bucket = bucketPath(cache, key);\n  var entry = {\n    key: key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  };\n  return fixOwner.mkdirfix(path.dirname(bucket), opts.uid, opts.gid).then(function () {\n    var stringified = JSON.stringify(entry);\n    // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n    return appendFileAsync(bucket, \"\\n\".concat(hashEntry(stringified), \"\\t\").concat(stringified));\n  }).then(function () {\n    return fixOwner.chownr(bucket, opts.uid, opts.gid);\n  }).catch({\n    code: 'ENOENT'\n  }, function () {\n    // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(function () {\n    return formatEntry(cache, entry);\n  });\n}\nmodule.exports.find = find;\nfunction find(cache, key) {\n  var bucket = bucketPath(cache, key);\n  return bucketEntries(cache, bucket).then(function (entries) {\n    return entries.reduce(function (latest, next) {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  }).catch(function (err) {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  });\n}\nmodule.exports.delete = del;\nfunction del(cache, key, opts) {\n  return insert(cache, key, null, opts);\n}\nmodule.exports.lsStream = lsStream;\nfunction lsStream(cache) {\n  var indexDir = bucketDir(cache);\n  var stream = from.obj();\n\n  // \"/cachename/*\"\n  readdirOrEmpty(indexDir).map(function (bucket) {\n    var bucketPath = path.join(indexDir, bucket);\n\n    // \"/cachename/<bucket 0xFF>/*\"\n    return readdirOrEmpty(bucketPath).map(function (subbucket) {\n      var subbucketPath = path.join(bucketPath, subbucket);\n\n      // \"/cachename/<bucket 0xFF>/<bucket 0xFF>/*\"\n      return readdirOrEmpty(subbucketPath).map(function (entry) {\n        var getKeyToEntry = bucketEntries(cache, path.join(subbucketPath, entry)).reduce(function (acc, entry) {\n          acc.set(entry.key, entry);\n          return acc;\n        }, new Map());\n        return getKeyToEntry.then(function (reduced) {\n          var _iterator = _createForOfIteratorHelper(reduced.values()),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _entry = _step.value;\n              var formatted = formatEntry(cache, _entry);\n              formatted && stream.push(formatted);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }).catch({\n          code: 'ENOENT'\n        }, nop);\n      });\n    });\n  }).then(function () {\n    stream.push(null);\n  }, function (err) {\n    stream.emit('error', err);\n  });\n  return stream;\n}\nmodule.exports.ls = ls;\nfunction ls(cache) {\n  return BB.fromNode(function (cb) {\n    lsStream(cache).on('error', cb).pipe(concat(function (entries) {\n      cb(null, entries.reduce(function (acc, xs) {\n        acc[xs.key] = xs;\n        return acc;\n      }, {}));\n    }));\n  });\n}\nfunction bucketEntries(cache, bucket, filter) {\n  return readFileAsync(bucket, 'utf8').then(function (data) {\n    var entries = [];\n    data.split('\\n').forEach(function (entry) {\n      if (!entry) {\n        return;\n      }\n      var pieces = entry.split('\\t');\n      if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n        // Hash is no good! Corruption or malice? Doesn't matter!\n        // EJECT EJECT\n        return;\n      }\n      var obj;\n      try {\n        obj = JSON.parse(pieces[1]);\n      } catch (e) {\n        // Entry is corrupted!\n        return;\n      }\n      if (obj) {\n        entries.push(obj);\n      }\n    });\n    return entries;\n  });\n}\nmodule.exports._bucketDir = bucketDir;\nfunction bucketDir(cache) {\n  return path.join(cache, \"index-v\".concat(indexV));\n}\nmodule.exports._bucketPath = bucketPath;\nfunction bucketPath(cache, key) {\n  var hashed = hashKey(key);\n  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));\n}\nmodule.exports._hashKey = hashKey;\nfunction hashKey(key) {\n  return hash(key, 'sha256');\n}\nmodule.exports._hashEntry = hashEntry;\nfunction hashEntry(str) {\n  return hash(str, 'sha1');\n}\nfunction hash(str, digest) {\n  return crypto.createHash(digest).update(str).digest('hex');\n}\nfunction formatEntry(cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) {\n    return null;\n  }\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  };\n}\nfunction readdirOrEmpty(dir) {\n  return readdirAsync(dir).catch({\n    code: 'ENOENT'\n  }, function () {\n    return [];\n  }).catch({\n    code: 'ENOTDIR'\n  }, function () {\n    return [];\n  });\n}\nfunction nop() {}","map":null,"metadata":{},"sourceType":"script"}