{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar createDefaultHandler = function createDefaultHandler(profile) {\n  var lineCaretPosition = 0;\n  var lastState;\n  var lastStateTime;\n  var defaultHandler = function defaultHandler(percentage, msg) {\n    var state = msg;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    var details = args;\n    if (percentage < 1) {\n      percentage = Math.floor(percentage * 100);\n      msg = \"\".concat(percentage, \"% \").concat(msg);\n      if (percentage < 100) {\n        msg = \" \".concat(msg);\n      }\n      if (percentage < 10) {\n        msg = \" \".concat(msg);\n      }\n      var _iterator = _createForOfIteratorHelper(details),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var detail = _step.value;\n          if (!detail) continue;\n          if (detail.length > 40) {\n            detail = \"...\".concat(detail.substr(detail.length - 39));\n          }\n          msg += \" \".concat(detail);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    if (profile) {\n      state = state.replace(/^\\d+\\/\\d+\\s+/, \"\");\n      if (percentage === 0) {\n        lastState = null;\n        lastStateTime = Date.now();\n      } else if (state !== lastState || percentage === 1) {\n        var now = Date.now();\n        if (lastState) {\n          var stateMsg = \"\".concat(now - lastStateTime, \"ms \").concat(lastState);\n          goToLineStart(stateMsg);\n          process.stderr.write(stateMsg + \"\\n\");\n          lineCaretPosition = 0;\n        }\n        lastState = state;\n        lastStateTime = now;\n      }\n    }\n    goToLineStart(msg);\n    process.stderr.write(msg);\n  };\n  var goToLineStart = function goToLineStart(nextMessage) {\n    var str = \"\";\n    for (; lineCaretPosition > nextMessage.length; lineCaretPosition--) {\n      str += \"\\b \\b\";\n    }\n    for (var i = 0; i < lineCaretPosition; i++) {\n      str += \"\\b\";\n    }\n    lineCaretPosition = nextMessage.length;\n    if (str) process.stderr.write(str);\n  };\n  return defaultHandler;\n};\nvar ProgressPlugin = /*#__PURE__*/function () {\n  function ProgressPlugin(options) {\n    _classCallCheck(this, ProgressPlugin);\n    if (typeof options === \"function\") {\n      options = {\n        handler: options\n      };\n    }\n    options = options || {};\n    this.profile = options.profile;\n    this.handler = options.handler;\n  }\n  _createClass(ProgressPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var handler = this.handler || createDefaultHandler(this.profile);\n      if (compiler.compilers) {\n        var states = new Array(compiler.compilers.length);\n        compiler.compilers.forEach(function (compiler, idx) {\n          new ProgressPlugin(function (p, msg) {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n              args[_key2 - 2] = arguments[_key2];\n            }\n            states[idx] = [p, msg].concat(args);\n            handler.apply(void 0, [states.map(function (state) {\n              return state && state[0] || 0;\n            }).reduce(function (a, b) {\n              return a + b;\n            }) / states.length, \"[\".concat(idx, \"] \").concat(msg)].concat(args));\n          }).apply(compiler);\n        });\n      } else {\n        var lastModulesCount = 0;\n        var moduleCount = 500;\n        var doneModules = 0;\n        var activeModules = [];\n        var update = function update(module) {\n          handler(0.1 + doneModules / Math.max(lastModulesCount, moduleCount) * 0.6, \"building modules\", \"\".concat(doneModules, \"/\").concat(moduleCount, \" modules\"), \"\".concat(activeModules.length, \" active\"), activeModules[activeModules.length - 1]);\n        };\n        var moduleDone = function moduleDone(module) {\n          doneModules++;\n          var ident = module.identifier();\n          if (ident) {\n            var idx = activeModules.indexOf(ident);\n            if (idx >= 0) activeModules.splice(idx, 1);\n          }\n          update();\n        };\n        compiler.hooks.compilation.tap(\"ProgressPlugin\", function (compilation) {\n          if (compilation.compiler.isChild()) return;\n          lastModulesCount = moduleCount;\n          moduleCount = 0;\n          doneModules = 0;\n          handler(0, \"compiling\");\n          compilation.hooks.buildModule.tap(\"ProgressPlugin\", function (module) {\n            moduleCount++;\n            var ident = module.identifier();\n            if (ident) {\n              activeModules.push(ident);\n            }\n            update();\n          });\n          compilation.hooks.failedModule.tap(\"ProgressPlugin\", moduleDone);\n          compilation.hooks.succeedModule.tap(\"ProgressPlugin\", moduleDone);\n          var hooks = {\n            finishModules: \"finish module graph\",\n            seal: \"sealing\",\n            optimizeDependenciesBasic: \"basic dependencies optimization\",\n            optimizeDependencies: \"dependencies optimization\",\n            optimizeDependenciesAdvanced: \"advanced dependencies optimization\",\n            afterOptimizeDependencies: \"after dependencies optimization\",\n            optimize: \"optimizing\",\n            optimizeModulesBasic: \"basic module optimization\",\n            optimizeModules: \"module optimization\",\n            optimizeModulesAdvanced: \"advanced module optimization\",\n            afterOptimizeModules: \"after module optimization\",\n            optimizeChunksBasic: \"basic chunk optimization\",\n            optimizeChunks: \"chunk optimization\",\n            optimizeChunksAdvanced: \"advanced chunk optimization\",\n            afterOptimizeChunks: \"after chunk optimization\",\n            optimizeTree: \"module and chunk tree optimization\",\n            afterOptimizeTree: \"after module and chunk tree optimization\",\n            optimizeChunkModulesBasic: \"basic chunk modules optimization\",\n            optimizeChunkModules: \"chunk modules optimization\",\n            optimizeChunkModulesAdvanced: \"advanced chunk modules optimization\",\n            afterOptimizeChunkModules: \"after chunk modules optimization\",\n            reviveModules: \"module reviving\",\n            optimizeModuleOrder: \"module order optimization\",\n            advancedOptimizeModuleOrder: \"advanced module order optimization\",\n            beforeModuleIds: \"before module ids\",\n            moduleIds: \"module ids\",\n            optimizeModuleIds: \"module id optimization\",\n            afterOptimizeModuleIds: \"module id optimization\",\n            reviveChunks: \"chunk reviving\",\n            optimizeChunkOrder: \"chunk order optimization\",\n            beforeChunkIds: \"before chunk ids\",\n            optimizeChunkIds: \"chunk id optimization\",\n            afterOptimizeChunkIds: \"after chunk id optimization\",\n            recordModules: \"record modules\",\n            recordChunks: \"record chunks\",\n            beforeHash: \"hashing\",\n            afterHash: \"after hashing\",\n            recordHash: \"record hash\",\n            beforeModuleAssets: \"module assets processing\",\n            beforeChunkAssets: \"chunk assets processing\",\n            additionalChunkAssets: \"additional chunk assets processing\",\n            record: \"recording\",\n            additionalAssets: \"additional asset processing\",\n            optimizeChunkAssets: \"chunk asset optimization\",\n            afterOptimizeChunkAssets: \"after chunk asset optimization\",\n            optimizeAssets: \"asset optimization\",\n            afterOptimizeAssets: \"after asset optimization\",\n            afterSeal: \"after seal\"\n          };\n          var numberOfHooks = Object.keys(hooks).length;\n          Object.keys(hooks).forEach(function (name, idx) {\n            var title = hooks[name];\n            var percentage = idx / numberOfHooks * 0.25 + 0.7;\n            compilation.hooks[name].intercept({\n              name: \"ProgressPlugin\",\n              context: true,\n              call: function call() {\n                handler(percentage, title);\n              },\n              tap: function tap(context, _tap) {\n                if (context) {\n                  // p is percentage from 0 to 1\n                  // args is any number of messages in a hierarchical matter\n                  context.reportProgress = function (p) {\n                    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                      args[_key3 - 1] = arguments[_key3];\n                    }\n                    handler.apply(void 0, [percentage, title, _tap.name].concat(args));\n                  };\n                }\n                handler(percentage, title, _tap.name);\n              }\n            });\n          });\n        });\n        compiler.hooks.emit.intercept({\n          name: \"ProgressPlugin\",\n          context: true,\n          call: function call() {\n            handler(0.95, \"emitting\");\n          },\n          tap: function tap(context, _tap2) {\n            if (context) {\n              context.reportProgress = function (p) {\n                for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n                  args[_key4 - 1] = arguments[_key4];\n                }\n                handler.apply(void 0, [0.95, \"emitting\", _tap2.name].concat(args));\n              };\n            }\n            handler(0.95, \"emitting\", _tap2.name);\n          }\n        });\n        compiler.hooks.afterEmit.intercept({\n          name: \"ProgressPlugin\",\n          context: true,\n          call: function call() {\n            handler(0.98, \"after emitting\");\n          },\n          tap: function tap(context, _tap3) {\n            if (context) {\n              context.reportProgress = function (p) {\n                for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                  args[_key5 - 1] = arguments[_key5];\n                }\n                handler.apply(void 0, [0.98, \"after emitting\", _tap3.name].concat(args));\n              };\n            }\n            handler(0.98, \"after emitting\", _tap3.name);\n          }\n        });\n        compiler.hooks.done.tap(\"ProgressPlugin\", function () {\n          handler(1, \"\");\n        });\n      }\n    }\n  }]);\n  return ProgressPlugin;\n}();\nmodule.exports = ProgressPlugin;","map":null,"metadata":{},"sourceType":"script"}