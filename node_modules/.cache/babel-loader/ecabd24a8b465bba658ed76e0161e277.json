{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar util = require(\"util\");\nvar _require = require(\"webpack-sources\"),\n  OriginalSource = _require.OriginalSource,\n  RawSource = _require.RawSource;\nvar Module = require(\"./Module\");\nvar AsyncDependenciesBlock = require(\"./AsyncDependenciesBlock\");\nvar Template = require(\"./Template\");\nvar contextify = require(\"./util/identifier\").contextify;\n\n/** @typedef {\"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\"} ContextMode Context mode */\n/** @typedef {import(\"./dependencies/ContextElementDependency\")} ContextElementDependency */\n\n/**\n * @callback ResolveDependenciesCallback\n * @param {Error=} err\n * @param {ContextElementDependency[]} dependencies\n */\n\n/**\n * @callback ResolveDependencies\n * @param {TODO} fs\n * @param {TODO} options\n * @param {ResolveDependenciesCallback} callback\n */\nvar ContextModule = /*#__PURE__*/function (_Module) {\n  _inherits(ContextModule, _Module);\n  // type ContextMode = \"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\"\n  // type ContextOptions = { resource: string, recursive: boolean, regExp: RegExp, addon?: string, mode?: ContextMode, chunkName?: string, include?: RegExp, exclude?: RegExp, groupOptions?: Object }\n  // resolveDependencies: (fs: FS, options: ContextOptions, (err: Error?, dependencies: Dependency[]) => void) => void\n  // options: ContextOptions\n  /**\n   * @param {ResolveDependencies} resolveDependencies function to get dependencies in this context\n   * @param {TODO} options options object\n   */\n  function ContextModule(resolveDependencies, options) {\n    var _this;\n    _classCallCheck(this, ContextModule);\n    var resource;\n    var resourceQuery;\n    var queryIdx = options.resource.indexOf(\"?\");\n    if (queryIdx >= 0) {\n      resource = options.resource.substr(0, queryIdx);\n      resourceQuery = options.resource.substr(queryIdx);\n    } else {\n      resource = options.resource;\n      resourceQuery = \"\";\n    }\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextModule).call(this, \"javascript/dynamic\", resource));\n\n    // Info from Factory\n    _this.resolveDependencies = resolveDependencies;\n    _this.options = Object.assign({}, options, {\n      resource: resource,\n      resourceQuery: resourceQuery\n    });\n    if (options.resolveOptions !== undefined) {\n      _this.resolveOptions = options.resolveOptions;\n    }\n\n    // Info from Build\n    _this._contextDependencies = new Set([_this.context]);\n    if (typeof options.mode !== \"string\") {\n      throw new Error(\"options.mode is a required option\");\n    }\n    _this._identifier = _this._createIdentifier();\n    return _this;\n  }\n  _createClass(ContextModule, [{\n    key: \"updateCacheModule\",\n    value: function updateCacheModule(module) {\n      this.resolveDependencies = module.resolveDependencies;\n      this.options = module.options;\n      this.resolveOptions = module.resolveOptions;\n    }\n  }, {\n    key: \"prettyRegExp\",\n    value: function prettyRegExp(regexString) {\n      // remove the \"/\" at the front and the beginning\n      // \"/foo/\" -> \"foo\"\n      return regexString.substring(1, regexString.length - 1);\n    }\n  }, {\n    key: \"_createIdentifier\",\n    value: function _createIdentifier() {\n      var identifier = this.context;\n      if (this.options.resourceQuery) {\n        identifier += \" \".concat(this.options.resourceQuery);\n      }\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n      if (!this.options.recursive) {\n        identifier += \" nonrecursive\";\n      }\n      if (this.options.addon) {\n        identifier += \" \".concat(this.options.addon);\n      }\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.options.regExp);\n      }\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.options.include);\n      }\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.options.exclude);\n      }\n      if (this.options.groupOptions) {\n        identifier += \" groupOptions: \".concat(JSON.stringify(this.options.groupOptions));\n      }\n      if (this.options.namespaceObject === \"strict\") {\n        identifier += \" strict namespace object\";\n      } else if (this.options.namespaceObject) {\n        identifier += \" namespace object\";\n      }\n      return identifier;\n    }\n  }, {\n    key: \"identifier\",\n    value: function identifier() {\n      return this._identifier;\n    }\n  }, {\n    key: \"readableIdentifier\",\n    value: function readableIdentifier(requestShortener) {\n      var identifier = requestShortener.shorten(this.context);\n      if (this.options.resourceQuery) {\n        identifier += \" \".concat(this.options.resourceQuery);\n      }\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n      if (!this.options.recursive) {\n        identifier += \" nonrecursive\";\n      }\n      if (this.options.addon) {\n        identifier += \" \".concat(requestShortener.shorten(this.options.addon));\n      }\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.prettyRegExp(this.options.regExp + \"\"));\n      }\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.prettyRegExp(this.options.include + \"\"));\n      }\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.prettyRegExp(this.options.exclude + \"\"));\n      }\n      if (this.options.groupOptions) {\n        var groupOptions = this.options.groupOptions;\n        for (var _i = 0, _Object$keys = Object.keys(groupOptions); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          identifier += \" \".concat(key, \": \").concat(groupOptions[key]);\n        }\n      }\n      if (this.options.namespaceObject === \"strict\") {\n        identifier += \" strict namespace object\";\n      } else if (this.options.namespaceObject) {\n        identifier += \" namespace object\";\n      }\n      return identifier;\n    }\n  }, {\n    key: \"libIdent\",\n    value: function libIdent(options) {\n      var identifier = contextify(options.context, this.context);\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n      if (this.options.recursive) {\n        identifier += \" recursive\";\n      }\n      if (this.options.addon) {\n        identifier += \" \".concat(contextify(options.context, this.options.addon));\n      }\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.prettyRegExp(this.options.regExp + \"\"));\n      }\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.prettyRegExp(this.options.include + \"\"));\n      }\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.prettyRegExp(this.options.exclude + \"\"));\n      }\n      return identifier;\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      var ts = contextTimestamps.get(this.context);\n      if (!ts) {\n        return true;\n      }\n      return ts >= this.buildInfo.builtTime;\n    }\n  }, {\n    key: \"build\",\n    value: function build(options, compilation, resolver, fs, callback) {\n      var _this2 = this;\n      this.built = true;\n      this.buildMeta = {};\n      this.buildInfo = {\n        builtTime: Date.now(),\n        contextDependencies: this._contextDependencies\n      };\n      this.resolveDependencies(fs, this.options, function (err, dependencies) {\n        if (err) return callback(err);\n\n        // abort if something failed\n        // this will create an empty context\n        if (!dependencies) {\n          callback();\n          return;\n        }\n\n        // enhance dependencies with meta info\n        var _iterator = _createForOfIteratorHelper(dependencies),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _dep3 = _step.value;\n            _dep3.loc = {\n              name: _dep3.userRequest\n            };\n            _dep3.request = _this2.options.addon + _dep3.request;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (_this2.options.mode === \"sync\" || _this2.options.mode === \"eager\") {\n          // if we have an sync or eager context\n          // just add all dependencies and continue\n          _this2.dependencies = dependencies;\n        } else if (_this2.options.mode === \"lazy-once\") {\n          // for the lazy-once mode create a new async dependency block\n          // and add that block to this context\n          if (dependencies.length > 0) {\n            var block = new AsyncDependenciesBlock(Object.assign({}, _this2.options.groupOptions, {\n              name: _this2.options.chunkName\n            }), _this2);\n            var _iterator2 = _createForOfIteratorHelper(dependencies),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var dep = _step2.value;\n                block.addDependency(dep);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n            _this2.addBlock(block);\n          }\n        } else if (_this2.options.mode === \"weak\" || _this2.options.mode === \"async-weak\") {\n          // we mark all dependencies as weak\n          var _iterator3 = _createForOfIteratorHelper(dependencies),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _dep = _step3.value;\n              _dep.weak = true;\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          _this2.dependencies = dependencies;\n        } else if (_this2.options.mode === \"lazy\") {\n          // if we are lazy create a new async dependency block per dependency\n          // and add all blocks to this context\n          var index = 0;\n          var _iterator4 = _createForOfIteratorHelper(dependencies),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _dep2 = _step4.value;\n              var chunkName = _this2.options.chunkName;\n              if (chunkName) {\n                if (!/\\[(index|request)\\]/.test(chunkName)) {\n                  chunkName += \"[index]\";\n                }\n                chunkName = chunkName.replace(/\\[index\\]/g, index++);\n                chunkName = chunkName.replace(/\\[request\\]/g, Template.toPath(_dep2.userRequest));\n              }\n              var _block = new AsyncDependenciesBlock(Object.assign({}, _this2.options.groupOptions, {\n                name: chunkName\n              }), _dep2.module, _dep2.loc, _dep2.userRequest);\n              _block.addDependency(_dep2);\n              _this2.addBlock(_block);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          callback(new Error(\"Unsupported mode \\\"\".concat(_this2.options.mode, \"\\\" in context\")));\n          return;\n        }\n        callback();\n      });\n    }\n  }, {\n    key: \"getUserRequestMap\",\n    value: function getUserRequestMap(dependencies) {\n      // if we filter first we get a new array\n      // therefor we dont need to create a clone of dependencies explicitly\n      // therefore the order of this is !important!\n      return dependencies.filter(function (dependency) {\n        return dependency.module;\n      }).sort(function (a, b) {\n        if (a.userRequest === b.userRequest) {\n          return 0;\n        }\n        return a.userRequest < b.userRequest ? -1 : 1;\n      }).reduce(function (map, dep) {\n        map[dep.userRequest] = dep.module.id;\n        return map;\n      }, Object.create(null));\n    }\n  }, {\n    key: \"getFakeMap\",\n    value: function getFakeMap(dependencies) {\n      var _this3 = this;\n      if (!this.options.namespaceObject) {\n        return 9;\n      }\n      // if we filter first we get a new array\n      // therefor we dont need to create a clone of dependencies explicitly\n      // therefore the order of this is !important!\n      var hasNonHarmony = false;\n      var hasNamespace = false;\n      var hasNamed = false;\n      var fakeMap = dependencies.filter(function (dependency) {\n        return dependency.module;\n      }).sort(function (a, b) {\n        return b.module.id - a.module.id;\n      }).reduce(function (map, dep) {\n        var exportsType = dep.module.buildMeta && dep.module.buildMeta.exportsType;\n        var id = dep.module.id;\n        if (!exportsType) {\n          map[id] = _this3.options.namespaceObject === \"strict\" ? 1 : 7;\n          hasNonHarmony = true;\n        } else if (exportsType === \"namespace\") {\n          map[id] = 9;\n          hasNamespace = true;\n        } else if (exportsType === \"named\") {\n          map[id] = 3;\n          hasNamed = true;\n        }\n        return map;\n      }, Object.create(null));\n      if (!hasNamespace && hasNonHarmony && !hasNamed) {\n        return this.options.namespaceObject === \"strict\" ? 1 : 7;\n      }\n      if (hasNamespace && !hasNonHarmony && !hasNamed) {\n        return 9;\n      }\n      if (!hasNamespace && !hasNonHarmony && hasNamed) {\n        return 3;\n      }\n      if (!hasNamespace && !hasNonHarmony && !hasNamed) {\n        return 9;\n      }\n      return fakeMap;\n    }\n  }, {\n    key: \"getFakeMapInitStatement\",\n    value: function getFakeMapInitStatement(fakeMap) {\n      return typeof fakeMap === \"object\" ? \"var fakeMap = \".concat(JSON.stringify(fakeMap, null, \"\\t\"), \";\") : \"\";\n    }\n  }, {\n    key: \"getReturn\",\n    value: function getReturn(type) {\n      if (type === 9) {\n        return \"__webpack_require__(id)\";\n      }\n      return \"__webpack_require__.t(id, \".concat(type, \")\");\n    }\n  }, {\n    key: \"getReturnModuleObjectSource\",\n    value: function getReturnModuleObjectSource(fakeMap) {\n      var fakeMapDataExpression = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"fakeMap[id]\";\n      if (typeof fakeMap === \"number\") {\n        return \"return \".concat(this.getReturn(fakeMap), \";\");\n      }\n      return \"return __webpack_require__.t(id, \".concat(fakeMapDataExpression, \")\");\n    }\n  }, {\n    key: \"getSyncSource\",\n    value: function getSyncSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\t\").concat(returnModuleObject, \"\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = \").concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getWeakSyncSource\",\n    value: function getWeakSyncSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\tif(!__webpack_require__.m[id]) {\\n\\t\\tvar e = new Error(\\\"Module '\\\" + req + \\\"' ('\\\" + id + \\\"') is not available (weak dependency)\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\t\").concat(returnModuleObject, \"\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nwebpackContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackContext;\");\n    }\n  }, {\n    key: \"getAsyncWeakSource\",\n    value: function getAsyncWeakSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(function(id) {\\n\\t\\tif(!__webpack_require__.m[id]) {\\n\\t\\t\\tvar e = new Error(\\\"Module '\\\" + req + \\\"' ('\\\" + id + \\\"') is not available (weak dependency)\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar id = map[req];\\n\\t\\tif(!(id + 1)) { // check for number or string\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn id;\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getEagerSource\",\n    value: function getEagerSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var thenFunction = fakeMap !== 9 ? \"function(id) {\\n\\t\\t\".concat(this.getReturnModuleObjectSource(fakeMap), \"\\n\\t}\") : \"__webpack_require__\";\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(\").concat(thenFunction, \");\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar id = map[req];\\n\\t\\tif(!(id + 1)) { // check for number or string\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn id;\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getLazyOnceSource\",\n    value: function getLazyOnceSource(block, dependencies, id, runtimeTemplate) {\n      var promise = runtimeTemplate.blockPromise({\n        block: block,\n        message: \"lazy-once context\"\n      });\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var thenFunction = fakeMap !== 9 ? \"function(id) {\\n\\t\\t\".concat(this.getReturnModuleObjectSource(fakeMap), \";\\n\\t}\") : \"__webpack_require__\";\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(\").concat(thenFunction, \");\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\treturn \").concat(promise, \".then(function() {\\n\\t\\tvar id = map[req];\\n\\t\\tif(!(id + 1)) { // check for number or string\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn id;\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getLazySource\",\n    value: function getLazySource(blocks, id) {\n      var hasMultipleOrNoChunks = false;\n      var fakeMap = this.getFakeMap(blocks.map(function (b) {\n        return b.dependencies[0];\n      }));\n      var map = blocks.filter(function (block) {\n        return block.dependencies[0].module;\n      }).map(function (block) {\n        return {\n          dependency: block.dependencies[0],\n          block: block,\n          userRequest: block.dependencies[0].userRequest\n        };\n      }).sort(function (a, b) {\n        if (a.userRequest === b.userRequest) return 0;\n        return a.userRequest < b.userRequest ? -1 : 1;\n      }).reduce(function (map, item) {\n        var chunks = item.block.chunkGroup && item.block.chunkGroup.chunks || [];\n        if (chunks.length !== 1) {\n          hasMultipleOrNoChunks = true;\n        }\n        var arrayStart = [item.dependency.module.id];\n        if (typeof fakeMap === \"object\") {\n          arrayStart.push(fakeMap[item.dependency.module.id]);\n        }\n        map[item.userRequest] = arrayStart.concat(chunks.map(function (chunk) {\n          return chunk.id;\n        }));\n        return map;\n      }, Object.create(null));\n      var chunksStartPosition = typeof fakeMap === \"object\" ? 2 : 1;\n      var requestPrefix = hasMultipleOrNoChunks ? \"Promise.all(ids.slice(\".concat(chunksStartPosition, \").map(__webpack_require__.e))\") : \"__webpack_require__.e(ids[\".concat(chunksStartPosition, \"])\");\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap, \"ids[1]\");\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\nfunction webpackAsyncContext(req) {\\n\\tvar ids = map[req];\\n\\tif(!ids) {\\n\\t\\treturn Promise.resolve().then(function() {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t});\\n\\t}\\n\\treturn \").concat(requestPrefix, \".then(function() {\\n\\t\\tvar id = ids[0];\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getSourceForEmptyContext\",\n    value: function getSourceForEmptyContext(id) {\n      return \"function webpackEmptyContext(req) {\\n\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\te.code = 'MODULE_NOT_FOUND';\\n\\tthrow e;\\n}\\nwebpackEmptyContext.keys = function() { return []; };\\nwebpackEmptyContext.resolve = webpackEmptyContext;\\nmodule.exports = webpackEmptyContext;\\nwebpackEmptyContext.id = \".concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getSourceForEmptyAsyncContext\",\n    value: function getSourceForEmptyAsyncContext(id) {\n      return \"function webpackEmptyAsyncContext(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t});\\n}\\nwebpackEmptyAsyncContext.keys = function() { return []; };\\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\\nmodule.exports = webpackEmptyAsyncContext;\\nwebpackEmptyAsyncContext.id = \".concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getSourceString\",\n    value: function getSourceString(asyncMode, runtimeTemplate) {\n      if (asyncMode === \"lazy\") {\n        if (this.blocks && this.blocks.length > 0) {\n          return this.getLazySource(this.blocks, this.id);\n        }\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n      if (asyncMode === \"eager\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getEagerSource(this.dependencies, this.id);\n        }\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n      if (asyncMode === \"lazy-once\") {\n        var block = this.blocks[0];\n        if (block) {\n          return this.getLazyOnceSource(block, block.dependencies, this.id, runtimeTemplate);\n        }\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n      if (asyncMode === \"async-weak\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getAsyncWeakSource(this.dependencies, this.id);\n        }\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n      if (asyncMode === \"weak\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getWeakSyncSource(this.dependencies, this.id);\n        }\n      }\n      if (this.dependencies && this.dependencies.length > 0) {\n        return this.getSyncSource(this.dependencies, this.id);\n      }\n      return this.getSourceForEmptyContext(this.id);\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource(sourceString) {\n      if (this.useSourceMap) {\n        return new OriginalSource(sourceString, this.identifier());\n      }\n      return new RawSource(sourceString);\n    }\n  }, {\n    key: \"source\",\n    value: function source(dependencyTemplates, runtimeTemplate) {\n      return this.getSource(this.getSourceString(this.options.mode, runtimeTemplate));\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      // base penalty\n      var initialSize = 160;\n\n      // if we dont have dependencies we stop here.\n      return this.dependencies.reduce(function (size, dependency) {\n        var element = /** @type {ContextElementDependency} */dependency;\n        return size + 5 + element.userRequest.length;\n      }, initialSize);\n    }\n  }]);\n  return ContextModule;\n}(Module); // TODO remove in webpack 5\nObject.defineProperty(ContextModule.prototype, \"recursive\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {boolean} is recursive\n   */\n  function () {\n    return this.options.recursive;\n  }, \"ContextModule.recursive has been moved to ContextModule.options.recursive\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {boolean} value is recursive\n   * @returns {void}\n   */\n  function (value) {\n    this.options.recursive = value;\n  }, \"ContextModule.recursive has been moved to ContextModule.options.recursive\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(ContextModule.prototype, \"regExp\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {RegExp} regular expression\n   */\n  function () {\n    return this.options.regExp;\n  }, \"ContextModule.regExp has been moved to ContextModule.options.regExp\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {RegExp} value Regular expression\n   * @returns {void}\n   */\n  function (value) {\n    this.options.regExp = value;\n  }, \"ContextModule.regExp has been moved to ContextModule.options.regExp\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(ContextModule.prototype, \"addon\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {string} addon\n   */\n  function () {\n    return this.options.addon;\n  }, \"ContextModule.addon has been moved to ContextModule.options.addon\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {string} value addon\n   * @returns {void}\n   */\n  function (value) {\n    this.options.addon = value;\n  }, \"ContextModule.addon has been moved to ContextModule.options.addon\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(ContextModule.prototype, \"async\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {boolean} is async\n   */\n  function () {\n    return this.options.mode;\n  }, \"ContextModule.async has been moved to ContextModule.options.mode\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {ContextMode} value Context mode\n   * @returns {void}\n   */\n  function (value) {\n    this.options.mode = value;\n  }, \"ContextModule.async has been moved to ContextModule.options.mode\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(ContextModule.prototype, \"chunkName\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {string} chunk name\n   */\n  function () {\n    return this.options.chunkName;\n  }, \"ContextModule.chunkName has been moved to ContextModule.options.chunkName\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {string} value chunk name\n   * @returns {void}\n   */\n  function (value) {\n    this.options.chunkName = value;\n  }, \"ContextModule.chunkName has been moved to ContextModule.options.chunkName\")\n});\nmodule.exports = ContextModule;","map":null,"metadata":{},"sourceType":"script"}