{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar util = require(\"util\");\nvar DependenciesBlock = require(\"./DependenciesBlock\");\nvar ModuleReason = require(\"./ModuleReason\");\nvar SortableSet = require(\"./util/SortableSet\");\nvar Template = require(\"./Template\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./RequestShortener\")} RequestShortener */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\nvar EMPTY_RESOLVE_OPTIONS = {};\nvar debugId = 1000;\nvar sortById = function sortById(a, b) {\n  return a.id - b.id;\n};\nvar sortByDebugId = function sortByDebugId(a, b) {\n  return a.debugId - b.debugId;\n};\n\n/** @typedef {(requestShortener: RequestShortener) => string} OptimizationBailoutFunction */\nvar Module = /*#__PURE__*/function (_DependenciesBlock) {\n  _inherits(Module, _DependenciesBlock);\n  function Module(type) {\n    var _this;\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, Module);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Module).call(this));\n    /** @type {string} */\n    _this.type = type;\n    /** @type {string} */\n    _this.context = context;\n\n    // Unique Id\n    /** @type {number} */\n    _this.debugId = debugId++;\n\n    // Hash\n    /** @type {string} */\n    _this.hash = undefined;\n    /** @type {string} */\n    _this.renderedHash = undefined;\n\n    // Info from Factory\n    /** @type {TODO} */\n    _this.resolveOptions = EMPTY_RESOLVE_OPTIONS;\n    /** @type {object} */\n    _this.factoryMeta = {};\n\n    // Info from Build\n    /** @type {WebpackError[]} */\n    _this.warnings = [];\n    /** @type {WebpackError[]} */\n    _this.errors = [];\n    /** @type {object} */\n    _this.buildMeta = undefined;\n    /** @type {object} */\n    _this.buildInfo = undefined;\n\n    // Graph (per Compilation)\n    /** @type {ModuleReason[]} */\n    _this.reasons = [];\n    /** @type {SortableSet<Chunk>} */\n    _this._chunks = new SortableSet(undefined, sortById);\n\n    // Info from Compilation (per Compilation)\n    /** @type {number|string} */\n    _this.id = null;\n    /** @type {number} */\n    _this.index = null;\n    /** @type {number} */\n    _this.index2 = null;\n    /** @type {number} */\n    _this.depth = null;\n    /** @type {Module} */\n    _this.issuer = null;\n    /** @type {undefined | object} */\n    _this.profile = undefined;\n    /** @type {boolean} */\n    _this.prefetched = false;\n    /** @type {boolean} */\n    _this.built = false;\n\n    // Info from Optimization (per Compilation)\n    /** @type {null | boolean} */\n    _this.used = null;\n    /** @type {false | true | string[]} */\n    _this.usedExports = null;\n    /** @type {(string | OptimizationBailoutFunction)[]} */\n    _this.optimizationBailout = [];\n\n    // delayed operations\n    /** @type {undefined | {oldChunk: Chunk, newChunks: Chunk[]}[] } */\n    _this._rewriteChunkInReasons = undefined;\n\n    /** @type {boolean} */\n    _this.useSourceMap = false;\n\n    // info from build\n    _this._source = null;\n    return _this;\n  }\n  _createClass(Module, [{\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.hash = undefined;\n      this.renderedHash = undefined;\n      this.reasons.length = 0;\n      this._rewriteChunkInReasons = undefined;\n      this._chunks.clear();\n      this.id = null;\n      this.index = null;\n      this.index2 = null;\n      this.depth = null;\n      this.issuer = null;\n      this.profile = undefined;\n      this.prefetched = false;\n      this.built = false;\n      this.used = null;\n      this.usedExports = null;\n      this.optimizationBailout.length = 0;\n      _get(_getPrototypeOf(Module.prototype), \"disconnect\", this).call(this);\n    }\n  }, {\n    key: \"unseal\",\n    value: function unseal() {\n      this.id = null;\n      this.index = null;\n      this.index2 = null;\n      this.depth = null;\n      this._chunks.clear();\n      _get(_getPrototypeOf(Module.prototype), \"unseal\", this).call(this);\n    }\n  }, {\n    key: \"setChunks\",\n    value: function setChunks(chunks) {\n      this._chunks = new SortableSet(chunks, sortById);\n    }\n  }, {\n    key: \"addChunk\",\n    value: function addChunk(chunk) {\n      if (this._chunks.has(chunk)) return false;\n      this._chunks.add(chunk);\n      return true;\n    }\n  }, {\n    key: \"removeChunk\",\n    value: function removeChunk(chunk) {\n      if (this._chunks.delete(chunk)) {\n        chunk.removeModule(this);\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"isInChunk\",\n    value: function isInChunk(chunk) {\n      return this._chunks.has(chunk);\n    }\n  }, {\n    key: \"isEntryModule\",\n    value: function isEntryModule() {\n      var _iterator = _createForOfIteratorHelper(this._chunks),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var chunk = _step.value;\n          if (chunk.entryModule === this) return true;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"getChunks\",\n    /**\n     * @returns {Chunk[]} all chunks which contain the module\n     */\n    value: function getChunks() {\n      return Array.from(this._chunks);\n    }\n  }, {\n    key: \"getNumberOfChunks\",\n    value: function getNumberOfChunks() {\n      return this._chunks.size;\n    }\n  }, {\n    key: \"hasEqualsChunks\",\n    value: function hasEqualsChunks(otherModule) {\n      if (this._chunks.size !== otherModule._chunks.size) return false;\n      this._chunks.sortWith(sortByDebugId);\n      otherModule._chunks.sortWith(sortByDebugId);\n      var a = this._chunks[Symbol.iterator]();\n      var b = otherModule._chunks[Symbol.iterator]();\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        var aItem = a.next();\n        var bItem = b.next();\n        if (aItem.done) return true;\n        if (aItem.value !== bItem.value) return false;\n      }\n    }\n  }, {\n    key: \"addReason\",\n    value: function addReason(module, dependency, explanation) {\n      this.reasons.push(new ModuleReason(module, dependency, explanation));\n    }\n  }, {\n    key: \"removeReason\",\n    value: function removeReason(module, dependency) {\n      for (var i = 0; i < this.reasons.length; i++) {\n        var r = this.reasons[i];\n        if (r.module === module && r.dependency === dependency) {\n          this.reasons.splice(i, 1);\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"hasReasonForChunk\",\n    value: function hasReasonForChunk(chunk) {\n      if (this._rewriteChunkInReasons) {\n        var _iterator2 = _createForOfIteratorHelper(this._rewriteChunkInReasons),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var operation = _step2.value;\n            this._doRewriteChunkInReasons(operation.oldChunk, operation.newChunks);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        this._rewriteChunkInReasons = undefined;\n      }\n      for (var i = 0; i < this.reasons.length; i++) {\n        if (this.reasons[i].hasChunk(chunk)) return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"hasReasons\",\n    value: function hasReasons() {\n      return this.reasons.length > 0;\n    }\n  }, {\n    key: \"rewriteChunkInReasons\",\n    value: function rewriteChunkInReasons(oldChunk, newChunks) {\n      // This is expensive. Delay operation until we really need the data\n      if (this._rewriteChunkInReasons === undefined) {\n        this._rewriteChunkInReasons = [];\n      }\n      this._rewriteChunkInReasons.push({\n        oldChunk: oldChunk,\n        newChunks: newChunks\n      });\n    }\n  }, {\n    key: \"_doRewriteChunkInReasons\",\n    value: function _doRewriteChunkInReasons(oldChunk, newChunks) {\n      for (var i = 0; i < this.reasons.length; i++) {\n        this.reasons[i].rewriteChunks(oldChunk, newChunks);\n      }\n    }\n  }, {\n    key: \"isUsed\",\n    value: function isUsed(exportName) {\n      if (!exportName) return this.used !== false;\n      if (this.used === null || this.usedExports === null) return exportName;\n      if (!this.used) return false;\n      if (!this.usedExports) return false;\n      if (this.usedExports === true) return exportName;\n      var idx = this.usedExports.indexOf(exportName);\n      if (idx < 0) return false;\n\n      // Mangle export name if possible\n      if (this.isProvided(exportName)) {\n        if (this.buildMeta.exportsType === \"namespace\") {\n          return Template.numberToIdentifer(idx);\n        }\n        if (this.buildMeta.exportsType === \"named\" && !this.usedExports.includes(\"default\")) {\n          return Template.numberToIdentifer(idx);\n        }\n      }\n      return exportName;\n    }\n  }, {\n    key: \"isProvided\",\n    value: function isProvided(exportName) {\n      if (!Array.isArray(this.buildMeta.providedExports)) return null;\n      return this.buildMeta.providedExports.includes(exportName);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Module[\".concat(this.id || this.debugId, \"]\");\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      return true;\n    }\n    /**\n     * @param {Hash} hash the hash used to track dependencies\n     * @returns {void}\n     */\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"\".concat(this.id));\n      hash.update(JSON.stringify(this.usedExports));\n      _get(_getPrototypeOf(Module.prototype), \"updateHash\", this).call(this, hash);\n    }\n  }, {\n    key: \"sortItems\",\n    value: function sortItems(sortChunks) {\n      _get(_getPrototypeOf(Module.prototype), \"sortItems\", this).call(this);\n      if (sortChunks) this._chunks.sort();\n      this.reasons.sort(function (a, b) {\n        if (a.module === b.module) return 0;\n        if (!a.module) return -1;\n        if (!b.module) return 1;\n        return sortById(a.module, b.module);\n      });\n      if (Array.isArray(this.usedExports)) {\n        this.usedExports.sort();\n      }\n    }\n  }, {\n    key: \"unbuild\",\n    value: function unbuild() {\n      this.dependencies.length = 0;\n      this.blocks.length = 0;\n      this.variables.length = 0;\n      this.buildMeta = undefined;\n      this.buildInfo = undefined;\n      this.disconnect();\n    }\n  }, {\n    key: \"exportsArgument\",\n    get: function get() {\n      return this.buildInfo && this.buildInfo.exportsArgument || \"exports\";\n    }\n  }, {\n    key: \"moduleArgument\",\n    get: function get() {\n      return this.buildInfo && this.buildInfo.moduleArgument || \"module\";\n    }\n  }, {\n    key: \"optional\",\n    get: function get() {\n      return this.reasons.length > 0 && this.reasons.every(function (r) {\n        return r.dependency && r.dependency.optional;\n      });\n    }\n  }, {\n    key: \"chunksIterable\",\n    get: function get() {\n      return this._chunks;\n    }\n  }, {\n    key: \"arguments\",\n    get: function get() {\n      throw new Error(\"Module.arguments was removed, there is no replacement.\");\n    },\n    set: function set(value) {\n      throw new Error(\"Module.arguments was removed, there is no replacement.\");\n    }\n  }]);\n  return Module;\n}(DependenciesBlock); // TODO remove in webpack 5\nObject.defineProperty(Module.prototype, \"forEachChunk\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {function(any, any, Set<any>): void} fn callback function\n   * @returns {void}\n   * @this {Module}\n   */\n  function (fn) {\n    this._chunks.forEach(fn);\n  }, \"Module.forEachChunk: Use for(const chunk of module.chunksIterable) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Module.prototype, \"mapChunks\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {function(any, any): void} fn Mapper function\n   * @returns {Array<TODO>} Array of chunks mapped\n   * @this {Module}\n   */\n  function (fn) {\n    return Array.from(this._chunks, fn);\n  }, \"Module.mapChunks: Use Array.from(module.chunksIterable, fn) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Module.prototype, \"entry\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Module.entry was removed. Use Chunk.entryModule\");\n  },\n  set: function set() {\n    throw new Error(\"Module.entry was removed. Use Chunk.entryModule\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Module.prototype, \"meta\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @returns {void}\n   * @this {Module}\n   */\n  function () {\n    return this.buildMeta;\n  }, \"Module.meta was renamed to Module.buildMeta\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} value Value\n   * @returns {void}\n   * @this {Module}\n   */\n  function (value) {\n    this.buildMeta = value;\n  }, \"Module.meta was renamed to Module.buildMeta\")\n});\n\n/** @type {function(): string} */\nModule.prototype.identifier = null;\n\n/** @type {function(RequestShortener): string} */\nModule.prototype.readableIdentifier = null;\nModule.prototype.build = null;\nModule.prototype.source = null;\nModule.prototype.size = null;\nModule.prototype.nameForCondition = null;\n/** @type {null | function(Chunk): boolean} */\nModule.prototype.chunkCondition = null;\nModule.prototype.updateCacheModule = null;\nmodule.exports = Module;","map":null,"metadata":{},"sourceType":"script"}