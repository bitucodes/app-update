{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar he = require('he');\nvar _require = require('./helper'),\n  get = _require.get,\n  numberToLetterSequence = _require.numberToLetterSequence,\n  numberToRoman = _require.numberToRoman,\n  splitClassesAndIds = _require.splitClassesAndIds,\n  trimCharacter = _require.trimCharacter; // eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip(elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline(elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak(elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbk` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr(elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(function (str) {\n      return str.toUpperCase();\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: function blockTransform(str) {\n      return (formatOptions.trimEmptyLines !== false ? trimCharacter(str, '\\n') : str).split('\\n').map(function (line) {\n        return '> ' + line;\n      }).join('\\n');\n    }\n  });\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage(elem, walk, builder, formatOptions) {\n  var attribs = elem.attribs || {};\n  var alt = attribs.alt ? he.decode(attribs.alt, builder.options.decodeOptions) : '';\n  var src = !attribs.src ? '' : formatOptions.baseUrl && attribs.src.indexOf('/') === 0 ? formatOptions.baseUrl + attribs.src : attribs.src;\n  var text = !src ? alt : !alt ? '[' + src + ']' : alt + ' [' + src + ']';\n  builder.addInline(text);\n}\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor(elem, walk, builder, formatOptions) {\n  function getHref() {\n    if (formatOptions.ignoreHref) {\n      return '';\n    }\n    if (!elem.attribs || !elem.attribs.href) {\n      return '';\n    }\n    var href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') {\n      return '';\n    }\n    href = formatOptions.baseUrl && href[0] === '/' ? formatOptions.baseUrl + href : href;\n    return he.decode(href, builder.options.decodeOptions);\n  }\n  var href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    var text = '';\n    builder.pushWordTransform(function (str) {\n      if (str) {\n        text += str;\n      }\n      return str;\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n    var hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(!text ? href : formatOptions.noLinkBrackets ? ' ' + href : ' [' + href + ']', {\n        noWordTransform: true\n      });\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns inreasing index each time it is called.\n */\nfunction formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n  var isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  var maxPrefixLength = 0;\n  var listItems = (elem.children || []\n  // it might be more accuurate to check only for html spaces here, but no significant benefit\n  ).filter(function (child) {\n    return child.type !== 'text' || !/^\\s*$/.test(child.data);\n  }).map(function (child) {\n    if (child.name !== 'li') {\n      return {\n        node: child,\n        prefix: ''\n      };\n    }\n    var prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n    if (prefix.length > maxPrefixLength) {\n      maxPrefixLength = prefix.length;\n    }\n    return {\n      node: child,\n      prefix: prefix\n    };\n  });\n  if (!listItems.length) {\n    return;\n  }\n  var reservedLineLength = maxPrefixLength;\n  var spacing = '\\n' + ' '.repeat(reservedLineLength);\n  builder.openBlock({\n    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2\n  });\n  var _iterator = _createForOfIteratorHelper(listItems),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var _step$value = _step.value,\n        node = _step$value.node,\n        prefix = _step$value.prefix;\n      builder.openBlock({\n        leadingLineBreaks: 1,\n        reservedLineLength: reservedLineLength\n      });\n      walk([node], builder);\n      builder.closeBlock({\n        trailingLineBreaks: 1,\n        blockTransform: function blockTransform(str) {\n          return prefix + ' '.repeat(reservedLineLength - prefix.length) + str.replace(/\\n/g, spacing);\n        }\n      });\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  builder.closeBlock({\n    trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList(elem, walk, builder, formatOptions) {\n  var prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, function () {\n    return prefix;\n  });\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList(elem, walk, builder, formatOptions) {\n  var nextIndex = Number(elem.attribs.start || '1');\n  var indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  var nextPrefixCallback = function nextPrefixCallback() {\n    return ' ' + indexFunction(nextIndex++) + '. ';\n  };\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction() {\n  var olType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '1';\n  switch (olType) {\n    case 'a':\n      return function (i) {\n        return numberToLetterSequence(i, 'a');\n      };\n    case 'A':\n      return function (i) {\n        return numberToLetterSequence(i, 'A');\n      };\n    case 'i':\n      return function (i) {\n        return numberToRoman(i).toLowerCase();\n      };\n    case 'I':\n      return function (i) {\n        return numberToRoman(i);\n      };\n    case '1':\n    default:\n      return function (i) {\n        return i.toString();\n      };\n  }\n}\nfunction isDataTable(attr, tables) {\n  if (tables === true) {\n    return true;\n  }\n  if (!attr) {\n    return false;\n  }\n  var _splitClassesAndIds = splitClassesAndIds(tables),\n    classes = _splitClassesAndIds.classes,\n    ids = _splitClassesAndIds.ids;\n  var attrClasses = (attr['class'] || '').split(' ');\n  var attrIds = (attr['id'] || '').split(' ');\n  return attrClasses.some(function (x) {\n    return classes.includes(x);\n  }) || attrIds.some(function (x) {\n    return ids.includes(x);\n  });\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable(elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable(elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    colSpacing: formatOptions.colSpacing,\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    rowSpacing: formatOptions.rowSpacing,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n  function formatCell(cellNode) {\n    var colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    var rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({\n      maxColumnWidth: formatOptions.maxColumnWidth\n    });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({\n      colspan: colspan,\n      rowspan: rowspan\n    });\n  }\n  function walkTable(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n    var formatHeaderCell = formatOptions.uppercaseHeaderCells ? function (cellNode) {\n      builder.pushWordTransform(function (str) {\n        return str.toUpperCase();\n      });\n      formatCell(cellNode);\n      builder.popWordTransform();\n    } : formatCell;\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n      case 'tr':\n        {\n          builder.openTableRow();\n          var _iterator2 = _createForOfIteratorHelper(elem.children),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var childOfTr = _step2.value;\n              if (childOfTr.type !== 'tag') {\n                continue;\n              }\n              switch (childOfTr.name) {\n                case 'th':\n                  {\n                    formatHeaderCell(childOfTr);\n                    break;\n                  }\n                case 'td':\n                  {\n                    formatCell(childOfTr);\n                    break;\n                  }\n                default:\n                // do nothing\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          builder.closeTableRow();\n          break;\n        }\n      default:\n      // do nothing\n    }\n  }\n}\n\nmodule.exports = {\n  anchor: formatAnchor,\n  block: formatBlock,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  inline: formatInline,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  skip: formatSkip,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n};","map":null,"metadata":{},"sourceType":"script"}