{"ast":null,"code":"var mergeAdjacent = require('./merge-adjacent');\nvar mergeMediaQueries = require('./merge-media-queries');\nvar mergeNonAdjacentByBody = require('./merge-non-adjacent-by-body');\nvar mergeNonAdjacentBySelector = require('./merge-non-adjacent-by-selector');\nvar reduceNonAdjacent = require('./reduce-non-adjacent');\nvar removeDuplicateFontAtRules = require('./remove-duplicate-font-at-rules');\nvar removeDuplicateMediaQueries = require('./remove-duplicate-media-queries');\nvar removeDuplicates = require('./remove-duplicates');\nvar removeUnusedAtRules = require('./remove-unused-at-rules');\nvar restructure = require('./restructure');\nvar optimizeProperties = require('./properties/optimize');\nvar OptimizationLevel = require('../../options/optimization-level').OptimizationLevel;\nvar Token = require('../../tokenizer/token');\nfunction removeEmpty(tokens) {\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n    var isEmpty = false;\n    switch (token[0]) {\n      case Token.RULE:\n        isEmpty = token[1].length === 0 || token[2].length === 0;\n        break;\n      case Token.NESTED_BLOCK:\n        removeEmpty(token[2]);\n        isEmpty = token[2].length === 0;\n        break;\n      case Token.AT_RULE:\n        isEmpty = token[1].length === 0;\n        break;\n      case Token.AT_RULE_BLOCK:\n        isEmpty = token[2].length === 0;\n    }\n    if (isEmpty) {\n      tokens.splice(i, 1);\n      i--;\n      l--;\n    }\n  }\n}\nfunction recursivelyOptimizeBlocks(tokens, context) {\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n    if (token[0] == Token.NESTED_BLOCK) {\n      var isKeyframes = /@(-moz-|-o-|-webkit-)?keyframes/.test(token[1][0][1]);\n      level2Optimize(token[2], context, !isKeyframes);\n    }\n  }\n}\nfunction recursivelyOptimizeProperties(tokens, context) {\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n    switch (token[0]) {\n      case Token.RULE:\n        optimizeProperties(token[2], true, true, context);\n        break;\n      case Token.NESTED_BLOCK:\n        recursivelyOptimizeProperties(token[2], context);\n    }\n  }\n}\nfunction level2Optimize(tokens, context, withRestructuring) {\n  var levelOptions = context.options.level[OptimizationLevel.Two];\n  var reduced;\n  var i;\n  recursivelyOptimizeBlocks(tokens, context);\n  recursivelyOptimizeProperties(tokens, context);\n  if (levelOptions.removeDuplicateRules) {\n    removeDuplicates(tokens, context);\n  }\n  if (levelOptions.mergeAdjacentRules) {\n    mergeAdjacent(tokens, context);\n  }\n  if (levelOptions.reduceNonAdjacentRules) {\n    reduceNonAdjacent(tokens, context);\n  }\n  if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'body') {\n    mergeNonAdjacentBySelector(tokens, context);\n  }\n  if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'selector') {\n    mergeNonAdjacentByBody(tokens, context);\n  }\n  if (levelOptions.restructureRules && levelOptions.mergeAdjacentRules && withRestructuring) {\n    restructure(tokens, context);\n    mergeAdjacent(tokens, context);\n  }\n  if (levelOptions.restructureRules && !levelOptions.mergeAdjacentRules && withRestructuring) {\n    restructure(tokens, context);\n  }\n  if (levelOptions.removeDuplicateFontRules) {\n    removeDuplicateFontAtRules(tokens, context);\n  }\n  if (levelOptions.removeDuplicateMediaBlocks) {\n    removeDuplicateMediaQueries(tokens, context);\n  }\n  if (levelOptions.removeUnusedAtRules) {\n    removeUnusedAtRules(tokens, context);\n  }\n  if (levelOptions.mergeMedia) {\n    reduced = mergeMediaQueries(tokens, context);\n    for (i = reduced.length - 1; i >= 0; i--) {\n      level2Optimize(reduced[i][2], context, false);\n    }\n  }\n  if (levelOptions.removeEmpty) {\n    removeEmpty(tokens);\n  }\n  return tokens;\n}\nmodule.exports = level2Optimize;","map":null,"metadata":{},"sourceType":"script"}