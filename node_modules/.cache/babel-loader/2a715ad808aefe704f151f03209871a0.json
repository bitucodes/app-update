{"ast":null,"code":"function _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { decodeInt32, decodeUInt32, MAX_NUMBER_OF_BYTE_U32, decodeInt64, decodeUInt64, MAX_NUMBER_OF_BYTE_U64 } from \"@webassemblyjs/leb128\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\nfunction toHex(n) {\n  return \"0x\" + Number(n).toString(16);\n}\nfunction byteArrayEq(l, r) {\n  if (l.length !== r.length) {\n    return false;\n  }\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== r[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function decode(ab, opts) {\n  var buf = new Uint8Array(ab);\n  var getUniqueName = t.getUniqueNameGenerator();\n  var offset = 0;\n  function getPosition() {\n    return {\n      line: -1,\n      column: offset\n    };\n  }\n  function dump(b, msg) {\n    if (opts.dump === false) return;\n    var pad = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n    var str = \"\";\n    if (b.length < 5) {\n      str = b.map(toHex).join(\" \");\n    } else {\n      str = \"...\";\n    }\n    console.log(toHex(offset) + \":\\t\", str, pad, \";\", msg);\n  }\n  function dumpSep(msg) {\n    if (opts.dump === false) return;\n    console.log(\";\", msg);\n  }\n  /**\n   * TODO(sven): we can atually use a same structure\n   * we are adding incrementally new features\n   */\n\n  var state = {\n    elementsInFuncSection: [],\n    elementsInExportSection: [],\n    elementsInCodeSection: [],\n    /**\n     * Decode memory from:\n     * - Memory section\n     */\n    memoriesInModule: [],\n    /**\n     * Decoded types from:\n     * - Type section\n     */\n    typesInModule: [],\n    /**\n     * Decoded functions from:\n     * - Function section\n     * - Import section\n     */\n    functionsInModule: [],\n    /**\n     * Decoded tables from:\n     * - Table section\n     */\n    tablesInModule: [],\n    /**\n     * Decoded globals from:\n     * - Global section\n     */\n    globalsInModule: []\n  };\n  function isEOF() {\n    return offset >= buf.length;\n  }\n  function eatBytes(n) {\n    offset = offset + n;\n  }\n  function readBytesAtOffset(_offset, numberOfBytes) {\n    var arr = [];\n    for (var i = 0; i < numberOfBytes; i++) {\n      arr.push(buf[_offset + i]);\n    }\n    return arr;\n  }\n  function readBytes(numberOfBytes) {\n    return readBytesAtOffset(offset, numberOfBytes);\n  }\n  function readF64() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);\n    var value = ieee754.decodeF64(bytes);\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F64\n    };\n  }\n  function readF32() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);\n    var value = ieee754.decodeF32(bytes);\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F32\n    };\n  }\n  function readUTF8String() {\n    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using\n    // readBytesAtOffset below. This keeps readUTF8String neutral with respect\n    // to the current offset, just like the other readX functions.\n\n    var strlen = lenu32.value;\n    dump([strlen], \"string length\");\n    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);\n    var value = utf8.decode(bytes);\n    return {\n      value: value,\n      nextIndex: strlen + lenu32.nextIndex\n    };\n  }\n  /**\n   * Decode an unsigned 32bits integer\n   *\n   * The length will be handled by the leb librairy, we pass the max number of\n   * byte.\n   */\n\n  function readU32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n  function readVaruint32() {\n    // where 32 bits = max 4 bytes\n    var bytes = readBytes(4);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n  function readVaruint7() {\n    // where 7 bits = max 1 bytes\n    var bytes = readBytes(1);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n  /**\n   * Decode a signed 32bits interger\n   */\n\n  function read32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return decodeInt32(buffer);\n  }\n  /**\n   * Decode a signed 64bits integer\n   */\n\n  function read64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return decodeInt64(buffer);\n  }\n  function readU64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt64(buffer);\n  }\n  function readByte() {\n    return readBytes(1)[0];\n  }\n  function parseModuleHeader() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n    var header = readBytes(4);\n    if (byteArrayEq(constants.magicModuleHeader, header) === false) {\n      throw new CompileError(\"magic header not detected\");\n    }\n    dump(header, \"wasm magic header\");\n    eatBytes(4);\n  }\n  function parseVersion() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n    var version = readBytes(4);\n    if (byteArrayEq(constants.moduleVersion, version) === false) {\n      throw new CompileError(\"unknown binary version\");\n    }\n    dump(version, \"wasm version\");\n    eatBytes(4);\n  }\n  function parseVec(cast) {\n    var u32 = readU32();\n    var length = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([length], \"number\");\n    if (length === 0) {\n      return [];\n    }\n    var elements = [];\n    for (var i = 0; i < length; i++) {\n      var byte = readByte();\n      eatBytes(1);\n      var value = cast(byte);\n      dump([byte], value);\n      if (typeof value === \"undefined\") {\n        throw new CompileError(\"Internal failure: parseVec could not cast the value\");\n      }\n      elements.push(value);\n    }\n    return elements;\n  } // Type section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec\n\n  function parseTypeSection(numberOfTypes) {\n    var typeInstructionNodes = [];\n    dump([numberOfTypes], \"num types\");\n    for (var i = 0; i < numberOfTypes; i++) {\n      var startLoc = getPosition();\n      dumpSep(\"type \" + i);\n      var type = readByte();\n      eatBytes(1);\n      if (type == constants.types.func) {\n        dump([type], \"func\");\n        var paramValtypes = parseVec(function (b) {\n          return constants.valtypes[b];\n        });\n        var params = paramValtypes.map(function (v) {\n          return t.funcParam( /*valtype*/\n          v);\n        });\n        var result = parseVec(function (b) {\n          return constants.valtypes[b];\n        });\n        var endLoc = getPosition();\n        typeInstructionNodes.push(t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, startLoc));\n        state.typesInModule.push({\n          params: params,\n          result: result\n        });\n      } else {\n        throw new Error(\"Unsupported type: \" + toHex(type));\n      }\n    }\n    return typeInstructionNodes;\n  } // Import section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec\n\n  function parseImportSection(numberOfImports) {\n    var imports = [];\n    for (var i = 0; i < numberOfImports; i++) {\n      dumpSep(\"import header \" + i);\n      var startLoc = getPosition();\n      /**\n       * Module name\n       */\n\n      var moduleName = readUTF8String();\n      eatBytes(moduleName.nextIndex);\n      dump([], \"module name (\".concat(moduleName.value, \")\"));\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"name (\".concat(name.value, \")\"));\n      /**\n       * Import descr\n       */\n\n      var descrTypeByte = readByte();\n      eatBytes(1);\n      var descrType = constants.importTypes[descrTypeByte];\n      dump([descrTypeByte], \"import kind\");\n      if (typeof descrType === \"undefined\") {\n        throw new CompileError(\"Unknown import description type: \" + toHex(descrTypeByte));\n      }\n      var importDescr = void 0;\n      if (descrType === \"func\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n        }\n        var id = getUniqueName(\"func\");\n        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));\n        state.functionsInModule.push({\n          id: t.identifier(name.value),\n          signature: signature,\n          isExternal: true\n        });\n      } else if (descrType === \"global\") {\n        importDescr = parseGlobalType();\n        var globalNode = t.global(importDescr, []);\n        state.globalsInModule.push(globalNode);\n      } else if (descrType === \"table\") {\n        importDescr = parseTableType(i);\n      } else if (descrType === \"mem\") {\n        var memoryNode = parseMemoryType(0);\n        state.memoriesInModule.push(memoryNode);\n        importDescr = memoryNode;\n      } else {\n        throw new CompileError(\"Unsupported import of type: \" + descrType);\n      }\n      var endLoc = getPosition();\n      imports.push(t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, startLoc));\n    }\n    return imports;\n  } // Function section\n  // https://webassembly.github.io/spec/binary/modules.html#function-section\n\n  function parseFuncSection(numberOfFunctions) {\n    dump([numberOfFunctions], \"num funcs\");\n    for (var i = 0; i < numberOfFunctions; i++) {\n      var indexU32 = readU32();\n      var typeindex = indexU32.value;\n      eatBytes(indexU32.nextIndex);\n      dump([typeindex], \"type index\");\n      var signature = state.typesInModule[typeindex];\n      if (typeof signature === \"undefined\") {\n        throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n      } // preserve anonymous, a name might be resolved later\n\n      var id = t.withRaw(t.identifier(getUniqueName(\"func\")), \"\");\n      state.functionsInModule.push({\n        id: id,\n        signature: signature,\n        isExternal: false\n      });\n    }\n  } // Export section\n  // https://webassembly.github.io/spec/binary/modules.html#export-section\n\n  function parseExportSection(numberOfExport) {\n    dump([numberOfExport], \"num exports\"); // Parse vector of exports\n\n    for (var i = 0; i < numberOfExport; i++) {\n      var startLoc = getPosition();\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"export name (\".concat(name.value, \")\"));\n      /**\n       * exportdescr\n       */\n\n      var typeIndex = readByte();\n      eatBytes(1);\n      dump([typeIndex], \"export kind\");\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      dump([index], \"export index\");\n      var id = void 0,\n        signature = void 0;\n      if (constants.exportTypes[typeIndex] === \"Func\") {\n        var func = state.functionsInModule[index];\n        if (typeof func === \"undefined\") {\n          throw new CompileError(\"entry not found at index \".concat(index, \" in function section\"));\n        }\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = func.signature;\n      } else if (constants.exportTypes[typeIndex] === \"Table\") {\n        var table = state.tablesInModule[index];\n        if (typeof table === \"undefined\") {\n          throw new CompileError(\"entry not found at index \".concat(index, \" in table section\"));\n        }\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Mem\") {\n        var memNode = state.memoriesInModule[index];\n        if (typeof memNode === \"undefined\") {\n          throw new CompileError(\"entry not found at index \".concat(index, \" in memory section\"));\n        }\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Global\") {\n        var global = state.globalsInModule[index];\n        if (typeof global === \"undefined\") {\n          throw new CompileError(\"entry not found at index \".concat(index, \" in global section\"));\n        }\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else {\n        console.warn(\"Unsupported export type: \" + toHex(typeIndex));\n        return;\n      }\n      var endLoc = getPosition();\n      state.elementsInExportSection.push({\n        name: name.value,\n        type: constants.exportTypes[typeIndex],\n        signature: signature,\n        id: id,\n        index: index,\n        endLoc: endLoc,\n        startLoc: startLoc\n      });\n    }\n  } // Code section\n  // https://webassembly.github.io/spec/binary/modules.html#code-section\n\n  function parseCodeSection(numberOfFuncs) {\n    dump([numberOfFuncs], \"number functions\"); // Parse vector of function\n\n    for (var i = 0; i < numberOfFuncs; i++) {\n      var startLoc = getPosition();\n      dumpSep(\"function body \" + i); // the u32 size of the function code in bytes\n      // Ignore it for now\n\n      var bodySizeU32 = readU32();\n      eatBytes(bodySizeU32.nextIndex);\n      dump([bodySizeU32.value], \"function body size\");\n      var code = [];\n      /**\n       * Parse locals\n       */\n\n      var funcLocalNumU32 = readU32();\n      var funcLocalNum = funcLocalNumU32.value;\n      eatBytes(funcLocalNumU32.nextIndex);\n      dump([funcLocalNum], \"num locals\");\n      var locals = [];\n      for (var _i = 0; _i < funcLocalNum; _i++) {\n        var localCountU32 = readU32();\n        var localCount = localCountU32.value;\n        eatBytes(localCountU32.nextIndex);\n        dump([localCount], \"num local\");\n        var valtypeByte = readByte();\n        eatBytes(1);\n        var type = constants.valtypes[valtypeByte];\n        locals.push(type);\n        dump([valtypeByte], type);\n        if (typeof type === \"undefined\") {\n          throw new CompileError(\"Unexpected valtype: \" + toHex(valtypeByte));\n        }\n      } // Decode instructions until the end\n\n      parseInstructionBlock(code);\n      code.unshift.apply(code, _toConsumableArray(locals.map(function (l) {\n        return t.instruction(\"local\", [t.valtypeLiteral(l)]);\n      })));\n      var endLoc = getPosition();\n      state.elementsInCodeSection.push({\n        code: code,\n        locals: locals,\n        endLoc: endLoc,\n        startLoc: startLoc,\n        bodySize: bodySizeU32.value\n      });\n    }\n  }\n  function parseInstructionBlock(code) {\n    while (true) {\n      var startLoc = getPosition();\n      var instructionAlreadyCreated = false;\n      var instructionByte = readByte();\n      eatBytes(1);\n      if (instructionByte === 0xfe) {\n        throw new CompileError(\"Atomic instructions are not implemented\");\n      }\n      var instruction = constants.symbolsByByte[instructionByte];\n      if (typeof instruction === \"undefined\") {\n        throw new CompileError(\"Unexpected instruction: \" + toHex(instructionByte));\n      }\n      if (typeof instruction.object === \"string\") {\n        dump([instructionByte], \"\".concat(instruction.object, \".\").concat(instruction.name));\n      } else {\n        dump([instructionByte], instruction.name);\n      }\n      /**\n       * End of the function\n       */\n\n      if (instruction.name === \"end\") {\n        break;\n      }\n      var args = [];\n      if (instruction.name === \"loop\") {\n        var blocktypeByte = readByte();\n        eatBytes(1);\n        var blocktype = constants.blockTypes[blocktypeByte];\n        dump([blocktypeByte], \"blocktype\");\n        if (typeof blocktype === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(blocktypeByte));\n        }\n        var instr = [];\n        parseInstructionBlock(instr); // preserve anonymous\n\n        var label = t.withRaw(t.identifier(getUniqueName(\"loop\")), \"\");\n        var loopNode = t.loopInstruction(label, blocktype, instr);\n        code.push(loopNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"if\") {\n        var _blocktypeByte = readByte();\n        eatBytes(1);\n        var _blocktype = constants.blockTypes[_blocktypeByte];\n        dump([_blocktypeByte], \"blocktype\");\n        if (typeof _blocktype === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte));\n        }\n        var testIndex = t.withRaw(t.identifier(getUniqueName(\"if\")), \"\");\n        var ifBody = [];\n        parseInstructionBlock(ifBody); // Defaults to no alternate\n\n        var elseIndex = 0;\n        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {\n          var _instr = ifBody[elseIndex];\n          if (_instr.type === \"Instr\" && _instr.id === \"else\") {\n            break;\n          }\n        }\n        var consequentInstr = ifBody.slice(0, elseIndex);\n        var alternate = ifBody.slice(elseIndex + 1); // wast sugar\n\n        var testInstrs = [];\n        var ifNode = t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate);\n        code.push(ifNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"block\") {\n        var _blocktypeByte2 = readByte();\n        eatBytes(1);\n        var _blocktype2 = constants.blockTypes[_blocktypeByte2];\n        dump([_blocktypeByte2], \"blocktype\");\n        if (typeof _blocktype2 === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte2));\n        }\n        var _instr2 = [];\n        parseInstructionBlock(_instr2); // preserve anonymous\n\n        var _label = t.withRaw(t.identifier(getUniqueName(\"block\")), \"\");\n        var blockNode = t.blockInstruction(_label, _instr2, _blocktype2);\n        code.push(blockNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call\") {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n        var callNode = t.callInstruction(t.indexLiteral(index));\n        code.push(callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call_indirect\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"call_indirect signature not found (\".concat(typeindex, \")\"));\n        }\n        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);\n        var flagU32 = readU32();\n        var flag = flagU32.value; // 0x00 - reserved byte\n\n        eatBytes(flagU32.nextIndex);\n        if (flag !== 0) {\n          throw new CompileError(\"zero flag expected\");\n        }\n        code.push(_callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"br_table\") {\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n        for (var i = 0; i <= indices; i++) {\n          var _indexu = readU32();\n          var _index = _indexu.value;\n          eatBytes(_indexu.nextIndex);\n          dump([_index], \"index\");\n          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), \"u32\"));\n        }\n      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {\n        /**\n         * Memory instructions\n         */\n        if (instruction.name === \"grow_memory\" || instruction.name === \"current_memory\") {\n          var _indexU = readU32();\n          var _index2 = _indexU.value;\n          eatBytes(_indexU.nextIndex);\n          if (_index2 !== 0) {\n            throw new Error(\"zero flag expected\");\n          }\n          dump([_index2], \"index\");\n        } else {\n          var aligun32 = readU32();\n          var align = aligun32.value;\n          eatBytes(aligun32.nextIndex);\n          dump([align], \"align\");\n          var offsetu32 = readU32();\n          var _offset2 = offsetu32.value;\n          eatBytes(offsetu32.nextIndex);\n          dump([_offset2], \"offset\");\n        }\n      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {\n        /**\n         * Numeric instructions\n         */\n        if (instruction.object === \"i32\") {\n          var value32 = read32();\n          var value = value32.value;\n          eatBytes(value32.nextIndex);\n          dump([value], \"i32 value\");\n          args.push(t.numberLiteralFromRaw(value));\n        }\n        if (instruction.object === \"u32\") {\n          var valueu32 = readU32();\n          var _value = valueu32.value;\n          eatBytes(valueu32.nextIndex);\n          dump([_value], \"u32 value\");\n          args.push(t.numberLiteralFromRaw(_value));\n        }\n        if (instruction.object === \"i64\") {\n          var value64 = read64();\n          var _value2 = value64.value;\n          eatBytes(value64.nextIndex);\n          dump([Number(_value2.toString())], \"i64 value\");\n          var high = _value2.high,\n            low = _value2.low;\n          var node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: high,\n              low: low\n            }\n          };\n          args.push(node);\n        }\n        if (instruction.object === \"u64\") {\n          var valueu64 = readU64();\n          var _value3 = valueu64.value;\n          eatBytes(valueu64.nextIndex);\n          dump([Number(_value3.toString())], \"u64 value\");\n          var _high = _value3.high,\n            _low = _value3.low;\n          var _node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: _high,\n              low: _low\n            }\n          };\n          args.push(_node);\n        }\n        if (instruction.object === \"f32\") {\n          var valuef32 = readF32();\n          var _value4 = valuef32.value;\n          eatBytes(valuef32.nextIndex);\n          dump([_value4], \"f32 value\");\n          args.push(\n          // $FlowIgnore\n          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));\n        }\n        if (instruction.object === \"f64\") {\n          var valuef64 = readF64();\n          var _value5 = valuef64.value;\n          eatBytes(valuef64.nextIndex);\n          dump([_value5], \"f64 value\");\n          args.push(\n          // $FlowIgnore\n          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));\n        }\n      } else {\n        for (var _i2 = 0; _i2 < instruction.numberOfArgs; _i2++) {\n          var u32 = readU32();\n          eatBytes(u32.nextIndex);\n          dump([u32.value], \"argument \" + _i2);\n          args.push(t.numberLiteralFromRaw(u32.value));\n        }\n      }\n      if (instructionAlreadyCreated === false) {\n        if (typeof instruction.object === \"string\") {\n          code.push(t.objectInstruction(instruction.name, instruction.object, args));\n        } else {\n          var endLoc = getPosition();\n          var _node2 = t.withLoc(t.instruction(instruction.name, args), endLoc, startLoc);\n          code.push(_node2);\n        }\n      }\n    }\n  } // https://webassembly.github.io/spec/core/binary/types.html#limits\n\n  function parseLimits() {\n    var limitType = readByte();\n    eatBytes(1);\n    dump([limitType], \"limit type\");\n    var min, max;\n    if (limitType === 0x01 || limitType === 0x03 // shared limits\n    ) {\n      var u32min = readU32();\n      min = parseInt(u32min.value);\n      eatBytes(u32min.nextIndex);\n      dump([min], \"min\");\n      var u32max = readU32();\n      max = parseInt(u32max.value);\n      eatBytes(u32max.nextIndex);\n      dump([max], \"max\");\n    }\n    if (limitType === 0x00) {\n      var _u32min = readU32();\n      min = parseInt(_u32min.value);\n      eatBytes(_u32min.nextIndex);\n      dump([min], \"min\");\n    }\n    return t.limit(min, max);\n  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype\n\n  function parseTableType(index) {\n    var name = t.withRaw(t.identifier(getUniqueName(\"table\")), String(index));\n    var elementTypeByte = readByte();\n    eatBytes(1);\n    dump([elementTypeByte], \"element type\");\n    var elementType = constants.tableTypes[elementTypeByte];\n    if (typeof elementType === \"undefined\") {\n      throw new CompileError(\"Unknown element type in table: \" + toHex(elementType));\n    }\n    var limits = parseLimits();\n    return t.table(elementType, limits, name);\n  } // https://webassembly.github.io/spec/binary/types.html#global-types\n\n  function parseGlobalType() {\n    var valtypeByte = readByte();\n    eatBytes(1);\n    var type = constants.valtypes[valtypeByte];\n    dump([valtypeByte], type);\n    if (typeof type === \"undefined\") {\n      throw new CompileError(\"Unknown valtype: \" + toHex(valtypeByte));\n    }\n    var globalTypeByte = readByte();\n    eatBytes(1);\n    var globalType = constants.globalTypes[globalTypeByte];\n    dump([globalTypeByte], \"global type (\".concat(globalType, \")\"));\n    if (typeof globalType === \"undefined\") {\n      throw new CompileError(\"Invalid mutability: \" + toHex(globalTypeByte));\n    }\n    return t.globalType(type, globalType);\n  } // function parseNameModule() {\n  //   const lenu32 = readVaruint32();\n  //   eatBytes(lenu32.nextIndex);\n  //   console.log(\"len\", lenu32);\n  //   const strlen = lenu32.value;\n  //   dump([strlen], \"string length\");\n  //   const bytes = readBytes(strlen);\n  //   eatBytes(strlen);\n  //   const value = utf8.decode(bytes);\n  //   return [t.moduleNameMetadata(value)];\n  // }\n  // this section contains an array of function names and indices\n\n  function parseNameSectionFunctions() {\n    var functionNames = [];\n    var numberOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numberOfFunctionsu32.value;\n    eatBytes(numberOfFunctionsu32.nextIndex);\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      functionNames.push(t.functionNameMetadata(name.value, index));\n    }\n    return functionNames;\n  }\n  function parseNameSectionLocals() {\n    var localNames = [];\n    var numbeOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numbeOfFunctionsu32.value;\n    eatBytes(numbeOfFunctionsu32.nextIndex);\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var functionIndexu32 = readU32();\n      var functionIndex = functionIndexu32.value;\n      eatBytes(functionIndexu32.nextIndex);\n      var numLocalsu32 = readU32();\n      var numLocals = numLocalsu32.value;\n      eatBytes(numLocalsu32.nextIndex);\n      for (var _i3 = 0; _i3 < numLocals; _i3++) {\n        var localIndexu32 = readU32();\n        var localIndex = localIndexu32.value;\n        eatBytes(localIndexu32.nextIndex);\n        var name = readUTF8String();\n        eatBytes(name.nextIndex);\n        localNames.push(t.localNameMetadata(name.value, localIndex, functionIndex));\n      }\n    }\n    return localNames;\n  } // this is a custom section used for name resolution\n  // https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n\n  function parseNameSection(remainingBytes) {\n    var nameMetadata = [];\n    var initialOffset = offset;\n    while (offset - initialOffset < remainingBytes) {\n      // name_type\n      var sectionTypeByte = readVaruint7();\n      eatBytes(sectionTypeByte.nextIndex); // name_payload_len\n\n      var subSectionSizeInBytesu32 = readVaruint32();\n      eatBytes(subSectionSizeInBytesu32.nextIndex);\n      switch (sectionTypeByte.value) {\n        // case 0: {\n        // TODO(sven): re-enable that\n        // Current status: it seems that when we decode the module's name\n        // no name_payload_len is used.\n        //\n        // See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n        //\n        // nameMetadata.push(...parseNameModule());\n        // break;\n        // }\n        case 1:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionFunctions()));\n            break;\n          }\n        case 2:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionLocals()));\n            break;\n          }\n        default:\n          {\n            // skip unknown subsection\n            eatBytes(subSectionSizeInBytesu32.value);\n          }\n      }\n    }\n    return nameMetadata;\n  }\n  function parseGlobalSection(numberOfGlobals) {\n    var globals = [];\n    dump([numberOfGlobals], \"num globals\");\n    for (var i = 0; i < numberOfGlobals; i++) {\n      var startLoc = getPosition();\n      var globalType = parseGlobalType();\n      /**\n       * Global expressions\n       */\n\n      var init = [];\n      parseInstructionBlock(init);\n      var endLoc = getPosition();\n      var node = t.withLoc(t.global(globalType, init), endLoc, startLoc);\n      globals.push(node);\n      state.globalsInModule.push(node);\n    }\n    return globals;\n  }\n  function parseElemSection(numberOfElements) {\n    var elems = [];\n    dump([numberOfElements], \"num elements\");\n    for (var i = 0; i < numberOfElements; i++) {\n      var startLoc = getPosition();\n      var tableindexu32 = readU32();\n      var tableindex = tableindexu32.value;\n      eatBytes(tableindexu32.nextIndex);\n      dump([tableindex], \"table index\");\n      /**\n       * Parse instructions\n       */\n\n      var instr = [];\n      parseInstructionBlock(instr);\n      /**\n       * Parse ( vector function index ) *\n       */\n\n      var indicesu32 = readU32();\n      var indices = indicesu32.value;\n      eatBytes(indicesu32.nextIndex);\n      dump([indices], \"num indices\");\n      var indexValues = [];\n      for (var _i4 = 0; _i4 < indices; _i4++) {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n        indexValues.push(t.indexLiteral(index));\n      }\n      var endLoc = getPosition();\n      var elemNode = t.withLoc(t.elem(t.indexLiteral(tableindex), instr, indexValues), endLoc, startLoc);\n      elems.push(elemNode);\n    }\n    return elems;\n  } // https://webassembly.github.io/spec/core/binary/types.html#memory-types\n\n  function parseMemoryType(i) {\n    var limits = parseLimits();\n    return t.memory(limits, t.indexLiteral(i));\n  } // https://webassembly.github.io/spec/binary/modules.html#table-section\n\n  function parseTableSection(numberOfElements) {\n    var tables = [];\n    dump([numberOfElements], \"num elements\");\n    for (var i = 0; i < numberOfElements; i++) {\n      var tablesNode = parseTableType(i);\n      state.tablesInModule.push(tablesNode);\n      tables.push(tablesNode);\n    }\n    return tables;\n  } // https://webassembly.github.io/spec/binary/modules.html#memory-section\n\n  function parseMemorySection(numberOfElements) {\n    var memories = [];\n    dump([numberOfElements], \"num elements\");\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryNode = parseMemoryType(i);\n      state.memoriesInModule.push(memoryNode);\n      memories.push(memoryNode);\n    }\n    return memories;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec\n\n  function parseStartSection() {\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var startFuncIndex = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([startFuncIndex], \"index\");\n    var endLoc = getPosition();\n    return t.withLoc(t.start(t.indexLiteral(startFuncIndex)), endLoc, startLoc);\n  } // https://webassembly.github.io/spec/binary/modules.html#data-section\n\n  function parseDataSection(numberOfElements) {\n    var dataEntries = [];\n    dump([numberOfElements], \"num elements\");\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryIndexu32 = readU32();\n      var memoryIndex = memoryIndexu32.value;\n      eatBytes(memoryIndexu32.nextIndex);\n      dump([memoryIndex], \"memory index\");\n      var instrs = [];\n      parseInstructionBlock(instrs);\n      if (instrs.length !== 1) {\n        throw new CompileError(\"data section offset must be a single instruction\");\n      }\n      var bytes = parseVec(function (b) {\n        return b;\n      });\n      dump([], \"init\");\n      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));\n    }\n    return dataEntries;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-section\n\n  function parseSection(sectionIndex) {\n    var sectionId = readByte();\n    eatBytes(1);\n    if (sectionId >= sectionIndex || sectionIndex === constants.sections.custom) {\n      sectionIndex = sectionId + 1;\n    } else {\n      if (sectionId !== constants.sections.custom) throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n    }\n    var nextSectionIndex = sectionIndex;\n    var startOffset = offset;\n    var startPosition = getPosition();\n    var u32 = readU32();\n    var sectionSizeInBytes = u32.value;\n    eatBytes(u32.nextIndex);\n    var sectionSizeInBytesEndLoc = getPosition();\n    var sectionSizeInBytesNode = t.withLoc(t.numberLiteralFromRaw(sectionSizeInBytes), sectionSizeInBytesEndLoc, startPosition);\n    switch (sectionId) {\n      case constants.sections.type:\n        {\n          dumpSep(\"section Type\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition = getPosition();\n          var _u = readU32();\n          var numberOfTypes = _u.value;\n          eatBytes(_u.nextIndex);\n          var endPosition = getPosition();\n          var _metadata = t.sectionMetadata(\"type\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(numberOfTypes), endPosition, _startPosition));\n          var _nodes = parseTypeSection(numberOfTypes);\n          return {\n            nodes: _nodes,\n            metadata: _metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.table:\n        {\n          dumpSep(\"section Table\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition2 = getPosition();\n          var _u2 = readU32();\n          var numberOfTable = _u2.value;\n          eatBytes(_u2.nextIndex);\n          var _endPosition = getPosition();\n          dump([numberOfTable], \"num tables\");\n          var _metadata2 = t.sectionMetadata(\"table\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(numberOfTable), _endPosition, _startPosition2));\n          var _nodes2 = parseTableSection(numberOfTable);\n          return {\n            nodes: _nodes2,\n            metadata: _metadata2,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.import:\n        {\n          dumpSep(\"section Import\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition3 = getPosition();\n          var numberOfImportsu32 = readU32();\n          var numberOfImports = numberOfImportsu32.value;\n          eatBytes(numberOfImportsu32.nextIndex);\n          var _endPosition2 = getPosition();\n          dump([numberOfImports], \"number of imports\");\n          var _metadata3 = t.sectionMetadata(\"import\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(numberOfImports), _endPosition2, _startPosition3));\n          var _nodes3 = parseImportSection(numberOfImports);\n          return {\n            nodes: _nodes3,\n            metadata: _metadata3,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.func:\n        {\n          dumpSep(\"section Function\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition4 = getPosition();\n          var numberOfFunctionsu32 = readU32();\n          var numberOfFunctions = numberOfFunctionsu32.value;\n          eatBytes(numberOfFunctionsu32.nextIndex);\n          var _endPosition3 = getPosition();\n          var _metadata4 = t.sectionMetadata(\"func\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(numberOfFunctions), _endPosition3, _startPosition4));\n          parseFuncSection(numberOfFunctions);\n          var _nodes4 = [];\n          return {\n            nodes: _nodes4,\n            metadata: _metadata4,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.export:\n        {\n          dumpSep(\"section Export\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition5 = getPosition();\n          var _u3 = readU32();\n          var numberOfExport = _u3.value;\n          eatBytes(_u3.nextIndex);\n          var _endPosition4 = getPosition();\n          var _metadata5 = t.sectionMetadata(\"export\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(numberOfExport), _endPosition4, _startPosition5));\n          parseExportSection(numberOfExport);\n          var _nodes5 = [];\n          return {\n            nodes: _nodes5,\n            metadata: _metadata5,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.code:\n        {\n          dumpSep(\"section Code\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition6 = getPosition();\n          var _u4 = readU32();\n          var numberOfFuncs = _u4.value;\n          eatBytes(_u4.nextIndex);\n          var _endPosition5 = getPosition();\n          var _metadata6 = t.sectionMetadata(\"code\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(numberOfFuncs), _endPosition5, _startPosition6));\n          if (opts.ignoreCodeSection === true) {\n            var remainingBytes = sectionSizeInBytes - _u4.nextIndex;\n            eatBytes(remainingBytes); // eat the entire section\n          } else {\n            parseCodeSection(numberOfFuncs);\n          }\n          var _nodes6 = [];\n          return {\n            nodes: _nodes6,\n            metadata: _metadata6,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.start:\n        {\n          dumpSep(\"section Start\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata7 = t.sectionMetadata(\"start\", startOffset, sectionSizeInBytesNode);\n          var _nodes7 = [parseStartSection()];\n          return {\n            nodes: _nodes7,\n            metadata: _metadata7,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.element:\n        {\n          dumpSep(\"section Element\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition7 = getPosition();\n          var numberOfElementsu32 = readU32();\n          var numberOfElements = numberOfElementsu32.value;\n          eatBytes(numberOfElementsu32.nextIndex);\n          var _endPosition6 = getPosition();\n          var _metadata8 = t.sectionMetadata(\"element\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(numberOfElements), _endPosition6, _startPosition7));\n          var _nodes8 = parseElemSection(numberOfElements);\n          return {\n            nodes: _nodes8,\n            metadata: _metadata8,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.global:\n        {\n          dumpSep(\"section Global\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition8 = getPosition();\n          var numberOfGlobalsu32 = readU32();\n          var numberOfGlobals = numberOfGlobalsu32.value;\n          eatBytes(numberOfGlobalsu32.nextIndex);\n          var _endPosition7 = getPosition();\n          var _metadata9 = t.sectionMetadata(\"global\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(numberOfGlobals), _endPosition7, _startPosition8));\n          var _nodes9 = parseGlobalSection(numberOfGlobals);\n          return {\n            nodes: _nodes9,\n            metadata: _metadata9,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.memory:\n        {\n          dumpSep(\"section Memory\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startPosition9 = getPosition();\n          var _numberOfElementsu = readU32();\n          var _numberOfElements = _numberOfElementsu.value;\n          eatBytes(_numberOfElementsu.nextIndex);\n          var _endPosition8 = getPosition();\n          var _metadata10 = t.sectionMetadata(\"memory\", startOffset, sectionSizeInBytesNode, t.withLoc(t.numberLiteralFromRaw(_numberOfElements), _endPosition8, _startPosition9));\n          var _nodes10 = parseMemorySection(_numberOfElements);\n          return {\n            nodes: _nodes10,\n            metadata: _metadata10,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.data:\n        {\n          dumpSep(\"section Data\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata11 = t.sectionMetadata(\"data\", startOffset, sectionSizeInBytesNode);\n          var _startPosition10 = getPosition();\n          var _numberOfElementsu2 = readU32();\n          var _numberOfElements2 = _numberOfElementsu2.value;\n          eatBytes(_numberOfElementsu2.nextIndex);\n          var _endPosition9 = getPosition();\n          _metadata11.vectorOfSize = t.withLoc(t.numberLiteralFromRaw(_numberOfElements2), _endPosition9, _startPosition10);\n          if (opts.ignoreDataSection === true) {\n            var _remainingBytes = sectionSizeInBytes - _numberOfElementsu2.nextIndex;\n            eatBytes(_remainingBytes); // eat the entire section\n\n            dumpSep(\"ignore data (\" + sectionSizeInBytes + \" bytes)\");\n            return {\n              nodes: [],\n              metadata: _metadata11,\n              nextSectionIndex: nextSectionIndex\n            };\n          } else {\n            var _nodes11 = parseDataSection(_numberOfElements2);\n            return {\n              nodes: _nodes11,\n              metadata: _metadata11,\n              nextSectionIndex: nextSectionIndex\n            };\n          }\n        }\n      case constants.sections.custom:\n        {\n          dumpSep(\"section Custom\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata12 = [t.sectionMetadata(\"custom\", startOffset, sectionSizeInBytesNode)];\n          var sectionName = readUTF8String();\n          eatBytes(sectionName.nextIndex);\n          dump([], \"section name (\".concat(sectionName.value, \")\"));\n          var _remainingBytes2 = sectionSizeInBytes - sectionName.nextIndex;\n          if (sectionName.value === \"name\") {\n            try {\n              _metadata12.push.apply(_metadata12, _toConsumableArray(parseNameSection(_remainingBytes2)));\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"name\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(_remainingBytes2);\n            }\n          } else {\n            // We don't parse the custom section\n            eatBytes(_remainingBytes2);\n            dumpSep(\"ignore custom \" + JSON.stringify(sectionName.value) + \" section (\" + _remainingBytes2 + \" bytes)\");\n          }\n          return {\n            nodes: [],\n            metadata: _metadata12,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n    }\n    throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n  }\n  parseModuleHeader();\n  parseVersion();\n  var moduleFields = [];\n  var sectionIndex = 0;\n  var moduleMetadata = {\n    sections: [],\n    functionNames: [],\n    localNames: []\n  };\n  /**\n   * All the generate declaration are going to be stored in our state\n   */\n\n  while (offset < buf.length) {\n    var _parseSection = parseSection(sectionIndex),\n      _nodes12 = _parseSection.nodes,\n      _metadata13 = _parseSection.metadata,\n      nextSectionIndex = _parseSection.nextSectionIndex;\n    moduleFields.push.apply(moduleFields, _toConsumableArray(_nodes12));\n    var metadataArray = Array.isArray(_metadata13) ? _metadata13 : [_metadata13];\n    metadataArray.forEach(function (metadataItem) {\n      if (metadataItem.type === \"FunctionNameMetadata\") {\n        moduleMetadata.functionNames.push(metadataItem);\n      } else if (metadataItem.type === \"LocalNameMetadata\") {\n        moduleMetadata.localNames.push(metadataItem);\n      } else {\n        moduleMetadata.sections.push(metadataItem);\n      }\n    }); // Ignore custom section\n\n    if (nextSectionIndex) {\n      sectionIndex = nextSectionIndex;\n    }\n  }\n  /**\n   * Transform the state into AST nodes\n   */\n\n  var funcIndex = 0;\n  state.functionsInModule.forEach(function (func) {\n    var params = func.signature.params;\n    var result = func.signature.result;\n    var body = []; // External functions doesn't provide any code, can skip it here\n\n    if (func.isExternal === true) {\n      return;\n    }\n    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];\n    if (opts.ignoreCodeSection === false) {\n      if (typeof decodedElementInCodeSection === \"undefined\") {\n        throw new CompileError(\"func \" + toHex(funcIndex) + \" code not found\");\n      }\n      body = decodedElementInCodeSection.code;\n    }\n    funcIndex++;\n    var funcNode = t.func(func.id, t.signature(params, result), body);\n    if (func.isExternal === true) {\n      funcNode.isExternal = func.isExternal;\n    } // Add function position in the binary if possible\n\n    if (opts.ignoreCodeSection === false) {\n      var startLoc = decodedElementInCodeSection.startLoc,\n        endLoc = decodedElementInCodeSection.endLoc,\n        bodySize = decodedElementInCodeSection.bodySize;\n      funcNode = t.withLoc(funcNode, endLoc, startLoc);\n      funcNode.metadata = {\n        bodySize: bodySize\n      };\n    }\n    moduleFields.push(funcNode);\n  });\n  state.elementsInExportSection.forEach(function (moduleExport) {\n    /**\n     * If the export has no id, we won't be able to call it from the outside\n     * so we can omit it\n     */\n    if (moduleExport.id != null) {\n      moduleFields.push(t.withLoc(t.moduleExport(moduleExport.name, t.moduleExportDescr(moduleExport.type, moduleExport.id)), moduleExport.endLoc, moduleExport.startLoc));\n    }\n  });\n  dumpSep(\"end of program\");\n  var module = t.module(null, moduleFields, t.moduleMetadata(moduleMetadata.sections, moduleMetadata.functionNames, moduleMetadata.localNames));\n  return t.program([module]);\n}","map":null,"metadata":{},"sourceType":"module"}