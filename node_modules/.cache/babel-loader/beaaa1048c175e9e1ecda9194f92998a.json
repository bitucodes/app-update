{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar Source = require(\"./Source\");\nvar SourceNode = require(\"source-map\").SourceNode;\nvar Replacement = function Replacement(start, end, content, insertIndex, name) {\n  _classCallCheck(this, Replacement);\n  this.start = start;\n  this.end = end;\n  this.content = content;\n  this.insertIndex = insertIndex;\n  this.name = name;\n};\nvar ReplaceSource = /*#__PURE__*/function (_Source) {\n  _inherits(ReplaceSource, _Source);\n  function ReplaceSource(source, name) {\n    var _this;\n    _classCallCheck(this, ReplaceSource);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReplaceSource).call(this));\n    _this._source = source;\n    _this._name = name;\n    /** @type {Replacement[]} */\n    _this.replacements = [];\n    return _this;\n  }\n  _createClass(ReplaceSource, [{\n    key: \"replace\",\n    value: function replace(start, end, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n      this.replacements.push(new Replacement(start, end, newValue, this.replacements.length, name));\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n      this.replacements.push(new Replacement(pos, pos - 1, newValue, this.replacements.length, name));\n    }\n  }, {\n    key: \"source\",\n    value: function source(options) {\n      return this._replaceString(this._source.source());\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"_sortReplacements\",\n    value: function _sortReplacements() {\n      this.replacements.sort(function (a, b) {\n        var diff = b.end - a.end;\n        if (diff !== 0) return diff;\n        diff = b.start - a.start;\n        if (diff !== 0) return diff;\n        return b.insertIndex - a.insertIndex;\n      });\n    }\n  }, {\n    key: \"_replaceString\",\n    value: function _replaceString(str) {\n      if (typeof str !== \"string\") throw new Error(\"str must be a string, but is a \" + typeof str + \": \" + str);\n      this._sortReplacements();\n      var result = [str];\n      this.replacements.forEach(function (repl) {\n        var remSource = result.pop();\n        var splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n        var splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n        result.push(splitted1[1], repl.content, splitted2[0]);\n      }, this);\n\n      // write out result array in reverse order\n      var resultStr = \"\";\n      for (var i = result.length - 1; i >= 0; --i) {\n        resultStr += result[i];\n      }\n      return resultStr;\n    }\n  }, {\n    key: \"node\",\n    value: function node(options) {\n      var node = this._source.node(options);\n      if (this.replacements.length === 0) {\n        return node;\n      }\n      this._sortReplacements();\n      var replace = new ReplacementEnumerator(this.replacements);\n      var output = [];\n      var position = 0;\n      var sources = Object.create(null);\n      var sourcesInLines = Object.create(null);\n\n      // We build a new list of SourceNodes in \"output\"\n      // from the original mapping data\n\n      var result = new SourceNode();\n\n      // We need to add source contents manually\n      // because \"walk\" will not handle it\n      node.walkSourceContents(function (sourceFile, sourceContent) {\n        result.setSourceContent(sourceFile, sourceContent);\n        sources[\"$\" + sourceFile] = sourceContent;\n      });\n      var replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {\n        var key = \"$\" + mapping.source;\n        var lines = sourcesInLines[key];\n        if (!lines) {\n          var source = sources[key];\n          if (!source) return null;\n          lines = source.split(\"\\n\").map(function (line) {\n            return line + \"\\n\";\n          });\n          sourcesInLines[key] = lines;\n        }\n        // line is 1-based\n        if (mapping.line > lines.length) return null;\n        var line = lines[mapping.line - 1];\n        return line.substr(mapping.column);\n      });\n      node.walk(function (chunk, mapping) {\n        position = replaceInStringNode(chunk, position, mapping);\n      });\n\n      // If any replacements occur after the end of the original file, then we append them\n      // directly to the end of the output\n      var remaining = replace.footer();\n      if (remaining) {\n        output.push(remaining);\n      }\n      result.add(output);\n      return result;\n    }\n  }, {\n    key: \"listMap\",\n    value: function listMap(options) {\n      this._sortReplacements();\n      var map = this._source.listMap(options);\n      var currentIndex = 0;\n      var replacements = this.replacements;\n      var idxReplacement = replacements.length - 1;\n      var removeChars = 0;\n      map = map.mapGeneratedCode(function (str) {\n        var newCurrentIndex = currentIndex + str.length;\n        if (removeChars > str.length) {\n          removeChars -= str.length;\n          str = \"\";\n        } else {\n          if (removeChars > 0) {\n            str = str.substr(removeChars);\n            currentIndex += removeChars;\n            removeChars = 0;\n          }\n          var finalStr = \"\";\n          while (idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {\n            var repl = replacements[idxReplacement];\n            var start = Math.floor(repl.start);\n            var end = Math.floor(repl.end + 1);\n            var before = str.substr(0, Math.max(0, start - currentIndex));\n            if (end <= newCurrentIndex) {\n              var after = str.substr(Math.max(0, end - currentIndex));\n              finalStr += before + repl.content;\n              str = after;\n              currentIndex = Math.max(currentIndex, end);\n            } else {\n              finalStr += before + repl.content;\n              str = \"\";\n              removeChars = end - newCurrentIndex;\n            }\n            idxReplacement--;\n          }\n          str = finalStr + str;\n        }\n        currentIndex = newCurrentIndex;\n        return str;\n      });\n      var extraCode = \"\";\n      while (idxReplacement >= 0) {\n        extraCode += replacements[idxReplacement].content;\n        idxReplacement--;\n      }\n      if (extraCode) {\n        map.add(extraCode);\n      }\n      return map;\n    }\n  }, {\n    key: \"_splitString\",\n    value: function _splitString(str, position) {\n      return position <= 0 ? [\"\", str] : [str.substr(0, position), str.substr(position)];\n    }\n  }, {\n    key: \"_replaceInStringNode\",\n    value: function _replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {\n      var original = undefined;\n      do {\n        var splitPosition = replace.position - position;\n        // If multiple replaces occur in the same location then the splitPosition may be\n        // before the current position for the subsequent splits. Ensure it is >= 0\n        if (splitPosition < 0) {\n          splitPosition = 0;\n        }\n        if (splitPosition >= node.length || replace.done) {\n          if (replace.emit) {\n            var nodeEnd = new SourceNode(mapping.line, mapping.column, mapping.source, node, mapping.name);\n            output.push(nodeEnd);\n          }\n          return position + node.length;\n        }\n        var originalColumn = mapping.column;\n\n        // Try to figure out if generated code matches original code of this segement\n        // If this is the case we assume that it's allowed to move mapping.column\n        // Because getOriginalSource can be expensive we only do it when neccessary\n\n        var nodePart;\n        if (splitPosition > 0) {\n          nodePart = node.slice(0, splitPosition);\n          if (original === undefined) {\n            original = getOriginalSource(mapping);\n          }\n          if (original && original.length >= splitPosition && original.startsWith(nodePart)) {\n            mapping.column += splitPosition;\n            original = original.substr(splitPosition);\n          }\n        }\n        var emit = replace.next();\n        if (!emit) {\n          // Stop emitting when we have found the beginning of the string to replace.\n          // Emit the part of the string before splitPosition\n          if (splitPosition > 0) {\n            var nodeStart = new SourceNode(mapping.line, originalColumn, mapping.source, nodePart, mapping.name);\n            output.push(nodeStart);\n          }\n\n          // Emit the replacement value\n          if (replace.value) {\n            output.push(new SourceNode(mapping.line, mapping.column, mapping.source, replace.value, mapping.name || replace.name));\n          }\n        }\n\n        // Recurse with remainder of the string as there may be multiple replaces within a single node\n        node = node.substr(splitPosition);\n        position += splitPosition;\n      } while (true);\n    }\n  }]);\n  return ReplaceSource;\n}(Source);\nvar ReplacementEnumerator = /*#__PURE__*/function () {\n  /**\n   * @param {Replacement[]} replacements list of replacements\n   */\n  function ReplacementEnumerator(replacements) {\n    _classCallCheck(this, ReplacementEnumerator);\n    this.replacements = replacements || [];\n    this.index = this.replacements.length;\n    this.done = false;\n    this.emit = false;\n    // Set initial start position\n    this.next();\n  }\n  _createClass(ReplacementEnumerator, [{\n    key: \"next\",\n    value: function next() {\n      if (this.done) return true;\n      if (this.emit) {\n        // Start point found. stop emitting. set position to find end\n        var repl = this.replacements[this.index];\n        var end = Math.floor(repl.end + 1);\n        this.position = end;\n        this.value = repl.content;\n        this.name = repl.name;\n      } else {\n        // End point found. start emitting. set position to find next start\n        this.index--;\n        if (this.index < 0) {\n          this.done = true;\n        } else {\n          var nextRepl = this.replacements[this.index];\n          var start = Math.floor(nextRepl.start);\n          this.position = start;\n        }\n      }\n      if (this.position < 0) this.position = 0;\n      this.emit = !this.emit;\n      return this.emit;\n    }\n  }, {\n    key: \"footer\",\n    value: function footer() {\n      if (!this.done && !this.emit) this.next(); // If we finished _replaceInNode mid emit we advance to next entry\n      if (this.done) {\n        return [];\n      } else {\n        var resultStr = \"\";\n        for (var i = this.index; i >= 0; i--) {\n          var repl = this.replacements[i];\n          // this doesn't need to handle repl.name, because in SourceMaps generated code\n          // without pointer to original source can't have a name\n          resultStr += repl.content;\n        }\n        return resultStr;\n      }\n    }\n  }]);\n  return ReplacementEnumerator;\n}();\nrequire(\"./SourceAndMapMixin\")(ReplaceSource.prototype);\nmodule.exports = ReplaceSource;","map":null,"metadata":{},"sourceType":"script"}