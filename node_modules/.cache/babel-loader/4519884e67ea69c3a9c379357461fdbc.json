{"ast":null,"code":"function getRow(matrix, j) {\n  if (!matrix[j]) {\n    matrix[j] = [];\n  }\n  return matrix[j];\n}\nfunction findFirstVacantIndex(row) {\n  var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  while (row[x]) {\n    x++;\n  }\n  return x;\n}\nfunction transposeInPlace(matrix, maxSize) {\n  for (var i = 0; i < maxSize; i++) {\n    var rowI = getRow(matrix, i);\n    for (var j = 0; j < i; j++) {\n      var rowJ = getRow(matrix, j);\n      var temp = rowI[j];\n      rowI[j] = rowJ[i];\n      rowJ[i] = temp;\n    }\n  }\n}\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n  for (var r = 0; r < cell.rowspan; r++) {\n    var layoutRow = getRow(layout, baseRow + r);\n    for (var c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\nfunction updateOffset(offsets, base, span, value) {\n  offsets[base + span] = Math.max(offsets[base + span] || 0, offsets[base] + value);\n}\n\n/**\n * @typedef { object } TablePrinterCell\n * Cell definition for the table printer.\n *\n * @property { number } colspan Number of columns this cell occupies.\n * @property { number } rowspan Number of rows this cell occupies.\n * @property { string } text Cell contents (pre-wrapped).\n */\n\n/**\n * Render a table into string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString(tableRows, rowSpacing, colSpacing) {\n  var layout = [];\n  var colNumber = 0;\n  var rowNumber = tableRows.length;\n  var rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (var j = 0; j < rowNumber; j++) {\n    var layoutRow = getRow(layout, j);\n    var cells = tableRows[j];\n    var x = 0;\n    for (var i = 0; i < cells.length; i++) {\n      var cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      var cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n  }\n  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n  var outputLines = [];\n  var colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (var _x = 0; _x < colNumber; _x++) {\n    var y = 0;\n    var _cell = void 0;\n    while (y < rowNumber && (_cell = layout[_x][y])) {\n      if (!_cell.rendered) {\n        var cellWidth = 0;\n        for (var _j = 0; _j < _cell.lines.length; _j++) {\n          var line = _cell.lines[_j];\n          var lineOffset = rowOffsets[y] + _j;\n          outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[_x]) + line;\n          cellWidth = line.length > cellWidth ? line.length : cellWidth;\n        }\n        updateOffset(colOffsets, _x, _cell.colspan, cellWidth + colSpacing);\n        _cell.rendered = true;\n      }\n      y += _cell.rowspan;\n    }\n  }\n  return outputLines.join('\\n');\n}\nmodule.exports = {\n  tableToString: tableToString\n};","map":null,"metadata":{},"sourceType":"script"}