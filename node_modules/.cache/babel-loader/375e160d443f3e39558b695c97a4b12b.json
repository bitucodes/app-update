{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"/home/lenovo/Desktop/chatapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar path = require(\"path\");\nvar asyncLib = require(\"neo-async\");\nvar _require = require(\"tapable\"),\n  Tapable = _require.Tapable,\n  AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,\n  SyncWaterfallHook = _require.SyncWaterfallHook,\n  SyncBailHook = _require.SyncBailHook,\n  SyncHook = _require.SyncHook,\n  HookMap = _require.HookMap;\nvar NormalModule = require(\"./NormalModule\");\nvar RawModule = require(\"./RawModule\");\nvar RuleSet = require(\"./RuleSet\");\nvar cachedMerge = require(\"./util/cachedMerge\");\nvar EMPTY_RESOLVE_OPTIONS = {};\nvar MATCH_RESOURCE_REGEX = /^([^!]+)!=!/;\nvar loaderToIdent = function loaderToIdent(data) {\n  if (!data.options) {\n    return data.loader;\n  }\n  if (typeof data.options === \"string\") {\n    return data.loader + \"?\" + data.options;\n  }\n  if (typeof data.options !== \"object\") {\n    throw new Error(\"loader options must be string or object\");\n  }\n  if (data.ident) {\n    return data.loader + \"??\" + data.ident;\n  }\n  return data.loader + \"?\" + JSON.stringify(data.options);\n};\nvar identToLoaderRequest = function identToLoaderRequest(resultString) {\n  var idx = resultString.indexOf(\"?\");\n  if (idx >= 0) {\n    var loader = resultString.substr(0, idx);\n    var options = resultString.substr(idx + 1);\n    return {\n      loader: loader,\n      options: options\n    };\n  } else {\n    return {\n      loader: resultString,\n      options: undefined\n    };\n  }\n};\nvar dependencyCache = new WeakMap();\nvar NormalModuleFactory = /*#__PURE__*/function (_Tapable) {\n  _inherits(NormalModuleFactory, _Tapable);\n  function NormalModuleFactory(context, resolverFactory, options) {\n    var _this;\n    _classCallCheck(this, NormalModuleFactory);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NormalModuleFactory).call(this));\n    _this.hooks = {\n      resolver: new SyncWaterfallHook([\"resolver\"]),\n      factory: new SyncWaterfallHook([\"factory\"]),\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      createModule: new SyncBailHook([\"data\"]),\n      module: new SyncWaterfallHook([\"module\", \"data\"]),\n      createParser: new HookMap(function () {\n        return new SyncBailHook([\"parserOptions\"]);\n      }),\n      parser: new HookMap(function () {\n        return new SyncHook([\"parser\", \"parserOptions\"]);\n      }),\n      createGenerator: new HookMap(function () {\n        return new SyncBailHook([\"generatorOptions\"]);\n      }),\n      generator: new HookMap(function () {\n        return new SyncHook([\"generator\", \"generatorOptions\"]);\n      })\n    };\n    _this._pluginCompat.tap(\"NormalModuleFactory\", function (options) {\n      switch (options.name) {\n        case \"before-resolve\":\n        case \"after-resolve\":\n          options.async = true;\n          break;\n        case \"parser\":\n          _this.hooks.parser.for(\"javascript/auto\").tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n          return true;\n      }\n      var match;\n      match = /^parser (.+)$/.exec(options.name);\n      if (match) {\n        _this.hooks.parser.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n        return true;\n      }\n      match = /^create-parser (.+)$/.exec(options.name);\n      if (match) {\n        _this.hooks.createParser.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n        return true;\n      }\n    });\n    _this.resolverFactory = resolverFactory;\n    _this.ruleSet = new RuleSet(options.defaultRules.concat(options.rules));\n    _this.cachePredicate = typeof options.unsafeCache === \"function\" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);\n    _this.context = context || \"\";\n    _this.parserCache = Object.create(null);\n    _this.generatorCache = Object.create(null);\n    _this.hooks.factory.tap(\"NormalModuleFactory\", function () {\n      return function (result, callback) {\n        var resolver = _this.hooks.resolver.call(null);\n\n        // Ignored\n        if (!resolver) return callback();\n        resolver(result, function (err, data) {\n          if (err) return callback(err);\n\n          // Ignored\n          if (!data) return callback();\n\n          // direct module\n          if (typeof data.source === \"function\") return callback(null, data);\n          _this.hooks.afterResolve.callAsync(data, function (err, result) {\n            if (err) return callback(err);\n\n            // Ignored\n            if (!result) return callback();\n            var createdModule = _this.hooks.createModule.call(result);\n            if (!createdModule) {\n              if (!result.request) {\n                return callback(new Error(\"Empty dependency (no request)\"));\n              }\n              createdModule = new NormalModule(result);\n            }\n            createdModule = _this.hooks.module.call(createdModule, result);\n            return callback(null, createdModule);\n          });\n        });\n      };\n    });\n    _this.hooks.resolver.tap(\"NormalModuleFactory\", function () {\n      return function (data, callback) {\n        var contextInfo = data.contextInfo;\n        var context = data.context;\n        var request = data.request;\n        var loaderResolver = _this.getResolver(\"loader\");\n        var normalResolver = _this.getResolver(\"normal\", data.resolveOptions);\n        var matchResource = undefined;\n        var requestWithoutMatchResource = request;\n        var matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);\n        if (matchResourceMatch) {\n          matchResource = matchResourceMatch[1];\n          if (/^\\.\\.?\\//.test(matchResource)) {\n            matchResource = path.join(context, matchResource);\n          }\n          requestWithoutMatchResource = request.substr(matchResourceMatch[0].length);\n        }\n        var noPreAutoLoaders = requestWithoutMatchResource.startsWith(\"-!\");\n        var noAutoLoaders = noPreAutoLoaders || requestWithoutMatchResource.startsWith(\"!\");\n        var noPrePostAutoLoaders = requestWithoutMatchResource.startsWith(\"!!\");\n        var elements = requestWithoutMatchResource.replace(/^-?!+/, \"\").replace(/!!+/g, \"!\").split(\"!\");\n        var resource = elements.pop();\n        elements = elements.map(identToLoaderRequest);\n        asyncLib.parallel([function (callback) {\n          return _this.resolveRequestArray(contextInfo, context, elements, loaderResolver, callback);\n        }, function (callback) {\n          if (resource === \"\" || resource[0] === \"?\") {\n            return callback(null, {\n              resource: resource\n            });\n          }\n          normalResolver.resolve(contextInfo, context, resource, {}, function (err, resource, resourceResolveData) {\n            if (err) return callback(err);\n            callback(null, {\n              resourceResolveData: resourceResolveData,\n              resource: resource\n            });\n          });\n        }], function (err, results) {\n          if (err) return callback(err);\n          var loaders = results[0];\n          var resourceResolveData = results[1].resourceResolveData;\n          resource = results[1].resource;\n\n          // translate option idents\n          try {\n            var _iterator = _createForOfIteratorHelper(loaders),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var item = _step.value;\n                if (typeof item.options === \"string\" && item.options[0] === \"?\") {\n                  var ident = item.options.substr(1);\n                  item.options = _this.ruleSet.findOptionsByIdent(ident);\n                  item.ident = ident;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } catch (e) {\n            return callback(e);\n          }\n          if (resource === false) {\n            // ignored\n            return callback(null, new RawModule(\"/* (ignored) */\", \"ignored \".concat(context, \" \").concat(request), \"\".concat(request, \" (ignored)\")));\n          }\n          var userRequest = (matchResource !== undefined ? \"\".concat(matchResource, \"!=!\") : \"\") + loaders.map(loaderToIdent).concat([resource]).join(\"!\");\n          var resourcePath = matchResource !== undefined ? matchResource : resource;\n          var resourceQuery = \"\";\n          var queryIndex = resourcePath.indexOf(\"?\");\n          if (queryIndex >= 0) {\n            resourceQuery = resourcePath.substr(queryIndex);\n            resourcePath = resourcePath.substr(0, queryIndex);\n          }\n          var result = _this.ruleSet.exec({\n            resource: resourcePath,\n            realResource: matchResource !== undefined ? resource.replace(/\\?.*/, \"\") : resourcePath,\n            resourceQuery: resourceQuery,\n            issuer: contextInfo.issuer,\n            compiler: contextInfo.compiler\n          });\n          var settings = {};\n          var useLoadersPost = [];\n          var useLoaders = [];\n          var useLoadersPre = [];\n          var _iterator2 = _createForOfIteratorHelper(result),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var r = _step2.value;\n              if (r.type === \"use\") {\n                if (r.enforce === \"post\" && !noPrePostAutoLoaders) {\n                  useLoadersPost.push(r.value);\n                } else if (r.enforce === \"pre\" && !noPreAutoLoaders && !noPrePostAutoLoaders) {\n                  useLoadersPre.push(r.value);\n                } else if (!r.enforce && !noAutoLoaders && !noPrePostAutoLoaders) {\n                  useLoaders.push(r.value);\n                }\n              } else if (typeof r.value === \"object\" && r.value !== null && typeof settings[r.type] === \"object\" && settings[r.type] !== null) {\n                settings[r.type] = cachedMerge(settings[r.type], r.value);\n              } else {\n                settings[r.type] = r.value;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          asyncLib.parallel([_this.resolveRequestArray.bind(_assertThisInitialized(_assertThisInitialized(_this)), contextInfo, _this.context, useLoadersPost, loaderResolver), _this.resolveRequestArray.bind(_assertThisInitialized(_assertThisInitialized(_this)), contextInfo, _this.context, useLoaders, loaderResolver), _this.resolveRequestArray.bind(_assertThisInitialized(_assertThisInitialized(_this)), contextInfo, _this.context, useLoadersPre, loaderResolver)], function (err, results) {\n            if (err) return callback(err);\n            loaders = results[0].concat(loaders, results[1], results[2]);\n            process.nextTick(function () {\n              var type = settings.type;\n              var resolveOptions = settings.resolve;\n              callback(null, {\n                context: context,\n                request: loaders.map(loaderToIdent).concat([resource]).join(\"!\"),\n                dependencies: data.dependencies,\n                userRequest: userRequest,\n                rawRequest: request,\n                loaders: loaders,\n                resource: resource,\n                matchResource: matchResource,\n                resourceResolveData: resourceResolveData,\n                settings: settings,\n                type: type,\n                parser: _this.getParser(type, settings.parser),\n                generator: _this.getGenerator(type, settings.generator),\n                resolveOptions: resolveOptions\n              });\n            });\n          });\n        });\n      };\n    });\n    return _this;\n  }\n  _createClass(NormalModuleFactory, [{\n    key: \"create\",\n    value: function create(data, callback) {\n      var _this2 = this;\n      var dependencies = data.dependencies;\n      var cacheEntry = dependencyCache.get(dependencies[0]);\n      if (cacheEntry) return callback(null, cacheEntry);\n      var context = data.context || this.context;\n      var resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS;\n      var request = dependencies[0].request;\n      var contextInfo = data.contextInfo || {};\n      this.hooks.beforeResolve.callAsync({\n        contextInfo: contextInfo,\n        resolveOptions: resolveOptions,\n        context: context,\n        request: request,\n        dependencies: dependencies\n      }, function (err, result) {\n        if (err) return callback(err);\n\n        // Ignored\n        if (!result) return callback();\n        var factory = _this2.hooks.factory.call(null);\n\n        // Ignored\n        if (!factory) return callback();\n        factory(result, function (err, module) {\n          if (err) return callback(err);\n          if (module && _this2.cachePredicate(module)) {\n            var _iterator3 = _createForOfIteratorHelper(dependencies),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var d = _step3.value;\n                dependencyCache.set(d, module);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n          callback(null, module);\n        });\n      });\n    }\n  }, {\n    key: \"resolveRequestArray\",\n    value: function resolveRequestArray(contextInfo, context, array, resolver, callback) {\n      if (array.length === 0) return callback(null, []);\n      asyncLib.map(array, function (item, callback) {\n        resolver.resolve(contextInfo, context, item.loader, {}, function (err, result) {\n          if (err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) {\n            return resolver.resolve(contextInfo, context, item.loader + \"-loader\", {}, function (err2) {\n              if (!err2) {\n                err.message = err.message + \"\\n\" + \"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\\n\" + \"                 You need to specify '\".concat(item.loader, \"-loader' instead of '\").concat(item.loader, \"',\\n\") + \"                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed\";\n              }\n              callback(err);\n            });\n          }\n          if (err) return callback(err);\n          var optionsOnly = item.options ? {\n            options: item.options\n          } : undefined;\n          return callback(null, Object.assign({}, item, identToLoaderRequest(result), optionsOnly));\n        });\n      }, callback);\n    }\n  }, {\n    key: \"getParser\",\n    value: function getParser(type, parserOptions) {\n      var ident = type;\n      if (parserOptions) {\n        if (parserOptions.ident) {\n          ident = \"\".concat(type, \"|\").concat(parserOptions.ident);\n        } else {\n          ident = JSON.stringify([type, parserOptions]);\n        }\n      }\n      if (ident in this.parserCache) {\n        return this.parserCache[ident];\n      }\n      return this.parserCache[ident] = this.createParser(type, parserOptions);\n    }\n  }, {\n    key: \"createParser\",\n    value: function createParser(type) {\n      var parserOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var parser = this.hooks.createParser.for(type).call(parserOptions);\n      if (!parser) {\n        throw new Error(\"No parser registered for \".concat(type));\n      }\n      this.hooks.parser.for(type).call(parser, parserOptions);\n      return parser;\n    }\n  }, {\n    key: \"getGenerator\",\n    value: function getGenerator(type, generatorOptions) {\n      var ident = type;\n      if (generatorOptions) {\n        if (generatorOptions.ident) {\n          ident = \"\".concat(type, \"|\").concat(generatorOptions.ident);\n        } else {\n          ident = JSON.stringify([type, generatorOptions]);\n        }\n      }\n      if (ident in this.generatorCache) {\n        return this.generatorCache[ident];\n      }\n      return this.generatorCache[ident] = this.createGenerator(type, generatorOptions);\n    }\n  }, {\n    key: \"createGenerator\",\n    value: function createGenerator(type) {\n      var generatorOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var generator = this.hooks.createGenerator.for(type).call(generatorOptions);\n      if (!generator) {\n        throw new Error(\"No generator registered for \".concat(type));\n      }\n      this.hooks.generator.for(type).call(generator, generatorOptions);\n      return generator;\n    }\n  }, {\n    key: \"getResolver\",\n    value: function getResolver(type, resolveOptions) {\n      return this.resolverFactory.get(type, resolveOptions || EMPTY_RESOLVE_OPTIONS);\n    }\n  }]);\n  return NormalModuleFactory;\n}(Tapable);\nmodule.exports = NormalModuleFactory;","map":null,"metadata":{},"sourceType":"script"}