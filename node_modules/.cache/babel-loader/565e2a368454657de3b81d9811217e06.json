{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n// Generated by CoffeeScript 2.5.1\nvar SpecialString, i, len, prop, ref;\nmodule.exports = SpecialString = function () {\n  var self;\n  var SpecialString = /*#__PURE__*/function () {\n    function SpecialString(str) {\n      _classCallCheck(this, SpecialString);\n      if (!(this instanceof self)) {\n        return new self(str);\n      }\n      this._str = String(str);\n      this._len = 0;\n    }\n    _createClass(SpecialString, [{\n      key: \"_getStr\",\n      value: function _getStr() {\n        return this._str;\n      }\n    }, {\n      key: \"set\",\n      value: function set(str) {\n        this._str = String(str);\n        return this;\n      }\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new SpecialString(this._str);\n      }\n    }, {\n      key: \"isEmpty\",\n      value: function isEmpty() {\n        return this._str === '';\n      }\n    }, {\n      key: \"isOnlySpecialChars\",\n      value: function isOnlySpecialChars() {\n        return !this.isEmpty() && this.length === 0;\n      }\n    }, {\n      key: \"_reset\",\n      value: function _reset() {\n        return this._len = 0;\n      }\n    }, {\n      key: \"splitIn\",\n      value: function splitIn(limit) {\n        var trimLeftEachLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var buffer, bufferLength, justSkippedSkipChar, lines;\n        buffer = '';\n        bufferLength = 0;\n        lines = [];\n        justSkippedSkipChar = false;\n        self._countChars(this._str, function (char, charLength) {\n          if (bufferLength > limit || bufferLength + charLength > limit) {\n            lines.push(buffer);\n            buffer = '';\n            bufferLength = 0;\n          }\n          if (bufferLength === 0 && char === ' ' && !justSkippedSkipChar && trimLeftEachLine) {\n            return justSkippedSkipChar = true;\n          } else {\n            buffer += char;\n            bufferLength += charLength;\n            return justSkippedSkipChar = false;\n          }\n        });\n        if (buffer.length > 0) {\n          lines.push(buffer);\n        }\n        return lines;\n      }\n    }, {\n      key: \"trim\",\n      value: function trim() {\n        return new SpecialString(this.str.trim());\n      }\n    }, {\n      key: \"trimLeft\",\n      value: function trimLeft() {\n        return new SpecialString(this.str.replace(/^\\s+/, ''));\n      }\n    }, {\n      key: \"trimRight\",\n      value: function trimRight() {\n        return new SpecialString(this.str.replace(/\\s+$/, ''));\n      }\n    }, {\n      key: \"_getLength\",\n      value: function _getLength() {\n        var sum;\n        sum = 0;\n        self._countChars(this._str, function (char, charLength) {\n          sum += charLength;\n        });\n        return sum;\n      }\n    }, {\n      key: \"cut\",\n      value: function cut(from, to) {\n        var _this = this;\n        var trimLeft = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var after, before, cur, cut;\n        if (to == null) {\n          to = this.length;\n        }\n        from = parseInt(from);\n        if (from >= to) {\n          throw Error(\"`from` shouldn't be larger than `to`\");\n        }\n        before = '';\n        after = '';\n        cut = '';\n        cur = 0;\n        self._countChars(this._str, function (char, charLength) {\n          if (_this.str === 'ab<tag>') {\n            console.log(charLength, char);\n          }\n          if (cur === from && char.match(/^\\s+$/) && trimLeft) {\n            return;\n          }\n          if (cur < from) {\n            before += char; // let's be greedy\n          } else if (cur < to || cur + charLength <= to) {\n            cut += char;\n          } else {\n            after += char;\n          }\n          cur += charLength;\n        });\n        this._str = before + after;\n        this._reset();\n        return new SpecialString(cut);\n      }\n    }], [{\n      key: \"_countChars\",\n      value: function _countChars(text, cb) {\n        var char, charLength, m;\n        while (text.length !== 0) {\n          if (m = text.match(self._tagRx)) {\n            char = m[0];\n            charLength = 0;\n            text = text.substr(char.length, text.length);\n          } else if (m = text.match(self._quotedHtmlRx)) {\n            char = m[0];\n            charLength = 1;\n            text = text.substr(char.length, text.length);\n          } else if (text.match(self._tabRx)) {\n            char = \"\\t\";\n            charLength = 8;\n            text = text.substr(1, text.length);\n          } else {\n            char = text[0];\n            charLength = 1;\n            text = text.substr(1, text.length);\n          }\n          cb.call(null, char, charLength);\n        }\n      }\n    }]);\n    return SpecialString;\n  }();\n  ;\n  self = SpecialString;\n  SpecialString._tabRx = /^\\t/;\n  SpecialString._tagRx = /^<[^>]+>/;\n  SpecialString._quotedHtmlRx = /^&(gt|lt|quot|amp|apos|sp);/;\n  return SpecialString;\n}.call(void 0);\nref = ['str', 'length'];\nfor (i = 0, len = ref.length; i < len; i++) {\n  prop = ref[i];\n  (function () {\n    var methodName;\n    methodName = '_get' + prop[0].toUpperCase() + prop.substr(1, prop.length);\n    return SpecialString.prototype.__defineGetter__(prop, function () {\n      return this[methodName]();\n    });\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}